{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\r\n\r\npragma solidity =0.8.9;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.4.2\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\r\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() initializer {}\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\r\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\r\n        // contract may have been reentered.\r\n        require(\r\n            _initializing ? _isConstructor() : !_initialized,\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} modifier, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    function _isConstructor() private view returns (bool) {\r\n        return !AddressUpgradeable.isContract(address(this));\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.4.2\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n        __Context_init_unchained();\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {}\r\n\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol@v4.4.2\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal onlyInitializing {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal onlyInitializing {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    uint256[49] private __gap;\r\n}\r\n\r\n// File contracts/ProtocolConstants.sol\r\n\r\nabstract contract ProtocolConstants {\r\n    /* ========== GENERAL ========== */\r\n\r\n    // The zero address, utility\r\n    address internal constant _ZERO_ADDRESS = address(0);\r\n\r\n    // One year, utility\r\n    uint256 internal constant _ONE_YEAR = 365 days;\r\n\r\n    // Basis Points\r\n    uint256 internal constant _MAX_BASIS_POINTS = 100_00;\r\n\r\n    /* ========== VADER TOKEN ========== */\r\n\r\n    // Max VADER supply\r\n    uint256 internal constant _INITIAL_VADER_SUPPLY = 25_000_000_000 * 1 ether;\r\n\r\n    // Allocation for VETH holders\r\n    uint256 internal constant _VETH_ALLOCATION = 7_500_000_000 * 1 ether;\r\n\r\n    // Team allocation vested over {VESTING_DURATION} years\r\n    uint256 internal constant _TEAM_ALLOCATION = 2_500_000_000 * 1 ether;\r\n\r\n    // Ecosystem growth fund unlocked for partnerships & USDV provision\r\n    uint256 internal constant _ECOSYSTEM_GROWTH = 2_500_000_000 * 1 ether;\r\n\r\n    // Total grant tokens\r\n    uint256 internal constant _GRANT_ALLOCATION = 12_500_000_000 * 1 ether;\r\n\r\n    // Emission Era\r\n    uint256 internal constant _EMISSION_ERA = 24 hours;\r\n\r\n    // Initial Emission Curve, 5\r\n    uint256 internal constant _INITIAL_EMISSION_CURVE = 5;\r\n\r\n    // Fee Basis Points\r\n    uint256 internal constant _MAX_FEE_BASIS_POINTS = 1_00;\r\n\r\n    /* ========== USDV TOKEN ========== */\r\n\r\n    // Max locking duration\r\n    uint256 internal constant _MAX_LOCK_DURATION = 30 days;\r\n\r\n    /* ========== VESTING ========== */\r\n\r\n    // Vesting Duration\r\n    uint256 internal constant _VESTING_DURATION = 2 * _ONE_YEAR;\r\n\r\n    /* ========== CONVERTER ========== */\r\n\r\n    // Vader -> Vether Conversion Rate (10000:1)\r\n    uint256 internal constant _VADER_VETHER_CONVERSION_RATE = 10_000;\r\n\r\n    // Burn Address\r\n    address internal constant _BURN =\r\n        0xdeaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD;\r\n\r\n    /* ========== GAS QUEUE ========== */\r\n\r\n    // Address of Chainlink Fast Gas Price Oracle\r\n    address internal constant _FAST_GAS_ORACLE =\r\n        0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C;\r\n\r\n    /* ========== VADER RESERVE ========== */\r\n\r\n    // Minimum delay between grants\r\n    uint256 internal constant _GRANT_DELAY = 30 days;\r\n\r\n    // Maximum grant size divisor\r\n    uint256 internal constant _MAX_GRANT_BASIS_POINTS = 10_00;\r\n}\r\n\r\n// File contracts/interfaces/ILiquidityBasedTWAP.sol\r\n\r\ninterface ILiquidityBasedTWAP {\r\n    function maxUpdateWindow() external view returns (uint256);\r\n\r\n    function getVaderPrice() external returns (uint256);\r\n}\r\n\r\n// File contracts/VaderMinterStorage.sol\r\n\r\nstruct Limits {\r\n    uint256 fee;\r\n    uint256 mintLimit;\r\n    uint256 burnLimit;\r\n    uint256 lockDuration;\r\n}\r\n\r\ncontract VaderMinterStorage {\r\n    // The LBT pricing mechanism for the conversion\r\n    ILiquidityBasedTWAP public lbt;\r\n\r\n    // The 24 hour limits on USDV mints that are available for public minting and burning as well as the fee.\r\n    Limits public dailyLimits;\r\n\r\n    // The current cycle end timestamp\r\n    uint256 public cycleTimestamp;\r\n\r\n    // The current cycle cumulative mints\r\n    uint256 public cycleMints;\r\n\r\n    // The current cycle cumulative burns\r\n    uint256 public cycleBurns;\r\n\r\n    // The limits applied to each partner\r\n    mapping(address => Limits) public partnerLimits;\r\n\r\n    // Transmuter Contract\r\n    address public transmuter;\r\n}\r\n\r\n// File contracts/interfaces/IVaderMinterUpgradeable.sol\r\n\r\ninterface IVaderMinterUpgradeable {\r\n    /* ========== FUNCTIONS ========== */\r\n    function mint(uint256 vAmount, uint256 uAmountMinOut)\r\n        external\r\n        returns (uint256 uAmount);\r\n\r\n    function burn(uint256 uAmount, uint256 vAmountMinOut)\r\n        external\r\n        returns (uint256 vAmount);\r\n\r\n    function partnerMint(uint256 vAmount, uint256 uAmountMinOut)\r\n        external\r\n        returns (uint256 uAmount);\r\n\r\n    function partnerBurn(uint256 uAmount, uint256 vAmountMinOut)\r\n        external\r\n        returns (uint256 vAmount);\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event DailyLimitsChanged(Limits previousLimits, Limits nextLimits);\r\n    event WhitelistPartner(\r\n        address partner,\r\n        uint256 mintLimit,\r\n        uint256 burnLimit,\r\n        uint256 fee\r\n    );\r\n    event RemovePartner(address partner);\r\n    event SetPartnerFee(address indexed partner, uint256 fee);\r\n    event IncreasePartnerMintLimit(address indexed partner, uint256 mintLimit);\r\n    event DecreasePartnerMintLimit(address indexed partner, uint256 mintLimit);\r\n    event IncreasePartnerBurnLimit(address indexed partner, uint256 burnLimit);\r\n    event DecreasePartnerBurnLimit(address indexed partner, uint256 burnLimit);\r\n    event SetPartnerLockDuration(address indexed partner, uint256 lockDuration);\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.3.2\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File contracts/interfaces/IUSDV.sol\r\n\r\ninterface IUSDV is IERC20 {\r\n    /* ========== ENUMS ========== */\r\n\r\n    enum LockTypes {\r\n        USDV,\r\n        VADER\r\n    }\r\n\r\n    /* ========== STRUCTS ========== */\r\n\r\n    struct Lock {\r\n        LockTypes token;\r\n        uint256 amount;\r\n        uint256 release;\r\n    }\r\n\r\n    /* ========== FUNCTIONS ========== */\r\n\r\n    function mint(\r\n        address account,\r\n        uint256 vAmount,\r\n        uint256 uAmount,\r\n        uint256 exchangeFee,\r\n        uint256 window\r\n    ) external returns (uint256);\r\n\r\n    function burn(\r\n        address account,\r\n        uint256 uAmount,\r\n        uint256 vAmount,\r\n        uint256 exchangeFee,\r\n        uint256 window\r\n    ) external returns (uint256);\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event ExchangeFeeChanged(uint256 previousExchangeFee, uint256 exchangeFee);\r\n    event DailyLimitChanged(uint256 previousDailyLimit, uint256 dailyLimit);\r\n    event LockClaimed(\r\n        address user,\r\n        LockTypes lockType,\r\n        uint256 lockAmount,\r\n        uint256 lockRelease\r\n    );\r\n    event LockCreated(\r\n        address user,\r\n        LockTypes lockType,\r\n        uint256 lockAmount,\r\n        uint256 lockRelease\r\n    );\r\n    event ValidatorSet(address previous, address current);\r\n    event GuardianSet(address previous, address current);\r\n    event LockStatusSet(bool status);\r\n    event MinterSet(address minter);\r\n}\r\n\r\n// File contracts/VaderMinterUpgradeableV3.sol\r\n\r\ncontract VaderMinterUpgradeableV3 is\r\n    VaderMinterStorage,\r\n    IVaderMinterUpgradeable,\r\n    ProtocolConstants,\r\n    OwnableUpgradeable\r\n{\r\n    // USDV Contract for Mint / Burn Operations\r\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\r\n    IUSDV public immutable usdv;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor(address _usdv) {\r\n        require(_usdv != address(0), \"usdv = zero address\");\r\n        usdv = IUSDV(_usdv);\r\n    }\r\n\r\n    function initialize() external initializer {\r\n        __Ownable_init();\r\n        cycleTimestamp = block.timestamp;\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function getPublicFee() public view returns (uint256) {\r\n        // 24 hours passed, reset fee to 100%\r\n        if (block.timestamp >= cycleTimestamp) {\r\n            return dailyLimits.fee;\r\n        }\r\n\r\n        // cycle timestamp > block.timestamp, fee < 100%\r\n        return\r\n            (dailyLimits.fee * (cycleTimestamp - block.timestamp)) / 24 hours;\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @dev Public mint function that receives Vader and mints USDV.\r\n     * @param vAmount Vader amount to burn.\r\n     * @param uAmountMinOut USDV minimum amount to get back from the mint.\r\n     * @return uAmount in USDV, represents the USDV amount received from the mint.\r\n     */\r\n    function mint(uint256 vAmount, uint256 uAmountMinOut)\r\n        external\r\n        returns (uint256 uAmount)\r\n    {\r\n        uint256 vPrice = lbt.getVaderPrice();\r\n\r\n        uAmount = (vPrice * vAmount) / 1e18;\r\n\r\n        if (cycleTimestamp <= block.timestamp) {\r\n            cycleTimestamp = block.timestamp + 24 hours;\r\n            cycleMints = uAmount;\r\n            cycleBurns = 0;\r\n        } else {\r\n            cycleMints += uAmount;\r\n        }\r\n\r\n        require(\r\n            cycleMints <= dailyLimits.mintLimit,\r\n            \"VMU::mint: 24 Hour Limit Reached\"\r\n        );\r\n\r\n        // Actual amount of USDV minted including fees\r\n        uAmount = usdv.mint(\r\n            msg.sender,\r\n            vAmount,\r\n            uAmount,\r\n            getPublicFee(),\r\n            dailyLimits.lockDuration\r\n        );\r\n\r\n        require(\r\n            uAmount >= uAmountMinOut,\r\n            \"VMU::mint: Insufficient Trade Output\"\r\n        );\r\n\r\n        return uAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Public burn function that receives USDV and mints Vader.\r\n     * @param uAmount USDV amount to burn.\r\n     * @param vAmountMinOut Vader minimum amount to get back from the burn.\r\n     * @return vAmount in Vader, represents the Vader amount received from the burn.\r\n     *\r\n     */\r\n    function burn(uint256 uAmount, uint256 vAmountMinOut)\r\n        external\r\n        returns (uint256 vAmount)\r\n    {\r\n        uint256 vPrice = lbt.getVaderPrice();\r\n\r\n        vAmount = (1e18 * uAmount) / vPrice;\r\n\r\n        if (cycleTimestamp <= block.timestamp) {\r\n            cycleTimestamp = block.timestamp + 24 hours;\r\n            cycleBurns = uAmount;\r\n            cycleMints = 0;\r\n        } else {\r\n            cycleBurns += uAmount;\r\n        }\r\n\r\n        require(\r\n            cycleBurns <= dailyLimits.burnLimit,\r\n            \"VMU::burn: 24 Hour Limit Reached\"\r\n        );\r\n\r\n        // Actual amount of Vader minted including fees\r\n        vAmount = usdv.burn(\r\n            msg.sender,\r\n            uAmount,\r\n            vAmount,\r\n            getPublicFee(),\r\n            dailyLimits.lockDuration\r\n        );\r\n\r\n        require(\r\n            vAmount >= vAmountMinOut,\r\n            \"VMU::burn: Insufficient Trade Output\"\r\n        );\r\n\r\n        return vAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Public destroy function that burns USDV without minting Vader. Use with caution!\r\n     * @param uAmount USDV amount to burn permanently.\r\n     */\r\n    function unsafeDestroyUsdv(uint256 uAmount) external {\r\n        require(uAmount > 0, \"VMU::unsafeDestroyUsdv: Zero Input\");\r\n\r\n        uint256 vPrice = lbt.getVaderPrice();\r\n\r\n        // since 1 Vader will be minted, uAmount has to exceed that in value\r\n        require(\r\n            1e18 * uAmount >= vPrice,\r\n            \"VMU::unsafeDestroyUsdv: Minimum Amount\"\r\n        );\r\n\r\n        usdv.burn(msg.sender, uAmount, 1, _MAX_BASIS_POINTS, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Public destroy function that burns Vader without minting USDV. Use with caution!\r\n     * @param vAmount Vader amount to destroy permanently.\r\n     */\r\n    function unsafeDestroyVader(uint256 vAmount) external {\r\n        require(vAmount > 0, \"VMU::unsafeDestroyVader: Zero Input\");\r\n\r\n        uint256 vPrice = lbt.getVaderPrice();\r\n\r\n        // since 1 USDV will be minted, vAmount has to exceed that in value\r\n        require(\r\n            vPrice * vAmount >= 1e18,\r\n            \"VMU::unsafeDestroyVader: Minimum Amount\"\r\n        );\r\n\r\n        usdv.mint(msg.sender, vAmount, 1, _MAX_BASIS_POINTS, 0);\r\n    }\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @dev Partner mint function that receives Vader and mints USDV.\r\n     * @param vAmount Vader amount to burn.\r\n     * @param uAmountMinOut USDV minimum amount to get back from the mint.\r\n     * @return uAmount in USDV, represents the USDV amount received from the mint.\r\n     *\r\n     * Requirements:\r\n     * - Can only be called by whitelisted partners.\r\n     */\r\n    function partnerMint(uint256 vAmount, uint256 uAmountMinOut)\r\n        external\r\n        returns (uint256 uAmount)\r\n    {\r\n        require(\r\n            partnerLimits[msg.sender].mintLimit != 0,\r\n            \"VMU::partnerMint: Not Whitelisted\"\r\n        );\r\n        uint256 vPrice = lbt.getVaderPrice();\r\n\r\n        uAmount = (vPrice * vAmount) / 1e18;\r\n\r\n        Limits storage _partnerLimits = partnerLimits[msg.sender];\r\n\r\n        require(\r\n            uAmount <= _partnerLimits.mintLimit,\r\n            \"VMU::partnerMint: Mint Limit Reached\"\r\n        );\r\n\r\n        unchecked {\r\n            _partnerLimits.mintLimit -= uAmount;\r\n        }\r\n\r\n        uAmount = usdv.mint(\r\n            msg.sender,\r\n            vAmount,\r\n            uAmount,\r\n            _partnerLimits.fee,\r\n            _partnerLimits.lockDuration\r\n        );\r\n\r\n        require(\r\n            uAmount >= uAmountMinOut,\r\n            \"VMU::partnerMint: Insufficient Trade Output\"\r\n        );\r\n\r\n        return uAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Partner burn function that receives USDV and mints Vader.\r\n     * @param uAmount USDV amount to burn.\r\n     * @param vAmountMinOut Vader minimum amount to get back from the burn.\r\n     * @return vAmount in Vader, represents the Vader amount received from the mint.\r\n     *\r\n     * Requirements:\r\n     * - Can only be called by whitelisted partners.\r\n     */\r\n    function partnerBurn(uint256 uAmount, uint256 vAmountMinOut)\r\n        external\r\n        returns (uint256 vAmount)\r\n    {\r\n        require(\r\n            partnerLimits[msg.sender].burnLimit != 0,\r\n            \"VMU::partnerBurn: Not Whitelisted\"\r\n        );\r\n        uint256 vPrice = lbt.getVaderPrice();\r\n\r\n        vAmount = (1e18 * uAmount) / vPrice;\r\n\r\n        Limits storage _partnerLimits = partnerLimits[msg.sender];\r\n\r\n        require(\r\n            uAmount <= _partnerLimits.burnLimit,\r\n            \"VMU::partnerBurn: Burn Limit Reached\"\r\n        );\r\n\r\n        unchecked {\r\n            _partnerLimits.burnLimit -= uAmount;\r\n        }\r\n\r\n        vAmount = usdv.burn(\r\n            msg.sender,\r\n            uAmount,\r\n            vAmount,\r\n            _partnerLimits.fee,\r\n            _partnerLimits.lockDuration\r\n        );\r\n\r\n        require(\r\n            vAmount >= vAmountMinOut,\r\n            \"VMU::partnerBurn: Insufficient Trade Output\"\r\n        );\r\n\r\n        return vAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the daily limits for public mints represented by the param {_dailyMintLimit}.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     * - Param {_fee} fee can not be bigger than _MAX_BASIS_POINTS.\r\n     * - Param {_mintLimit} mint limit can be 0.\r\n     * - Param {_burnLimit} burn limit can be 0.\r\n     * - Param {_lockDuration} lock duration can be 0.\r\n     */\r\n    function setDailyLimits(\r\n        uint256 _fee,\r\n        uint256 _mintLimit,\r\n        uint256 _burnLimit,\r\n        uint256 _lockDuration\r\n    ) external onlyOwner {\r\n        require(_fee <= _MAX_BASIS_POINTS, \"VMU::setDailyLimits: Invalid Fee\");\r\n        require(\r\n            _lockDuration <= _MAX_LOCK_DURATION,\r\n            \"VMU::setDailyLimits: Invalid lock duration\"\r\n        );\r\n\r\n        Limits memory _dailyLimits = Limits({\r\n            fee: _fee,\r\n            mintLimit: _mintLimit,\r\n            burnLimit: _burnLimit,\r\n            lockDuration: _lockDuration\r\n        });\r\n\r\n        emit DailyLimitsChanged(dailyLimits, _dailyLimits);\r\n        dailyLimits = _dailyLimits;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the a partner address {_partner }  to a given limit {_limits} that represents the ability\r\n     * to mint USDV from the reserve partners minting allocation.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     * - Param {_partner} cannot be a zero address.\r\n     * - Param {_fee} fee can not be bigger than _MAX_BASIS_POINTS.\r\n     * - Param {_mintLimit} mint limits can be 0.\r\n     * - Param {_burnLimit} burn limits can be 0.\r\n     * - Param {_lockDuration} lock duration can be 0.\r\n     */\r\n    function whitelistPartner(\r\n        address _partner,\r\n        uint256 _fee,\r\n        uint256 _mintLimit,\r\n        uint256 _burnLimit,\r\n        uint256 _lockDuration\r\n    ) external onlyOwner {\r\n        require(_partner != address(0), \"VMU::whitelistPartner: Zero Address\");\r\n        require(\r\n            _fee <= _MAX_BASIS_POINTS,\r\n            \"VMU::whitelistPartner: Invalid Fee\"\r\n        );\r\n        require(\r\n            _lockDuration <= _MAX_LOCK_DURATION,\r\n            \"VMU::whitelistPartner: Invalid lock duration\"\r\n        );\r\n\r\n        emit WhitelistPartner(_partner, _mintLimit, _burnLimit, _fee);\r\n        partnerLimits[_partner] = Limits({\r\n            fee: _fee,\r\n            mintLimit: _mintLimit,\r\n            burnLimit: _burnLimit,\r\n            lockDuration: _lockDuration\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @dev Remove partner\r\n     * @param _partner Address of partner.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     */\r\n    function removePartner(address _partner) external onlyOwner {\r\n        delete partnerLimits[_partner];\r\n        emit RemovePartner(_partner);\r\n    }\r\n\r\n    /**\r\n     * @dev Set partner fee\r\n     * @param _partner Address of partner.\r\n     * @param _fee New fee.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     * - Param {_fee} fee can not be bigger than _MAX_BASIS_POINTS.\r\n     */\r\n    function setPartnerFee(address _partner, uint256 _fee) external onlyOwner {\r\n        require(_fee <= _MAX_BASIS_POINTS, \"VMU::setPartnerFee: Invalid Fee\");\r\n        partnerLimits[_partner].fee = _fee;\r\n        emit SetPartnerFee(_partner, _fee);\r\n    }\r\n\r\n    /**\r\n     * @dev Increase partner mint limit.\r\n     * @param _partner Address of partner.\r\n     * @param _amount Amount to increase the mint limit by.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     */\r\n    function increasePartnerMintLimit(address _partner, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        Limits storage limits = partnerLimits[_partner];\r\n        limits.mintLimit += _amount;\r\n        emit IncreasePartnerMintLimit(_partner, limits.mintLimit);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease partner mint limit.\r\n     * @param _partner Address of partner.\r\n     * @param _amount Amount to decrease the mint limit by.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     */\r\n    function decreasePartnerMintLimit(address _partner, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        Limits storage limits = partnerLimits[_partner];\r\n        limits.mintLimit -= _amount;\r\n        emit DecreasePartnerMintLimit(_partner, limits.mintLimit);\r\n    }\r\n\r\n    /**\r\n     * @dev Increase partner mint limit.\r\n     * @param _partner Address of partner.\r\n     * @param _amount Amount to increase the burn limit by.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     */\r\n    function increasePartnerBurnLimit(address _partner, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        Limits storage limits = partnerLimits[_partner];\r\n        limits.burnLimit += _amount;\r\n        emit IncreasePartnerBurnLimit(_partner, limits.burnLimit);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease partner mint limit.\r\n     * @param _partner Address of partner.\r\n     * @param _amount Amount to decrease the burn limit by.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     */\r\n    function decreasePartnerBurnLimit(address _partner, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        Limits storage limits = partnerLimits[_partner];\r\n        limits.burnLimit -= _amount;\r\n        emit DecreasePartnerBurnLimit(_partner, limits.burnLimit);\r\n    }\r\n\r\n    /**\r\n     * @dev Set partner lock duration.\r\n     * @param _partner Address of partner.\r\n     * @param _lockDuration New lock duration\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     * - Param {_lockDuration} cannot be bigger than _MAX_LOCK_DURATION\r\n     */\r\n    function setPartnerLockDuration(address _partner, uint256 _lockDuration)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _lockDuration <= _MAX_LOCK_DURATION,\r\n            \"VMU::setPartnerLockDuration: Invalid lock duration\"\r\n        );\r\n        partnerLimits[_partner].lockDuration = _lockDuration;\r\n        emit SetPartnerLockDuration(_partner, _lockDuration);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the transmuter contract address represented by the param {_transmuter}.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     * - Param {_transmuter} can not be address ZERO.\r\n     */\r\n    function setTransmuterAddress(address _transmuter) external onlyOwner {\r\n        require(\r\n            _transmuter != address(0),\r\n            \"VMU::setTransmuterAddress: Zero Address\"\r\n        );\r\n        transmuter = _transmuter;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the lbt contract address represented by the param {_lbt}.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     * - Param {_lbt} can not be address ZERO.\r\n     */\r\n    function setLBT(ILiquidityBasedTWAP _lbt) external onlyOwner {\r\n        require(\r\n            _lbt != ILiquidityBasedTWAP(address(0)),\r\n            \"VMU::setLBT: Zero Address\"\r\n        );\r\n        lbt = _lbt;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdv\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Limits\",\"name\":\"previousLimits\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Limits\",\"name\":\"nextLimits\",\"type\":\"tuple\"}],\"name\":\"DailyLimitsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnLimit\",\"type\":\"uint256\"}],\"name\":\"DecreasePartnerBurnLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintLimit\",\"type\":\"uint256\"}],\"name\":\"DecreasePartnerMintLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnLimit\",\"type\":\"uint256\"}],\"name\":\"IncreasePartnerBurnLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintLimit\",\"type\":\"uint256\"}],\"name\":\"IncreasePartnerMintLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"RemovePartner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SetPartnerFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"}],\"name\":\"SetPartnerLockDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"WhitelistPartner\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vAmountMinOut\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleBurns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decreasePartnerBurnLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decreasePartnerMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPublicFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increasePartnerBurnLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increasePartnerMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lbt\",\"outputs\":[{\"internalType\":\"contract ILiquidityBasedTWAP\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uAmountMinOut\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vAmountMinOut\",\"type\":\"uint256\"}],\"name\":\"partnerBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partnerLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uAmountMinOut\",\"type\":\"uint256\"}],\"name\":\"partnerMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"removePartner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"}],\"name\":\"setDailyLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILiquidityBasedTWAP\",\"name\":\"_lbt\",\"type\":\"address\"}],\"name\":\"setLBT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setPartnerFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"}],\"name\":\"setPartnerLockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transmuter\",\"type\":\"address\"}],\"name\":\"setTransmuterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transmuter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"}],\"name\":\"unsafeDestroyUsdv\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vAmount\",\"type\":\"uint256\"}],\"name\":\"unsafeDestroyVader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdv\",\"outputs\":[{\"internalType\":\"contract IUSDV\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"}],\"name\":\"whitelistPartner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VaderMinterUpgradeableV3", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ea3fb6f331735252e7bfb0b24b3b761301293dbe", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://239268474b146c3d4ea02be75c2952b6cadb778c637b8aaf7dfcfdcb64b89d2b"}]}