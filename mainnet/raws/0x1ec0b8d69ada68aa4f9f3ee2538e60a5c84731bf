{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL v3\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract MSNN_MINING {\r\n    uint256 public payable_amount;\r\n\r\n    address private MSNNAddr;\r\n    address private MiningOwner;\r\n\r\n    mapping(address => string) private keepers; //keeper account can add add_merkle_root\r\n    mapping(bytes32 => uint256) private merkleRoots; // merkleRoot=>balance\r\n    mapping(bytes32 => mapping(uint256 => bool)) private claimed; //bytes32 merkleRoot => (index => true|false)\r\n\r\n    mapping(address => uint256) private acc_staking;\r\n\r\n    constructor(address _MSNNcontractAddr) {\r\n        MiningOwner = msg.sender;\r\n        MSNNAddr = _MSNNcontractAddr;\r\n        keepers[msg.sender] = \"MiningOwner\";\r\n    }\r\n\r\n    modifier onlyMiningOwner() {\r\n        require(msg.sender == MiningOwner, \"only MiningOwner\");\r\n        _;\r\n    }\r\n\r\n    event set_MiningOwner_EVENT(\r\n        address trigger_user_addr,\r\n        address oldOwner,\r\n        address newOwner,\r\n        uint256 blocktime\r\n    );\r\n\r\n    function set_MiningOwner(address _newOwner) external onlyMiningOwner {\r\n        require(\r\n            _newOwner != MiningOwner,\r\n            \"The new owner must be different from the old\"\r\n        );\r\n        address oldMiningOwner = MiningOwner;\r\n        delete keepers[oldMiningOwner];\r\n        MiningOwner = _newOwner;\r\n        keepers[_newOwner] = \"MiningOwner\";\r\n        emit set_MiningOwner_EVENT(\r\n            msg.sender,\r\n            oldMiningOwner,\r\n            _newOwner,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function get_MiningOwner() external view returns (address) {\r\n        return MiningOwner;\r\n    }\r\n\r\n    function get_msn_addr() public view returns (address) {\r\n        return MSNNAddr;\r\n    }\r\n\r\n    function get_contract_balance() public view returns (uint256) {\r\n        return IERC20(MSNNAddr).balanceOf(address(this));\r\n    }\r\n\r\n    function get_keeper(address keeper_addr)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        require(bytes(keepers[keeper_addr]).length != 0, \"No such a keeper\");\r\n        return keepers[keeper_addr];\r\n    }\r\n\r\n    event add_keeper_EVENT(\r\n        address trigger_user_addr,\r\n        address keeper_addr,\r\n        string keeper_name,\r\n        uint256 blocktime\r\n    );\r\n\r\n    function add_keeper(address keeper_addr, string calldata keeper_name)\r\n        external\r\n        onlyMiningOwner\r\n    {\r\n        require(bytes(keeper_name).length != 0, \"No name\");\r\n        keepers[keeper_addr] = keeper_name;\r\n        emit add_keeper_EVENT(\r\n            msg.sender,\r\n            keeper_addr,\r\n            keeper_name,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    event remove_keeper_EVENT(\r\n        address trigger_user_addr,\r\n        address keeper_addr,\r\n        string keeper_name,\r\n        uint256 blocktime\r\n    );\r\n\r\n    function remove_keeper(address keeper_addr) external onlyMiningOwner {\r\n        require(bytes(keepers[keeper_addr]).length != 0, \"No such a keeper\");\r\n        require(keeper_addr != MiningOwner, \"Can not delete MiningOwner\");\r\n        string memory keeper_name = keepers[keeper_addr];\r\n        delete keepers[keeper_addr];\r\n        emit remove_keeper_EVENT(\r\n            msg.sender,\r\n            keeper_addr,\r\n            keeper_name,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    modifier onlyKeeper() {\r\n        require(bytes(keepers[msg.sender]).length != 0, \"No such a keeper\");\r\n        _;\r\n    }\r\n\r\n    event add_merkle_root_EVENT(\r\n        address trigger_user_addr,\r\n        bytes32 merkleRoot,\r\n        uint256 amount,\r\n        uint256 blocktime\r\n    );\r\n\r\n    function set_merkle_root(bytes32 merkleRoot, uint256 amount)\r\n        external\r\n        onlyKeeper\r\n    {\r\n        merkleRoots[merkleRoot] = amount + 1; // +1 for never to 0 again\r\n        emit add_merkle_root_EVENT(\r\n            msg.sender,\r\n            merkleRoot,\r\n            amount,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    event remove_merkle_root_EVENT(\r\n        address trigger_user_addr,\r\n        bytes32 merkleRoot,\r\n        uint256 blocktime\r\n    );\r\n\r\n    function remove_merkle_root(bytes32 merkleRoot) external onlyMiningOwner {\r\n        delete merkleRoots[merkleRoot];\r\n        emit remove_merkle_root_EVENT(msg.sender, merkleRoot, block.timestamp);\r\n    }\r\n\r\n    function get_merkle_balance(bytes32 merkleRoot)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return merkleRoots[merkleRoot];\r\n    }\r\n\r\n    event claim_erc20_EVENT(\r\n        address trigger_user_addr,\r\n        bytes32 merkleRoot,\r\n        uint256 amount,\r\n        uint256 time\r\n    );\r\n\r\n    function claim_erc20(\r\n        bytes32 merkleRoot,\r\n        uint256 index,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof\r\n    ) external {\r\n        require(merkleRoots[merkleRoot] != 0, \"The merkleRoot doesn't exist\");\r\n        require(claimed[merkleRoot][index] == false, \"Already claimed\");\r\n\r\n        bytes32 leaf = keccak256(abi.encodePacked(index, msg.sender, amount));\r\n        bool verify = MerkleProof.verify(merkleProof, merkleRoot, leaf);\r\n        require(verify == true, \"Not verified\");\r\n\r\n        require(merkleRoots[merkleRoot] > amount, \"Not enough balance\");\r\n        merkleRoots[merkleRoot] -= amount;\r\n\r\n        claimed[merkleRoot][index] = true;\r\n        bool result = IERC20(MSNNAddr).transfer(msg.sender, amount);\r\n        require(result == true, \"transfer error\");\r\n        emit claim_erc20_EVENT(msg.sender, merkleRoot, amount, block.timestamp);\r\n    }\r\n\r\n    function erc20_claimed(bytes32 merkleRoot, uint256 index)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return  claimed[merkleRoot][index];\r\n    }\r\n\r\n    event stake_token_EVENT(\r\n        address trigger_user_addr,\r\n        uint256 amount,\r\n        string userid,\r\n        uint256 blocktime\r\n    );\r\n\r\n    function stake_token(uint256 amount, string calldata userid) external {\r\n        uint256 allowance = IERC20(MSNNAddr).allowance(\r\n            msg.sender,\r\n            address(this)\r\n        );\r\n        require(allowance > 0, \"Not allowed\");\r\n        bool t_result = IERC20(MSNNAddr).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n        require(t_result == true, \"transfer error\");\r\n        acc_staking[msg.sender] += amount;\r\n        emit stake_token_EVENT(msg.sender, amount, userid, block.timestamp);\r\n    }\r\n\r\n    function get_acc_staking(address addr) public view returns (uint256) {\r\n        return acc_staking[addr];\r\n    }\r\n\r\n    receive() external payable {\r\n        payable_amount += msg.value;\r\n    }\r\n\r\n    fallback() external payable {\r\n        payable_amount += msg.value;\r\n    }\r\n\r\n    event withdraw_eth_EVENT(\r\n        address trigger_user_addr,\r\n        uint256 _amount,\r\n        uint256 blocktime\r\n    );\r\n\r\n    function withdraw_eth() external onlyMiningOwner {\r\n        uint256 amout_to_t = address(this).balance;\r\n        payable(msg.sender).transfer(amout_to_t);\r\n        payable_amount = 0;\r\n        emit withdraw_eth_EVENT(msg.sender, amout_to_t, block.timestamp);\r\n    }\r\n\r\n    event withdraw_contract_EVENT(\r\n        address trigger_user_addr,\r\n        address _from,\r\n        uint256 amount,\r\n        uint256 blocktime\r\n    );\r\n\r\n    function withdraw_contract() public onlyMiningOwner {\r\n        uint256 left = IERC20(MSNNAddr).balanceOf(address(this));\r\n        require(left > 0, \"No balance\");\r\n        IERC20(MSNNAddr).transfer(msg.sender, left);\r\n        emit withdraw_contract_EVENT(\r\n            msg.sender,\r\n            address(this),\r\n            left,\r\n            block.timestamp\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_MSNNcontractAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trigger_user_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keeper_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"keeper_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"add_keeper_EVENT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trigger_user_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"add_merkle_root_EVENT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trigger_user_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"claim_erc20_EVENT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trigger_user_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keeper_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"keeper_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"remove_keeper_EVENT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trigger_user_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"remove_merkle_root_EVENT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trigger_user_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"set_MiningOwner_EVENT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trigger_user_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"userid\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"stake_token_EVENT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trigger_user_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"withdraw_contract_EVENT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trigger_user_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"withdraw_eth_EVENT\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper_addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"keeper_name\",\"type\":\"string\"}],\"name\":\"add_keeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim_erc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"erc20_claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_MiningOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"get_acc_staking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_contract_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper_addr\",\"type\":\"address\"}],\"name\":\"get_keeper\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"get_merkle_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_msn_addr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payable_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper_addr\",\"type\":\"address\"}],\"name\":\"remove_keeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"remove_merkle_root\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"set_MiningOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"set_merkle_root\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"userid\",\"type\":\"string\"}],\"name\":\"stake_token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw_contract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw_eth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MSNN_MINING", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000096311848c9977682eef4156424e4e447b1af23ad", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://325aacaff4206c6970d4c7d40b2890f2c57e79a2e53ba7c2c4de371df2f446fc"}]}