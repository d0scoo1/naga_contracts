{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.9.9 https://hardhat.org\r\n\r\n// File contracts/oracle/IOracleRelay.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\n\r\n/// @title OracleRelay Interface\r\n/// @notice Interface for interacting with OracleRelay\r\ninterface IOracleRelay {\r\n  // returns  price with 18 decimals\r\n  function currentValue() external view returns (uint256);\r\n}\r\n\r\n// File contracts/_external/uniswap/IUniswapV3PoolDerivedState.sol\r\n\r\n/// @title Pool state that is not stored\r\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\r\n/// blockchain. The functions here may have variable gas costs.\r\ninterface IUniswapV3PoolDerivedState {\r\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\r\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\r\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\r\n  /// you must call it with secondsAgos = [3600, 0].\r\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\r\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\r\n  /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\r\n  /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\r\n  /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\r\n  /// timestamp\r\n  function observe(uint32[] calldata secondsAgos)\r\n    external\r\n    view\r\n    returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\r\n\r\n  /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\r\n  /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\r\n  /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\r\n  /// snapshot is taken and the second snapshot is taken.\r\n  /// @param tickLower The lower tick of the range\r\n  /// @param tickUpper The upper tick of the range\r\n  /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\r\n  /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\r\n  /// @return secondsInside The snapshot of seconds per liquidity for the range\r\n  function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\r\n    external\r\n    view\r\n    returns (\r\n      int56 tickCumulativeInside,\r\n      uint160 secondsPerLiquidityInsideX128,\r\n      uint32 secondsInside\r\n    );\r\n}\r\n\r\n// File contracts/_external/uniswap/TickMath.sol\r\n\r\n/// @title Math library for computing sqrt prices from ticks and vice versa\r\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\r\n/// prices between 2**-128 and 2**128\r\nlibrary TickMath {\r\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n  int24 internal constant MIN_TICK = -887272;\r\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n  int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\r\n\r\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n  /// @dev Throws if |tick| > max tick\r\n  /// @param tick The input tick for the above formula\r\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n  /// at the given tick\r\n  function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\r\n    uint256 absTick = (tick < 0) ? uint256(-int256(tick)) : uint256(int256(tick));\r\n    require(absTick <= uint256(int256(MAX_TICK)), \"T\");\r\n\r\n    uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\r\n    if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n    if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n    if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n    if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n    if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n    if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n    if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n    if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n    if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n    if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n    if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n    if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n    if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n    if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n    if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n    if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n    if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n    if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n    if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n    if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n    sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\r\n  }\r\n\r\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\r\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\r\n  /// ever return.\r\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\r\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\r\n  function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\r\n    // second inequality must be < because the price can never reach the price at the max tick\r\n    require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \"R\");\r\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\r\n\r\n    uint256 r = ratio;\r\n    uint256 msb = 0;\r\n\r\n    assembly {\r\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n      msb := or(msb, f)\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\r\n      msb := or(msb, f)\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      let f := shl(5, gt(r, 0xFFFFFFFF))\r\n      msb := or(msb, f)\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      let f := shl(4, gt(r, 0xFFFF))\r\n      msb := or(msb, f)\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      let f := shl(3, gt(r, 0xFF))\r\n      msb := or(msb, f)\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      let f := shl(2, gt(r, 0xF))\r\n      msb := or(msb, f)\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      let f := shl(1, gt(r, 0x3))\r\n      msb := or(msb, f)\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      let f := gt(r, 0x1)\r\n      msb := or(msb, f)\r\n    }\r\n\r\n    if (msb >= 128) r = ratio >> (msb - 127);\r\n    else r = ratio << (127 - msb);\r\n\r\n    int256 log_2 = (int256(msb) - 128) << 64;\r\n\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(63, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(62, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(61, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(60, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(59, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(58, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(57, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(56, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(55, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(54, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(53, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(52, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(51, f))\r\n      r := shr(f, r)\r\n    }\r\n    assembly {\r\n      r := shr(127, mul(r, r))\r\n      let f := shr(128, r)\r\n      log_2 := or(log_2, shl(50, f))\r\n    }\r\n\r\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\r\n\r\n    int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\r\n    int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\r\n\r\n    tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\r\n  }\r\n}\r\n\r\n// File contracts/oracle/External/UniswapV3OracleRelay.sol\r\n\r\n/// @title Oracle that wraps a univ3 pool\r\n/// @notice The oracle returns (univ3) * mul / div\r\n/// if quote_token_is_token0 == true, then the reciprocal is returned\r\ncontract UniswapV3OracleRelay is IOracleRelay {\r\n  bool public immutable _quoteTokenIsToken0;\r\n  IUniswapV3PoolDerivedState public immutable _pool;\r\n  uint32 public immutable _lookback;\r\n\r\n  uint256 public immutable _mul;\r\n  uint256 public immutable _div;\r\n\r\n  /// @notice all values set at construction time\r\n  /// @param lookback how many seconds to twap for\r\n  /// @param  pool_address address of chainlink feed\r\n  /// @param quote_token_is_token0 marker for which token to use as quote/base in calculation\r\n  /// @param mul numerator of scalar\r\n  /// @param div denominator of scalar\r\n  constructor(\r\n    uint32 lookback,\r\n    address pool_address,\r\n    bool quote_token_is_token0,\r\n    uint256 mul,\r\n    uint256 div\r\n  ) {\r\n    _lookback = lookback;\r\n    _mul = mul;\r\n    _div = div;\r\n    _quoteTokenIsToken0 = quote_token_is_token0;\r\n    _pool = IUniswapV3PoolDerivedState(pool_address);\r\n  }\r\n\r\n  /// @notice the current reported value of the oracle\r\n  /// @return the current value\r\n  /// @dev implementation in getLastSecond\r\n  function currentValue() external view override returns (uint256) {\r\n    return getLastSeconds(_lookback);\r\n  }\r\n\r\n  function getLastSeconds(uint32 seconds_) private view returns (uint256 price) {\r\n    int56[] memory tickCumulatives;\r\n    uint32[] memory input = new uint32[](2);\r\n    input[0] = seconds_;\r\n    input[1] = 0;\r\n\r\n    (tickCumulatives, ) = _pool.observe(input);\r\n\r\n    uint32 tickTimeDifference = seconds_;\r\n    int56 tickCumulativeDifference = tickCumulatives[0] - tickCumulatives[1];\r\n    bool tickNegative = tickCumulativeDifference < 0;\r\n    uint56 tickAbs;\r\n    if (tickNegative) {\r\n      tickAbs = uint56(-tickCumulativeDifference);\r\n    } else {\r\n      tickAbs = uint56(tickCumulativeDifference);\r\n    }\r\n\r\n    uint56 bigTick = tickAbs / tickTimeDifference;\r\n    require(bigTick < 887272, \"Tick time diff fail\");\r\n    int24 tick;\r\n    if (tickNegative) {\r\n      tick = -int24(int56(bigTick));\r\n    } else {\r\n      tick = int24(int56(bigTick));\r\n    }\r\n    // we use 1e18 bc this is what we're going to use in exp\r\n    // basically, you need the \"price\" amount of the quote in order to buy 1 base\r\n    // or, 1 base is worth this much quote;\r\n\r\n    price = (1e9 * ((uint256(TickMath.getSqrtRatioAtTick(tick))))) / (2**(2 * 48));\r\n\r\n    price = price * price;\r\n\r\n    if (!_quoteTokenIsToken0) {\r\n      price = (1e18 * 1e18) / price;\r\n    }\r\n\r\n    price = (price * _mul) / _div;\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"lookback\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"pool_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"quote_token_is_token0\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"mul\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"div\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_div\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lookback\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pool\",\"outputs\":[{\"internalType\":\"contract IUniswapV3PoolDerivedState\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_quoteTokenIsToken0\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniswapV3OracleRelay", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000005460000000000000000000000000d0fc8ba7e267f2bc56044a7715a489d851dc6d780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e8d4a510000000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://234d60ecc128324e04c058ab08d54c89ace8afa5365aceb4cf7897dbb9980dda"}]}