{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.8.11 <0.9.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ThreeChargeKings {\r\n    bool private lock = false;\r\n    uint private dayCount = 1 days;\r\n\r\n    uint reviewETHBalance;\r\n    uint devETHBalance;\r\n    uint burnChargeAmount;\r\n    uint totalChargeStaked;\r\n    uint totalPieBonus;\r\n    uint currentJuice;\r\n\r\n    IERC20 chargeContract;\r\n    address private owner_;\r\n    address private chargeContractAddress;\r\n\r\n    address private constant emptyAccount = 0x804748C80B4186aCAb5eC1EE8461dD3146612A67;\r\n    address private constant devAddress = 0xA8544199b573dbeFd2a1388820B527E01C3184CA;\r\n    address private constant reviewerAddress = 0xcC8376Ff36424C02EbfE35f5E7C202084789B345;\r\n\r\n    address[] private threeKings = [emptyAccount,emptyAccount,emptyAccount];\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => uint) pieBonus;\r\n    mapping(address => uint) stakeBalances;\r\n    mapping(address => uint) threeKingsLockTimes;\r\n    mapping(address => uint) stakeLockTimes;\r\n    mapping(address => bool) addressExists;\r\n\r\n    address[] balanceKeys;\r\n\r\n    constructor(address _address) {\r\n        chargeContractAddress = _address;\r\n        chargeContract = IERC20(_address);\r\n        owner_ = msg.sender;   \r\n    }\r\n\r\n    //\r\n    //  The first thing you have to do is jump in zPool\r\n    //  The UI will make sure the user does this\r\n    //\r\n    function z_jumpInThePool() external {\r\n        require(addressExists[msg.sender] == false, \"You are in the pool already\");\r\n        addressExists[msg.sender] = true;\r\n        balanceKeys.push(msg.sender);\r\n    }\r\n\r\n    function a_stakeCharge(uint256 amount) external {\r\n        _checkAllowance(amount);\r\n        require(chargeContract.transferFrom(msg.sender, address(this), amount));\r\n        \r\n        require(lock == false);\r\n        lock = true;\r\n\r\n        uint disPercent;\r\n        uint totalAmountToAdd;\r\n\r\n        unchecked {\r\n            disPercent = amount / 8;\r\n            totalAmountToAdd = amount - disPercent;\r\n            currentJuice += disPercent;\r\n            totalChargeStaked += totalAmountToAdd;\r\n            stakeBalances[msg.sender] += totalAmountToAdd;\r\n            stakeLockTimes[msg.sender] = block.timestamp + dayCount;\r\n        }\r\n\r\n        lock = false;\r\n    }\r\n\r\n    function a_unStake() external {\r\n        require(stakeBalances[msg.sender] > 0, \"User has nothing staked\");\r\n        require(block.timestamp > stakeLockTimes[msg.sender], \"Lock time has not expired yet\");\r\n\r\n        require(lock == false);\r\n        lock = true;\r\n\r\n        uint piBonus = pieBonus[msg.sender];\r\n        uint amountPotential = stakeBalances[msg.sender];\r\n\r\n        totalChargeStaked -= amountPotential;\r\n        totalPieBonus -= piBonus;\r\n\r\n        pieBonus[msg.sender] = 0;\r\n        stakeBalances[msg.sender] = 0;\r\n\r\n        lock = false;\r\n        require(chargeContract.transfer(msg.sender, amountPotential + piBonus));\r\n    }\r\n\r\n    receive() external payable {\r\n        require(lock == false);\r\n\r\n        uint devTax = msg.value / 400;\r\n        if(msg.value > 0) {\r\n            // there is a require in the else branch\r\n            // that we need to check before locking\r\n            // thats why its within each branch\r\n            lock = true;\r\n\r\n            threeKingsLockTimes[msg.sender] = block.timestamp + dayCount;\r\n            handleETHCutLogic(devTax);\r\n            handleDeposit(devTax);\r\n\r\n            lock = false;\r\n        } else {\r\n            require(balances[msg.sender] > 0);\r\n            require(block.timestamp > threeKingsLockTimes[msg.sender], \"Lock time has not expired yet\");\r\n            lock = true;\r\n\r\n            devTax = balances[msg.sender] / 400;\r\n\r\n            handleETHCutLogic(devTax);\r\n            uint amountToSend = handleFundsReturn(devTax);\r\n\r\n            lock = false;\r\n            \r\n            (bool sent, ) = msg.sender.call{value: amountToSend}(\"\");\r\n            require(sent, \"Failed to send Ether\");\r\n        }\r\n    }\r\n\r\n    function handleETHCutLogic(uint devTax) private {\r\n        uint reviewerTax = devTax / 10;\r\n        devETHBalance += devTax - reviewerTax;\r\n        reviewETHBalance += reviewerTax;\r\n    }\r\n\r\n    function handleDeposit(uint devTax) private {\r\n        uint amount = msg.value - devTax;\r\n        balances[msg.sender] += amount;\r\n        updateKing();\r\n    }\r\n\r\n    function handleFundsReturn(uint devTax) private returns (uint) {\r\n        uint amountToRedistribute = sendTokenAmount() / 10;\r\n        uint potential = sendTokenAmount() - amountToRedistribute;\r\n\r\n        uint amountToSend = balances[msg.sender] - devTax;\r\n        balances[msg.sender] = 0;\r\n\r\n        currentJuice += amountToRedistribute;\r\n\r\n        uint piBonusForUser = pieBonus[msg.sender];\r\n        totalPieBonus -= piBonusForUser;\r\n        pieBonus[msg.sender] = 0;\r\n        uint chargeToPayoutPotential = potential + piBonusForUser;\r\n        \r\n        if(isThreeKing(msg.sender)) {\r\n            resetKing();\r\n        }\r\n\r\n        if(chargeToPayoutPotential <= totalThreeChargeKingBalance()) {\r\n            // we unlock twice if we hit this branch\r\n            // never want to leave the contract in a locked state\r\n            lock = false;\r\n            require(chargeContract.transfer(msg.sender, chargeToPayoutPotential));\r\n        }\r\n        return amountToSend;\r\n    }\r\n\r\n    function updateKing() private {\r\n        uint newBalance = balances[msg.sender];\r\n        uint oldKingOne = balances[threeKings[0]];\r\n        uint oldKingTwo = balances[threeKings[1]];\r\n        uint oldKingThree = balances[threeKings[2]];\r\n\r\n        if(isThreeKing(msg.sender)) {\r\n            if(msg.sender == threeKings[1] && oldKingOne < newBalance) {\r\n                threeKings[1] = threeKings[0];\r\n                threeKings[0] = msg.sender;\r\n            } else if(msg.sender == threeKings[2] && oldKingTwo < newBalance && oldKingOne >= newBalance) {\r\n                threeKings[2] = threeKings[1];\r\n                threeKings[1] = msg.sender;\r\n            } else if(msg.sender == threeKings[2] && oldKingOne < newBalance) {\r\n                threeKings[2] = threeKings[1];\r\n                threeKings[1] = threeKings[0];\r\n                threeKings[0] = msg.sender;\r\n            }\r\n        } else if(oldKingOne < newBalance) {\r\n            threeKings[2] = threeKings[1];\r\n            threeKings[1] = threeKings[0];\r\n            threeKings[0] = msg.sender;\r\n        } else if(oldKingTwo < newBalance) {\r\n            threeKings[2] = threeKings[1];\r\n            threeKings[1] = msg.sender;\r\n        } else if(oldKingThree < newBalance) {\r\n            threeKings[2] = msg.sender;\r\n        }\r\n    }\r\n\r\n    function resetKing() private {\r\n        uint count = balanceKeys.length;\r\n        uint rollingCurrentBalance;\r\n        address currentAddressToReplace = emptyAccount;\r\n        \r\n        for (uint i=0; i < count; i++) {\r\n            if(isThreeKing(balanceKeys[i]) == false\r\n               && balances[balanceKeys[i]] > rollingCurrentBalance) {\r\n                   rollingCurrentBalance = balances[balanceKeys[i]];\r\n                   currentAddressToReplace = balanceKeys[i];\r\n               }\r\n        }\r\n        \r\n        if(threeKings[0] == msg.sender) {\r\n            threeKings[0] = threeKings[1];\r\n            threeKings[1] = threeKings[2];\r\n            threeKings[2] = currentAddressToReplace;\r\n        } else if(threeKings[1] == msg.sender) {\r\n            threeKings[1] = threeKings[2];\r\n            threeKings[2] = currentAddressToReplace;\r\n        } else if(threeKings[2] == msg.sender) {\r\n            threeKings[2] = currentAddressToReplace;\r\n        }\r\n    }\r\n\r\n    function z_updateChargeContract(address newAddress) external {\r\n        require(msg.sender == owner_, \"You are not the owner\");\r\n\r\n        chargeContractAddress = newAddress;\r\n        chargeContract = IERC20(newAddress);\r\n        uint count = balanceKeys.length;\r\n        for(uint i = 0; i < count; i++) {\r\n            pieBonus[balanceKeys[i]] = 0;\r\n        }\r\n\r\n        totalPieBonus = 0;\r\n        totalChargeStaked = 0;\r\n        burnChargeAmount = 0;\r\n        currentJuice = 0;\r\n    }\r\n\r\n    function z_getTokens(address tokenAddress) external {\r\n        require(msg.sender == owner_, \"You are not the owner\");\r\n        require(tokenAddress != chargeContractAddress, \"Sorry bro that would be unfair\");\r\n        \r\n        IERC20 found = IERC20(tokenAddress);\r\n        uint256 contract_token_balance = found.balanceOf(address(this));\r\n        require(contract_token_balance != 0);\r\n        require(found.transfer(owner_, contract_token_balance));\r\n    }\r\n\r\n    function stakeFromDistribution(address forAddress, uint distributeAmount) view internal returns (uint) {\r\n        if(totalChargeStaked == 0) return 0;\r\n        return (stakeBalances[forAddress] * distributeAmount) / totalChargeStaked;\r\n    }\r\n\r\n    function sendTokenAmount() view private returns (uint) {\r\n        if(totalThreeChargeKingBalance() > 0) {\r\n            uint potential;\r\n            if(threeKings[0] == msg.sender) {\r\n                potential = totalThreeChargeKingBalance() / 2;\r\n            } else if(threeKings[1] == msg.sender) {\r\n                potential = totalThreeChargeKingBalance() / 4;\r\n            } else if(threeKings[2] == msg.sender) {\r\n                potential = totalThreeChargeKingBalance() / 5;\r\n            } else {\r\n                potential = totalThreeChargeKingBalance() / 100;\r\n            }\r\n            return potential;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function shareTheJuice() external {\r\n        shareTheJuiceWithEveryone(0);\r\n    }\r\n\r\n    function distributeRewards(uint256 amount) external {\r\n        _checkAllowance(amount);\r\n        require(chargeContract.transferFrom(msg.sender, address(this), amount));\r\n        shareTheJuiceWithEveryone(amount);\r\n    }\r\n\r\n    function shareTheJuiceWithEveryone(uint amount) private {\r\n        require(lock == false);\r\n        lock = true;\r\n\r\n        uint distributeAmount;\r\n        unchecked {\r\n            uint halfPercent = currentJuice / 200;\r\n            uint fivePercent = currentJuice / 20;\r\n\r\n            totalPieBonus += halfPercent + halfPercent;\r\n            pieBonus[reviewerAddress] += halfPercent;\r\n            pieBonus[devAddress] += halfPercent;\r\n\r\n            burnChargeAmount += fivePercent;\r\n            distributeAmount = (amount / 2) + (currentJuice - (halfPercent + halfPercent) - fivePercent - fivePercent);\r\n            currentJuice = 0;\r\n        }\r\n        \r\n        uint count = balanceKeys.length;\r\n        for (uint i = 0; i < count; i++) {\r\n            uint stakePercent = stakeFromDistribution(balanceKeys[i], distributeAmount);\r\n            totalPieBonus += stakePercent;\r\n            pieBonus[balanceKeys[i]] += stakePercent;\r\n        }\r\n\r\n        lock = false;\r\n    }\r\n\r\n    function z_devETH() external {\r\n        require(msg.sender == devAddress);\r\n        require(devETHBalance > 0);\r\n        require(address(this).balance >= devETHBalance);\r\n        require(lock == false);\r\n        lock = true;\r\n        uint amountToSend = devETHBalance;\r\n        devETHBalance = 0;\r\n        lock = false;\r\n        (bool sent, ) = msg.sender.call{value: amountToSend}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n    }\r\n    \r\n    function z_reviewerETH() external {\r\n        require(msg.sender == reviewerAddress);\r\n        require(reviewETHBalance > 0);\r\n        require(address(this).balance >= reviewETHBalance);\r\n        require(lock == false);\r\n        lock = true;\r\n        uint amountToSend = reviewETHBalance;\r\n        reviewETHBalance = 0;\r\n        lock = false;\r\n        (bool sent, ) = msg.sender.call{value: amountToSend}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n    }\r\n\r\n    function z_devCharge() external {\r\n        require(msg.sender == devAddress);\r\n        require(pieBonus[devAddress] > 0);\r\n        require(lock == false);\r\n        lock = true;\r\n        uint amountToSend = pieBonus[devAddress];\r\n        totalPieBonus -= amountToSend;\r\n        pieBonus[devAddress] = 0;\r\n        lock = false;\r\n        require(chargeContract.transfer(msg.sender, amountToSend));\r\n    }\r\n    \r\n    function z_reviewerCharge() external {\r\n        require(msg.sender == reviewerAddress);\r\n        require(pieBonus[reviewerAddress] > 0);\r\n        require(lock == false);\r\n        lock = true;\r\n        uint amountToSend = pieBonus[reviewerAddress];\r\n        totalPieBonus -= amountToSend;\r\n        pieBonus[reviewerAddress] = 0;\r\n        lock = false;\r\n        require(chargeContract.transfer(msg.sender, amountToSend));\r\n    }\r\n    \r\n    function z_zburnCharge() external {\r\n        require(burnChargeAmount > 0);\r\n        require(chargeContract.balanceOf(address(this)) >= burnChargeAmount);\r\n        require(lock == false);\r\n        lock = true;\r\n        uint amountToSend = burnChargeAmount;\r\n        burnChargeAmount = 0;\r\n        lock = false;\r\n        require(chargeContract.transfer(0x000000000000000000000000000000000000dEaD, amountToSend));\r\n    }\r\n\r\n    function _checkAllowance(uint amount) private view {\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        require(chargeContract.allowance(msg.sender, address(this)) >= amount, \"Not enough allowance\");\r\n    }\r\n\r\n    function isThreeKing(address addressInQuestion) view public returns (bool) {\r\n        if(addressInQuestion == threeKings[0]\r\n            || addressInQuestion == threeKings[1]\r\n            || addressInQuestion == threeKings[2]) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function totalThreeChargeKingBalance() view public returns (uint) {\r\n        uint amountToSub = totalChargeStaked + totalPieBonus + burnChargeAmount + currentJuice;\r\n        uint contractBalance = chargeContract.balanceOf(address(this));\r\n        if(contractBalance <= amountToSub) {\r\n            return 0;\r\n        }\r\n        return contractBalance - amountToSub;\r\n    }\r\n\r\n    function ethForAddress(address forAddress) view public returns (uint) {\r\n        return balances[forAddress];\r\n    }\r\n\r\n    function chargeForAddress(address toFind) view public returns (uint) {\r\n        return stakeBalances[toFind];\r\n    }\r\n\r\n    function pieBonusForAddress(address forAddress) view public returns (uint) {\r\n        return pieBonus[forAddress];\r\n    }\r\n\r\n    function firstKing() view public returns (address) {\r\n        return threeKings[0];\r\n    }\r\n\r\n    function secondKing() view public returns (address) {\r\n        return threeKings[1];\r\n    }\r\n\r\n    function thirdKing() view public returns (address) {\r\n        return threeKings[2];\r\n    }\r\n\r\n    function firstKingBalance() view public returns (uint) {\r\n        return balances[threeKings[0]];\r\n    }\r\n\r\n    function secondKingBalance() view public returns (uint) {\r\n        return balances[threeKings[1]];\r\n    }\r\n\r\n    function thirdKingBalance() view public returns (uint) {\r\n        return balances[threeKings[2]];\r\n    }\r\n\r\n    function juiceAmount() view public returns (uint) {\r\n        return currentJuice;\r\n    }\r\n\r\n    function burnAmount() view public returns (uint) {\r\n        return burnChargeAmount;\r\n    }\r\n    \r\n    function zDevETHBalance() view public returns (uint) {\r\n        return devETHBalance;\r\n    }\r\n\r\n    function zReviewBalance() view public returns (uint) {\r\n        return reviewETHBalance;\r\n    }\r\n\r\n    function _isInThePool(address user) view public returns (bool) {\r\n        return addressExists[user];\r\n    }\r\n\r\n    function currentPotentialStakingBonus(address user) view public returns (uint) {\r\n        uint onePercent = currentJuice / 100;\r\n        uint tenPercent = currentJuice / 10;\r\n        uint distributeAmount = (currentJuice - onePercent - tenPercent);\r\n        uint count = balanceKeys.length;\r\n        uint valueToReturn = 0;\r\n        for (uint i = 0; i < count; i++) {\r\n            if(user == balanceKeys[i]) {\r\n                valueToReturn = stakeFromDistribution(balanceKeys[i], distributeAmount);\r\n                break;\r\n            }\r\n        }\r\n        return valueToReturn;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"_isInThePool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"a_stakeCharge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"a_unStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toFind\",\"type\":\"address\"}],\"name\":\"chargeForAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"currentPotentialStakingBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distributeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forAddress\",\"type\":\"address\"}],\"name\":\"ethForAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstKing\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstKingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressInQuestion\",\"type\":\"address\"}],\"name\":\"isThreeKing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"juiceAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forAddress\",\"type\":\"address\"}],\"name\":\"pieBonusForAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondKing\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondKingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shareTheJuice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thirdKing\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thirdKingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalThreeChargeKingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zDevETHBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zReviewBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"z_devCharge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"z_devETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"z_getTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"z_jumpInThePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"z_reviewerCharge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"z_reviewerETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"z_updateChargeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"z_zburnCharge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ThreeChargeKings", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000235a4fa8374fd49bb2f01ac953f99748756f3bd", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7a1bce234cd943f3d0dd7fb302e27ddd68a5acedb84fccc557eafc2c754d0036"}]}