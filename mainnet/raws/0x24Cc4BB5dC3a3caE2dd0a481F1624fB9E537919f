{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/market/diamond/facets/DiamondCutFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { SeenConstants } from \\\"../../../domain/SeenConstants.sol\\\";\\nimport { IDiamondCut } from \\\"../../../interfaces/IDiamondCut.sol\\\";\\nimport { DiamondLib } from \\\"../DiamondLib.sol\\\";\\nimport { JewelerLib } from \\\"../JewelerLib.sol\\\";\\n\\n/**\\n * @title DiamondCutFacet\\n *\\n * @notice DiamondCut facet based on Nick Mudge's gas-optimized diamond-2 reference.\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ncontract DiamondCutFacet is SeenConstants, IDiamondCut {\\n\\n    /**\\n     * @notice Cut facets of the Diamond\\n     *\\n     * Add/replace/remove any number of function selectors\\n     *\\n     * If populated, _calldata is executed with delegatecall on _init\\n     *\\n     * Reverts if caller does not have UPGRADER role\\n     *\\n     * @param _facetCuts Contains the facet addresses and function selectors\\n     * @param _init The address of the contract or facet to execute _calldata\\n     * @param _calldata A function call, including function selector and arguments\\n     */\\n    function diamondCut(FacetCut[] calldata _facetCuts, address _init, bytes calldata _calldata)\\n    external\\n    override\\n    {\\n        // Get the diamond storage slot\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n\\n        // Ensure the caller has the UPGRADER role\\n        require(ds.accessController.hasRole(UPGRADER, msg.sender), \\\"Caller must have UPGRADER role\\\");\\n\\n        // Make the cuts\\n        JewelerLib.diamondCut(_facetCuts, _init, _calldata);\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/domain/SeenConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title SeenConstants\\n *\\n * @notice Constants used by the Seen.Haus contract ecosystem.\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ncontract SeenConstants {\\n\\n    // Endpoint will serve dynamic metadata composed of ticket and ticketed item's info\\n    string internal constant ESCROW_TICKET_URI = \\\"https://api.seen.haus/ticket/metadata/\\\";\\n\\n    // Access Control Roles\\n    bytes32 internal constant ADMIN = keccak256(\\\"ADMIN\\\");                   // Deployer and any other admins as needed\\n    bytes32 internal constant SELLER = keccak256(\\\"SELLER\\\");                 // Approved sellers amd Seen.Haus reps\\n    bytes32 internal constant MINTER = keccak256(\\\"MINTER\\\");                 // Approved artists and Seen.Haus reps\\n    bytes32 internal constant ESCROW_AGENT = keccak256(\\\"ESCROW_AGENT\\\");     // Seen.Haus Physical Item Escrow Agent\\n    bytes32 internal constant MARKET_HANDLER = keccak256(\\\"MARKET_HANDLER\\\"); // Market Handler contracts\\n    bytes32 internal constant UPGRADER = keccak256(\\\"UPGRADER\\\");             // Performs contract upgrades\\n    bytes32 internal constant MULTISIG = keccak256(\\\"MULTISIG\\\");             // Admin role of MARKET_HANDLER & UPGRADER\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IDiamondCut\\n *\\n * @notice Diamond Facet management\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * The ERC-165 identifier for this interface is: 0x1f931c1c\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n */\\ninterface IDiamondCut {\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    enum FacetCutAction {Add, Replace, Remove}\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /**\\n     * @notice Add/replace/remove any number of functions and\\n     * optionally execute a function with delegatecall\\n     *\\n     * _calldata is executed with delegatecall on _init\\n     *\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     * @param _init The address of the contract or facet to execute _calldata\\n     * @param _calldata A function call, including function selector and arguments\\n     */\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/market/diamond/DiamondLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IAccessControlUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\nimport { IDiamondCut } from \\\"../../interfaces/IDiamondCut.sol\\\";\\n\\n/**\\n * @title DiamondLib\\n *\\n * @notice Diamond storage slot and supported interfaces\\n *\\n * @notice Based on Nick Mudge's gas-optimized diamond-2 reference,\\n * with modifications to support role-based access and management of\\n * supported interfaces.\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * N.B. Facet management functions from original `DiamondLib` were refactor/extracted\\n * to JewelerLib, since business facets also use this library for access control and\\n * managing supported interfaces.\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\nlibrary DiamondLib {\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n\\n        // The Seen.Haus AccessController\\n        IAccessControlUpgradeable accessController;\\n\\n    }\\n\\n    /**\\n     * @notice Get the Diamond storage slot\\n     *\\n     * @return ds - Diamond storage slot cast to DiamondStorage\\n     */\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @notice Add a supported interface to the Diamond\\n     *\\n     * @param _interfaceId - the interface to add\\n     */\\n    function addSupportedInterface(bytes4 _interfaceId) internal {\\n\\n        // Get the DiamondStorage struct\\n        DiamondStorage storage ds = diamondStorage();\\n\\n        // Flag the interfaces as supported\\n        ds.supportedInterfaces[_interfaceId] = true;\\n    }\\n\\n    /**\\n     * @notice Implementation of ERC-165 interface detection standard.\\n     *\\n     * @param _interfaceId - the sighash of the given interface\\n     */\\n    function supportsInterface(bytes4 _interfaceId) internal view returns (bool) {\\n\\n        // Get the DiamondStorage struct\\n        DiamondStorage storage ds = diamondStorage();\\n\\n        // Return the value\\n        return ds.supportedInterfaces[_interfaceId] || false;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/market/diamond/JewelerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { DiamondLib } from \\\"./DiamondLib.sol\\\";\\nimport { IDiamondCut } from \\\"../../interfaces/IDiamondCut.sol\\\";\\n\\n/**\\n * @title JewelerLib\\n *\\n * @notice Facet management functions\\n *\\n * Based on Nick Mudge's gas-optimized diamond-2 reference.\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * N.B. The original `LibDiamond` contract used single-owner security scheme,\\n * but this one uses role-based access via the Seen.Haus AccessController.\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\n\\nlibrary JewelerLib {\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 internal constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 internal constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    /**\\n     * @notice Cut facets of the Diamond\\n     *\\n     * Add/replace/remove any number of function selectors\\n     *\\n     * If populated, _calldata is executed with delegatecall on _init\\n     *\\n     * @param _facetCuts Contains the facet addresses and function selectors\\n     * @param _init The address of the contract or facet to execute _calldata\\n     * @param _calldata A function call, including function selector and arguments\\n     */\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _facetCuts,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n\\n        // Get the diamond storage slot\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n\\n        // Determine how many existing selectors we have\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n\\n        // Check if last selector slot is full\\n        // N.B.: selectorCount & 7 is a gas-efficient equivalent to selectorCount % 8\\n        if (selectorCount & 7 > 0) {\\n\\n            // get last selectorSlot\\n            // N.B.: selectorCount >> 3 is a gas-efficient equivalent to selectorCount / 8\\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n\\n        }\\n\\n        // Cut the facets\\n        for (uint256 facetIndex; facetIndex < _facetCuts.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _facetCuts[facetIndex].facetAddress,\\n                _facetCuts[facetIndex].action,\\n                _facetCuts[facetIndex].functionSelectors\\n            );\\n        }\\n\\n        // Update the selector count if it changed\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n\\n        // Update last selector slot\\n        // N.B.: selectorCount & 7 is a gas-efficient equivalent to selectorCount % 8\\n        if (selectorCount & 7 > 0) {\\n\\n            // N.B.: selectorCount >> 3 is a gas-efficient equivalent to selectorCount / 8\\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n\\n        }\\n\\n        // Notify listeners of state change\\n        emit DiamondCut(_facetCuts, _init, _calldata);\\n\\n        // Initialize the facet\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    /**\\n     * @notice Maintain the selectors in a FacetCut\\n     *\\n     * N.B. This method is unbelievably long and dense.\\n     * It hails from the diamond-2 reference and works\\n     * under test.\\n     *\\n     * I've added comments to try and reason about it\\n     * - CLH\\n     *\\n     * @param _selectorCount - the current selectorCount\\n     * @param _selectorSlot - the selector slot\\n     * @param _newFacetAddress - the facet address of the new or replacement function\\n     * @param _action - the action to perform. See: {IDiamondCut.FacetCutAction}\\n     * @param _selectors - the selectors to modify\\n     */\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n\\n        // Make sure there are some selectors to work with\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n\\n        // Add a selector\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n\\n            // Make sure facet being added has code\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n\\n            // Iterate selectors\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n\\n                // Make sure function doesn't already exist\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(address(bytes20(oldFacet)) == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n\\n                // clear selector position in slot and add selector\\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n\\n                // Increment selector count\\n                _selectorCount++;\\n            }\\n\\n        // Replace a selector\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n\\n            // Make sure replacement facet has code\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n\\n            // Iterate selectors\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n\\n                // Make sure function doesn't already exist\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n\\n                // only useful if immutable functions exist\\n                require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n                require(oldFacetAddress != _newFacetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n                require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n\\n                // replace old facet address\\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n\\n            }\\n\\n        // Remove a selector\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n\\n            // Make sure facet address is zero address\\n            require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n\\n            // Get the selector slot count and index to selector in slot\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n\\n            // Iterate selectors\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n\\n                // Get previous selector slot, wrapping around to last from zero\\n                if (_selectorSlot == 0) {\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n\\n                // Remove selector, swapping in with last selector in last slot\\n                // N.B. adding a block here prevents stack too deep error\\n                {\\n                    // get selector and facet, making sure it exists\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(address(bytes20(oldFacet)) != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n\\n                    // only useful if immutable functions exist\\n                    require(address(bytes20(oldFacet)) != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n\\n                // Update selector slot if count changed\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n\\n                // delete selector\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n            }\\n\\n            // Update selector count\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n\\n        }\\n\\n        // return updated selector count and selector slot for\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    /**\\n     * @notice Call a facet's initializer\\n     *\\n     * @param _init - the address of the facet to be initialized\\n     * @param _calldata - the\\n     */\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n\\n        // If _init is not populated, then _calldata must also be unpopulated\\n        if (_init == address(0)) {\\n\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n\\n        } else {\\n\\n            // Revert if _calldata is not populated\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n\\n            // Make sure address to be initialized has code\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n\\n            // If _init and _calldata are populated, call initializer\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n\\n            // Handle result\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n\\n        }\\n    }\\n\\n    /**\\n     * @notice make sure the given address has code\\n     *\\n     * Reverts if address has no contract code\\n     *\\n     * @param _contract - the contract to check\\n     * @param _errorMessage - the revert reason to throw\\n     */\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DiamondCutFacet", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}