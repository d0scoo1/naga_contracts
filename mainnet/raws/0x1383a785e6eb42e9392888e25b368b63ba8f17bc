{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ncontract VestingVault {\r\n\r\n    address public beneficiary;\r\n\r\n    uint256 public initialVestedAmount;\r\n\r\n    uint256 public vestingEndTimestamp;\r\n\r\n    uint256 public constant priceInterval = 0.2e18;\r\n\r\n    uint256 public constant priceBatches = 15;\r\n\r\n    address public constant deri = 0xA487bF43cF3b10dffc97A9A744cbB7036965d3b9;\r\n\r\n    address public constant sushiV2Pair = 0xA3DfbF2933FF3d96177bde4928D0F5840eE55600;\r\n\r\n    uint256 public blockTimestampLast;\r\n\r\n    uint256 public price0CumulativeLast;\r\n\r\n    uint256 public prepareWithdrawTimestamp;\r\n\r\n    constructor (address beneficiary_, uint256 initialVestedAmount_, uint256 vestingEndTimestamp_) {\r\n        beneficiary = beneficiary_;\r\n        initialVestedAmount = initialVestedAmount_;\r\n        vestingEndTimestamp = vestingEndTimestamp_;\r\n    }\r\n\r\n    // Beneficiary need to call prepareWithdraw before calling withdraw\r\n    // This function will record the start timestamp/price0CumulativeLast for calculating TWAP price\r\n    // To ensure a TWAP of at least 1 day, withdraw can only be called 1 day after calling this function\r\n    function prepareWithdraw() external {\r\n        require(msg.sender == beneficiary, 'prepareWithdraw: only beneficiary');\r\n\r\n        (, , uint256 timestamp) = IUniswapV2Pair(sushiV2Pair).getReserves();\r\n        blockTimestampLast = timestamp;\r\n        price0CumulativeLast = IUniswapV2Pair(sushiV2Pair).price0CumulativeLast();\r\n        prepareWithdrawTimestamp = block.timestamp;\r\n    }\r\n\r\n    // Convenient function for beneficiary to estimate the available withdraw amount\r\n    // Logic is the same as getAvailableAmount, except using a spot price instead of TWAP for estimation\r\n    function estimateAvailableAmount() external view returns (uint256) {\r\n        uint256 balance = IERC20(deri).balanceOf(address(this));\r\n        uint256 available;\r\n\r\n        if (block.timestamp >= vestingEndTimestamp) {\r\n            available = balance;\r\n        } else {\r\n            (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(sushiV2Pair).getReserves();\r\n            uint256 price = reserve1 * 10**30 / reserve0;\r\n\r\n            uint256 unlocked = price / priceInterval * initialVestedAmount / priceBatches;\r\n            uint256 locked = unlocked >= initialVestedAmount ? 0 : initialVestedAmount - unlocked;\r\n            available = balance > locked ? balance - locked : 0;\r\n        }\r\n\r\n        return available;\r\n    }\r\n\r\n    function getAvailableAmount() public view returns (uint256) {\r\n        uint256 balance = IERC20(deri).balanceOf(address(this));\r\n        uint256 available;\r\n\r\n        if (block.timestamp >= vestingEndTimestamp) {\r\n            available = balance;\r\n        } else {\r\n            require(\r\n                prepareWithdrawTimestamp != 0 && block.timestamp >= prepareWithdrawTimestamp + 86400,\r\n                'getAvailableAmount: not prepared, or wait at least 1 day after preparation'\r\n            );\r\n\r\n            (, , uint256 blockTimestampCurrent) = IUniswapV2Pair(sushiV2Pair).getReserves();\r\n            uint256 price0CumulativeCurrent = IUniswapV2Pair(sushiV2Pair).price0CumulativeLast();\r\n\r\n            // Revert if TWAP cannot be calculated\r\n            // This could happen if there is no swap at all on Sushi after prepareWithdraw\r\n            // Make a small swap on Sushi to update timestamp/price0CumulativeLast can solve this\r\n            require(blockTimestampLast != blockTimestampCurrent, 'getAvailableAmount: cannot calculate TWAP');\r\n\r\n            // TWAP price\r\n            uint256 price = (price0CumulativeCurrent - price0CumulativeLast) * 10**30 / (blockTimestampCurrent - blockTimestampLast) / 2**112;\r\n\r\n            // Amount is unlocked according to number of price intervals crossed\r\n            // Please notice that a pre-unlocked amount may be re-locked again due to price drop,\r\n            // if it is not withdrew when price is high\r\n            uint256 unlocked = price / priceInterval * initialVestedAmount / priceBatches;\r\n            uint256 locked = unlocked >= initialVestedAmount ? 0 : initialVestedAmount - unlocked;\r\n            available = balance > locked ? balance - locked : 0;\r\n        }\r\n\r\n        return available;\r\n    }\r\n\r\n    function withdraw() external {\r\n        require(msg.sender == beneficiary, 'prepareWithdraw: only beneficiary');\r\n        uint256 available = getAvailableAmount();\r\n\r\n        // Reset prepareWithdrawTimestamp\r\n        prepareWithdrawTimestamp = 0;\r\n\r\n        // Transfer available tokens\r\n        if (available > 0) {\r\n            IERC20(deri).transfer(beneficiary, available);\r\n        }\r\n    }\r\n\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external;\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialVestedAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingEndTimestamp_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimestampLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deri\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimateAvailableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialVestedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prepareWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prepareWithdrawTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceBatches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingEndTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VestingVault", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d31d2813d2c7277452eab156e764b88929ab322700000000000000000000000000000000000000000018d0bf423c03d8de0000000000000000000000000000000000000000000000000000000000000065c2c800", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e5503da7574f703bf10d4243f72b6fc85c6a98bedf032c2c49225d621bb06919"}]}