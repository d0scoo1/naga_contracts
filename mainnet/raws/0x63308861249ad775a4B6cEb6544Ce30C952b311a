{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/liquidity-protection/LiquidityProtection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"@bancor/token-governance/contracts/ITokenGovernance.sol\\\";\\n\\nimport \\\"../utility/MathEx.sol\\\";\\nimport \\\"../utility/Types.sol\\\";\\nimport \\\"../utility/Time.sol\\\";\\nimport \\\"../utility/Utils.sol\\\";\\nimport \\\"../utility/Owned.sol\\\";\\n\\nimport \\\"../token/interfaces/IDSToken.sol\\\";\\nimport \\\"../token/ReserveToken.sol\\\";\\n\\nimport \\\"../converter/interfaces/IConverterAnchor.sol\\\";\\nimport \\\"../converter/interfaces/IConverter.sol\\\";\\nimport \\\"../converter/interfaces/IConverterRegistry.sol\\\";\\n\\nimport \\\"./interfaces/ILiquidityProtection.sol\\\";\\n\\ninterface ILiquidityPoolConverter is IConverter {\\n    function addLiquidity(\\n        IReserveToken[] memory reserveTokens,\\n        uint256[] memory reserveAmounts,\\n        uint256 minReturn\\n    ) external payable;\\n\\n    function removeLiquidity(\\n        uint256 amount,\\n        IReserveToken[] memory reserveTokens,\\n        uint256[] memory reserveMinReturnAmounts\\n    ) external returns (uint256[] memory);\\n\\n    function recentAverageRate(IReserveToken reserveToken) external view returns (uint256, uint256);\\n}\\n\\ninterface IBancorNetworkV3 {\\n    function migrateLiquidity(\\n        IReserveToken reserveToken,\\n        address provider,\\n        uint256 amount,\\n        uint256 availableAmount,\\n        uint256 originalAmount\\n    ) external payable;\\n}\\n\\n/**\\n * @dev This contract implements the liquidity protection mechanism.\\n */\\ncontract LiquidityProtection is ILiquidityProtection, Utils, Owned, ReentrancyGuard, Time {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using ReserveToken for IReserveToken;\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IDSToken;\\n    using SafeERC20Ex for IERC20;\\n    using Address for address payable;\\n\\n    struct Position {\\n        address provider; // liquidity provider\\n        IDSToken poolToken; // pool token address\\n        IReserveToken reserveToken; // reserve token address\\n        uint256 poolAmount; // pool token amount\\n        uint256 reserveAmount; // reserve token amount\\n        uint256 reserveRateN; // rate of 1 protected reserve token in units of the other reserve token (numerator)\\n        uint256 reserveRateD; // rate of 1 protected reserve token in units of the other reserve token (denominator)\\n        uint256 timestamp; // timestamp\\n    }\\n\\n    // various rates between the two reserve tokens. the rate is of 1 unit of the protected reserve token in units of the other reserve token\\n    struct PackedRates {\\n        uint128 addSpotRateN; // spot rate of 1 A in units of B when liquidity was added (numerator)\\n        uint128 addSpotRateD; // spot rate of 1 A in units of B when liquidity was added (denominator)\\n        uint128 removeSpotRateN; // spot rate of 1 A in units of B when liquidity is removed (numerator)\\n        uint128 removeSpotRateD; // spot rate of 1 A in units of B when liquidity is removed (denominator)\\n        uint128 removeAverageRateN; // average rate of 1 A in units of B when liquidity is removed (numerator)\\n        uint128 removeAverageRateD; // average rate of 1 A in units of B when liquidity is removed (denominator)\\n    }\\n\\n    struct PositionList {\\n        IDSToken poolToken; // pool token address\\n        IReserveToken reserveToken; // reserve token address\\n        uint256[] positionIds; // position ids\\n    }\\n\\n    uint256 internal constant MAX_UINT128 = 2**128 - 1;\\n    uint256 internal constant MAX_UINT256 = uint256(-1);\\n\\n    IBancorNetworkV3 private immutable _networkV3;\\n    address payable private immutable _vaultV3;\\n    ILiquidityProtectionSettings private immutable _settings;\\n    ILiquidityProtectionStore private immutable _store;\\n    ILiquidityProtectionStats private immutable _stats;\\n    ILiquidityProtectionSystemStore private immutable _systemStore;\\n    ITokenHolder private immutable _wallet;\\n    IERC20 private immutable _networkToken;\\n    ITokenGovernance private immutable _networkTokenGovernance;\\n    IERC20 private immutable _govToken;\\n    ITokenGovernance private immutable _govTokenGovernance;\\n\\n    /**\\n     * @dev initializes a new LiquidityProtection contract\\n     */\\n    constructor(\\n        IBancorNetworkV3 networkV3,\\n        address payable vaultV3,\\n        ILiquidityProtectionSettings settings,\\n        ILiquidityProtectionStore store,\\n        ILiquidityProtectionStats stats,\\n        ILiquidityProtectionSystemStore systemStore,\\n        ITokenHolder wallet,\\n        ITokenGovernance networkTokenGovernance,\\n        ITokenGovernance govTokenGovernance\\n    ) public {\\n        _validAddress(address(networkV3));\\n        _validAddress(address(vaultV3));\\n        _validAddress(address(settings));\\n        _validAddress(address(store));\\n        _validAddress(address(stats));\\n        _validAddress(address(systemStore));\\n        _validAddress(address(wallet));\\n\\n        _networkV3 = networkV3;\\n        _vaultV3 = vaultV3;\\n        _settings = settings;\\n        _store = store;\\n        _stats = stats;\\n        _systemStore = systemStore;\\n        _wallet = wallet;\\n        _networkTokenGovernance = networkTokenGovernance;\\n        _govTokenGovernance = govTokenGovernance;\\n\\n        _networkToken = networkTokenGovernance.token();\\n        _govToken = govTokenGovernance.token();\\n    }\\n\\n    // ensures that the pool is supported and whitelisted\\n    modifier poolSupportedAndWhitelisted(IConverterAnchor poolAnchor) {\\n        _poolSupported(poolAnchor);\\n        _poolWhitelisted(poolAnchor);\\n\\n        _;\\n    }\\n\\n    // ensures that add liquidity is enabled\\n    modifier addLiquidityEnabled(IConverterAnchor poolAnchor, IReserveToken reserveToken) {\\n        _addLiquidityEnabled(poolAnchor, reserveToken);\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _poolSupported(IConverterAnchor poolAnchor) internal view {\\n        require(_settings.isPoolSupported(poolAnchor), \\\"ERR_POOL_NOT_SUPPORTED\\\");\\n    }\\n\\n    // error message binary size optimization\\n    function _poolWhitelisted(IConverterAnchor poolAnchor) internal view {\\n        require(_settings.isPoolWhitelisted(poolAnchor), \\\"ERR_POOL_NOT_WHITELISTED\\\");\\n    }\\n\\n    // error message binary size optimization\\n    function _addLiquidityEnabled(IConverterAnchor poolAnchor, IReserveToken reserveToken) internal view {\\n        require(!_settings.addLiquidityDisabled(poolAnchor, reserveToken), \\\"ERR_ADD_LIQUIDITY_DISABLED\\\");\\n    }\\n\\n    // error message binary size optimization\\n    function _verifyEthAmount(uint256 value) internal view {\\n        require(msg.value == value, \\\"ERR_ETH_AMOUNT_MISMATCH\\\");\\n    }\\n\\n    /**\\n     * @dev returns the LP store\\n     */\\n    function store() external view override returns (ILiquidityProtectionStore) {\\n        return _store;\\n    }\\n\\n    /**\\n     * @dev returns the LP stats\\n     */\\n    function stats() external view override returns (ILiquidityProtectionStats) {\\n        return _stats;\\n    }\\n\\n    /**\\n     * @dev returns the LP settings\\n     */\\n    function settings() external view override returns (ILiquidityProtectionSettings) {\\n        return _settings;\\n    }\\n\\n    /**\\n     * @dev accept ETH\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @dev transfers the ownership of the store\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function transferStoreOwnership(address newOwner) external ownerOnly {\\n        _store.transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev accepts the ownership of the store\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function acceptStoreOwnership() external ownerOnly {\\n        _store.acceptOwnership();\\n    }\\n\\n    /**\\n     * @dev transfers the ownership of the wallet\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function transferWalletOwnership(address newOwner) external ownerOnly {\\n        _wallet.transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev accepts the ownership of the wallet\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function acceptWalletOwnership() external ownerOnly {\\n        _wallet.acceptOwnership();\\n    }\\n\\n    /**\\n     * @dev adds protected liquidity to a pool for a specific recipient, mints new governance tokens for the caller\\n     * if the caller adds network tokens, and returns the new position id\\n     */\\n    function addLiquidityFor(\\n        address owner,\\n        IConverterAnchor poolAnchor,\\n        IReserveToken reserveToken,\\n        uint256 amount\\n    )\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        validAddress(owner)\\n        poolSupportedAndWhitelisted(poolAnchor)\\n        addLiquidityEnabled(poolAnchor, reserveToken)\\n        greaterThanZero(amount)\\n        returns (uint256)\\n    {\\n        return _addLiquidity(owner, poolAnchor, reserveToken, amount);\\n    }\\n\\n    /**\\n     * @dev adds protected liquidity to a pool, mints new governance tokens for the caller if the caller adds network\\n     * tokens, and returns the new position id\\n     */\\n    function addLiquidity(\\n        IConverterAnchor poolAnchor,\\n        IReserveToken reserveToken,\\n        uint256 amount\\n    )\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        poolSupportedAndWhitelisted(poolAnchor)\\n        addLiquidityEnabled(poolAnchor, reserveToken)\\n        greaterThanZero(amount)\\n        returns (uint256)\\n    {\\n        return _addLiquidity(msg.sender, poolAnchor, reserveToken, amount);\\n    }\\n\\n    /**\\n     * @dev adds protected liquidity to a pool for a specific recipient, mints new governance tokens for the caller if\\n     * the caller adds network tokens, and returns the new position id\\n     */\\n    function _addLiquidity(\\n        address owner,\\n        IConverterAnchor poolAnchor,\\n        IReserveToken reserveToken,\\n        uint256 amount\\n    ) private returns (uint256) {\\n        if (_isNetworkToken(reserveToken)) {\\n            _verifyEthAmount(0);\\n\\n            return _addNetworkTokenLiquidity(owner, poolAnchor, amount);\\n        }\\n\\n        // verify that ETH was passed with the call if needed\\n        _verifyEthAmount(reserveToken.isNativeToken() ? amount : 0);\\n\\n        return _addBaseTokenLiquidity(owner, poolAnchor, reserveToken, amount);\\n    }\\n\\n    /**\\n     * @dev adds network token liquidity to a pool, mints new governance tokens for the caller, and returns the new ]\\n     * position id\\n     */\\n    function _addNetworkTokenLiquidity(\\n        address owner,\\n        IConverterAnchor poolAnchor,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        IDSToken poolToken = IDSToken(address(poolAnchor));\\n        IReserveToken networkToken = IReserveToken(address(_networkToken));\\n\\n        // get the rate between the pool token and the reserve\\n        Fraction memory poolRate = _poolTokenRate(poolToken, networkToken);\\n\\n        // calculate the amount of pool tokens based on the amount of reserve tokens\\n        uint256 poolTokenAmount = _mulDivF(amount, poolRate.d, poolRate.n);\\n\\n        // remove the pool tokens from the system's ownership (will revert if not enough tokens are available)\\n        _systemStore.decSystemBalance(poolToken, poolTokenAmount);\\n\\n        // add the position for the recipient\\n        uint256 id = _addPosition(owner, poolToken, networkToken, poolTokenAmount, amount, _time());\\n\\n        // burns the network tokens from the caller. we need to transfer the tokens to the contract itself, since only\\n        // token holders can burn their tokens\\n        _networkToken.safeTransferFrom(msg.sender, address(this), amount);\\n        _burnNetworkTokens(poolAnchor, amount);\\n\\n        // mint governance tokens to the recipient\\n        _govTokenGovernance.mint(owner, amount);\\n\\n        return id;\\n    }\\n\\n    /**\\n     * @dev adds base token liquidity to a pool\\n     */\\n    function _addBaseTokenLiquidity(\\n        address owner,\\n        IConverterAnchor poolAnchor,\\n        IReserveToken baseToken,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        IDSToken poolToken = IDSToken(address(poolAnchor));\\n        IReserveToken networkToken = IReserveToken(address(_networkToken));\\n\\n        // get the reserve balances\\n        ILiquidityPoolConverter converter = ILiquidityPoolConverter(payable(_ownedBy(poolAnchor)));\\n        (uint256 reserveBalanceBase, uint256 reserveBalanceNetwork) = _converterReserveBalances(\\n            converter,\\n            baseToken,\\n            networkToken\\n        );\\n\\n        require(reserveBalanceNetwork >= _settings.minNetworkTokenLiquidityForMinting(), \\\"ERR_NOT_ENOUGH_LIQUIDITY\\\");\\n\\n        // calculate and mint the required amount of network tokens for adding liquidity\\n        uint256 newNetworkLiquidityAmount = _mulDivF(amount, reserveBalanceNetwork, reserveBalanceBase);\\n\\n        // get network token minting limit\\n        uint256 mintingLimit = _networkTokenMintingLimit(poolAnchor);\\n\\n        uint256 newNetworkTokensMinted = _systemStore.networkTokensMinted(poolAnchor).add(newNetworkLiquidityAmount);\\n        require(newNetworkTokensMinted <= mintingLimit, \\\"ERR_MAX_AMOUNT_REACHED\\\");\\n\\n        // issue new network tokens to the system\\n        _mintNetworkTokens(address(this), poolAnchor, newNetworkLiquidityAmount);\\n\\n        // transfer the base tokens from the caller and approve the converter\\n        networkToken.ensureApprove(address(converter), newNetworkLiquidityAmount);\\n\\n        if (!baseToken.isNativeToken()) {\\n            baseToken.safeTransferFrom(msg.sender, address(this), amount);\\n            baseToken.ensureApprove(address(converter), amount);\\n        }\\n\\n        // add the liquidity to the converter\\n        _addLiquidity(converter, baseToken, networkToken, amount, newNetworkLiquidityAmount, msg.value);\\n\\n        // transfer the new pool tokens to the wallet\\n        uint256 poolTokenAmount = poolToken.balanceOf(address(this));\\n        poolToken.safeTransfer(address(_wallet), poolTokenAmount);\\n\\n        // the system splits the pool tokens with the caller\\n        // increase the system's pool token balance and add the position for the caller\\n        _systemStore.incSystemBalance(poolToken, poolTokenAmount - poolTokenAmount / 2); // account for rounding errors\\n\\n        return _addPosition(owner, poolToken, baseToken, poolTokenAmount / 2, amount, _time());\\n    }\\n\\n    /**\\n     * @dev returns the single-side staking base and network token limits of a given pool\\n     */\\n    function poolAvailableSpace(IConverterAnchor poolAnchor)\\n        external\\n        view\\n        poolSupportedAndWhitelisted(poolAnchor)\\n        returns (uint256, uint256)\\n    {\\n        return (_baseTokenAvailableSpace(poolAnchor), _networkTokenAvailableSpace(poolAnchor));\\n    }\\n\\n    /**\\n     * @dev returns the base token staking limits of a given pool\\n     */\\n    function _baseTokenAvailableSpace(IConverterAnchor poolAnchor) internal view returns (uint256) {\\n        // get the pool converter\\n        ILiquidityPoolConverter converter = ILiquidityPoolConverter(payable(_ownedBy(poolAnchor)));\\n\\n        // get the base token\\n        IReserveToken networkToken = IReserveToken(address(_networkToken));\\n        IReserveToken baseToken = _converterOtherReserve(converter, networkToken);\\n\\n        // get the reserve balances\\n        (uint256 reserveBalanceBase, uint256 reserveBalanceNetwork) = _converterReserveBalances(\\n            converter,\\n            baseToken,\\n            networkToken\\n        );\\n\\n        // get the network token minting limit\\n        uint256 mintingLimit = _networkTokenMintingLimit(poolAnchor);\\n\\n        // get the amount of network tokens already minted for the pool\\n        uint256 networkTokensMinted = _systemStore.networkTokensMinted(poolAnchor);\\n\\n        // get the amount of network tokens which can minted for the pool\\n        uint256 networkTokensCanBeMinted = Math.max(mintingLimit, networkTokensMinted) - networkTokensMinted;\\n\\n        // return the maximum amount of base token liquidity that can be single-sided staked in the pool\\n        return _mulDivF(networkTokensCanBeMinted, reserveBalanceBase, reserveBalanceNetwork);\\n    }\\n\\n    /**\\n     * @dev returns the network token staking limits of a given pool\\n     */\\n    function _networkTokenAvailableSpace(IConverterAnchor poolAnchor) internal view returns (uint256) {\\n        // get the pool token\\n        IDSToken poolToken = IDSToken(address(poolAnchor));\\n        IReserveToken networkToken = IReserveToken(address(_networkToken));\\n\\n        // get the pool token rate\\n        Fraction memory poolRate = _poolTokenRate(poolToken, networkToken);\\n\\n        // return the maximum amount of network token liquidity that can be single-sided staked in the pool\\n        return _systemStore.systemBalance(poolToken).mul(poolRate.n).add(poolRate.n).sub(1).div(poolRate.d);\\n    }\\n\\n    /**\\n     * @dev returns the expected, actual, and network token compensation amounts the provider will receive for removing\\n     * liquidity\\n     *\\n     * note that it's also possible to provide the remove liquidity time to get an estimation for the return at that\\n     * given point\\n     */\\n    function removeLiquidityReturn(\\n        uint256 id,\\n        uint32 portion,\\n        uint256 removeTimestamp\\n    )\\n        external\\n        view\\n        validPortion(portion)\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        Position memory pos = _position(id);\\n\\n        require(pos.provider != address(0), \\\"ERR_INVALID_ID\\\");\\n        require(removeTimestamp >= pos.timestamp, \\\"ERR_INVALID_TIMESTAMP\\\");\\n\\n        // calculate the portion of the liquidity to remove\\n        if (portion != PPM_RESOLUTION) {\\n            (pos.poolAmount, pos.reserveAmount) = _portionAmounts(pos.poolAmount, pos.reserveAmount, portion);\\n        }\\n\\n        // get the various rates between the reserves upon adding liquidity and now\\n        PackedRates memory packedRates = _packRates(\\n            pos.poolToken,\\n            pos.reserveToken,\\n            pos.reserveRateN,\\n            pos.reserveRateD\\n        );\\n\\n        uint256 targetAmount = _removeLiquidityTargetAmount(\\n            pos.poolToken,\\n            pos.reserveToken,\\n            pos.poolAmount,\\n            pos.reserveAmount,\\n            packedRates,\\n            pos.timestamp,\\n            removeTimestamp\\n        );\\n\\n        // for network token, the return amount is identical to the target amount\\n        if (_isNetworkToken(pos.reserveToken)) {\\n            return (targetAmount, targetAmount, 0);\\n        }\\n\\n        // handle base token return\\n\\n        // calculate the amount of pool tokens required for liquidation\\n        // note that the amount is doubled since it's not possible to liquidate one reserve only\\n        Fraction memory poolRate = _poolTokenRate(pos.poolToken, pos.reserveToken);\\n        uint256 poolAmount = _liquidationAmount(targetAmount, poolRate, pos.poolToken, pos.poolAmount);\\n\\n        // calculate the base token amount received by liquidating the pool tokens\\n        // note that the amount is divided by 2 since the pool amount represents both reserves\\n        uint256 baseAmount = _mulDivF(poolAmount, poolRate.n, poolRate.d.mul(2));\\n        uint256 networkAmount = _networkCompensation(targetAmount, baseAmount, packedRates);\\n\\n        return (targetAmount, baseAmount, networkAmount);\\n    }\\n\\n    /**\\n     * @dev removes protected liquidity from a pool and also burns governance tokens from the caller if the caller\\n     * removes network tokens\\n     */\\n    function removeLiquidity(uint256 id, uint32 portion) external override nonReentrant validPortion(portion) {\\n        _removeLiquidity(msg.sender, id, portion);\\n    }\\n\\n    /**\\n     * @dev removes a position from a pool and burns governance tokens from the caller if the caller removes network tokens\\n     */\\n    function _removeLiquidity(\\n        address payable provider,\\n        uint256 id,\\n        uint32 portion\\n    ) internal {\\n        // remove the position from the store and update the stats\\n        Position memory removedPos = _removePosition(provider, id, portion);\\n\\n        // add the pool tokens to the system\\n        _systemStore.incSystemBalance(removedPos.poolToken, removedPos.poolAmount);\\n\\n        // if removing network token liquidity, burn the governance tokens from the caller. we need to transfer the\\n        // tokens to the contract itself, since only token holders can burn their tokens\\n        if (_isNetworkToken(removedPos.reserveToken)) {\\n            _govToken.safeTransferFrom(provider, address(this), removedPos.reserveAmount);\\n            _govTokenGovernance.burn(removedPos.reserveAmount);\\n        }\\n\\n        // get the various rates between the reserves upon adding liquidity and now\\n        PackedRates memory packedRates = _packRates(\\n            removedPos.poolToken,\\n            removedPos.reserveToken,\\n            removedPos.reserveRateN,\\n            removedPos.reserveRateD\\n        );\\n\\n        // verify rate deviation as early as possible in order to reduce gas-cost for failing transactions\\n        _verifyRateDeviation(\\n            packedRates.removeSpotRateN,\\n            packedRates.removeSpotRateD,\\n            packedRates.removeAverageRateN,\\n            packedRates.removeAverageRateD\\n        );\\n\\n        // get the target token amount\\n        uint256 targetAmount = _removeLiquidityTargetAmount(\\n            removedPos.poolToken,\\n            removedPos.reserveToken,\\n            removedPos.poolAmount,\\n            removedPos.reserveAmount,\\n            packedRates,\\n            removedPos.timestamp,\\n            _time()\\n        );\\n\\n        // remove network token liquidity\\n        if (_isNetworkToken(removedPos.reserveToken)) {\\n            // mint network tokens for the caller and lock them\\n            _mintNetworkTokens(address(_wallet), removedPos.poolToken, targetAmount);\\n            _lockTokens(provider, targetAmount);\\n            return;\\n        }\\n\\n        // remove base token liquidity\\n\\n        // calculate the amount of pool tokens required for liquidation\\n        // note that the amount is doubled since it's not possible to liquidate one reserve only\\n        Fraction memory poolRate = _poolTokenRate(removedPos.poolToken, removedPos.reserveToken);\\n        uint256 poolAmount = _liquidationAmount(targetAmount, poolRate, removedPos.poolToken, 0);\\n\\n        // withdraw the pool tokens from the wallet\\n        _withdrawPoolTokens(removedPos.poolToken, poolAmount);\\n\\n        // remove liquidity\\n        _removeLiquidity(\\n            removedPos.poolToken,\\n            poolAmount,\\n            removedPos.reserveToken,\\n            IReserveToken(address(_networkToken))\\n        );\\n\\n        // transfer the base tokens to the caller\\n        uint256 baseBalance = removedPos.reserveToken.balanceOf(address(this));\\n        removedPos.reserveToken.safeTransfer(provider, baseBalance);\\n\\n        // compensate the caller with network tokens if still needed\\n        uint256 delta = _networkCompensation(targetAmount, baseBalance, packedRates);\\n        if (delta > 0) {\\n            // check if there's enough network token balance, otherwise mint more\\n            uint256 networkBalance = _networkToken.balanceOf(address(this));\\n            if (networkBalance < delta) {\\n                _networkTokenGovernance.mint(address(this), delta - networkBalance);\\n            }\\n\\n            // lock network tokens for the caller\\n            _networkToken.safeTransfer(address(_wallet), delta);\\n            _lockTokens(provider, delta);\\n        }\\n\\n        // if the contract still holds network tokens, burn them\\n        uint256 networkBalance = _networkToken.balanceOf(address(this));\\n        if (networkBalance > 0) {\\n            _burnNetworkTokens(removedPos.poolToken, networkBalance);\\n        }\\n    }\\n\\n    /**\\n     * @dev migrates a set of position lists to v3\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of all of the positions\\n     */\\n    function migratePositions(PositionList[] calldata positionLists) external nonReentrant {\\n        uint256 length = positionLists.length;\\n        for (uint256 i = 0; i < length; ++i) {\\n            _migratePositions(positionLists[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev migrates a list of positions to v3\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of all of the positions\\n     */\\n    function _migratePositions(PositionList calldata positionList) internal {\\n        IDSToken poolToken = positionList.poolToken;\\n        IReserveToken reserveToken = positionList.reserveToken;\\n\\n        Fraction memory poolRate = _poolTokenRate(poolToken, reserveToken);\\n\\n        (Fraction memory removeSpotRate, Fraction memory removeAverageRate) = _reserveTokenRates(\\n            poolToken,\\n            reserveToken\\n        );\\n\\n        // verify rate deviation as early as possible in order to reduce gas-cost for failing transactions\\n        _verifyRateDeviation(removeSpotRate.n, removeSpotRate.d, removeAverageRate.n, removeAverageRate.d);\\n\\n        uint256 poolTokenAmount = 0;\\n        uint256 originalAmount = 0;\\n        uint256 fullyProtectedAmount = 0;\\n\\n        uint256 length = positionList.positionIds.length;\\n        for (uint256 i = 0; i < length; ++i) {\\n            Position memory removedPos = _removePosition(msg.sender, positionList.positionIds[i], PPM_RESOLUTION);\\n            require(\\n                removedPos.poolToken == poolToken && removedPos.reserveToken == reserveToken,\\n                \\\"ERR_INVALID_POSITION_LIST\\\"\\n            );\\n\\n            // collect pool token amounts\\n            poolTokenAmount = poolTokenAmount.add(removedPos.poolAmount);\\n\\n            // collect originally provided amounts\\n            originalAmount = originalAmount.add(removedPos.reserveAmount);\\n\\n            // get the various rates between the reserves upon adding liquidity and now\\n            PackedRates memory packedRates = _packRates(\\n                removedPos.reserveRateN,\\n                removedPos.reserveRateD,\\n                removeSpotRate,\\n                removeAverageRate\\n            );\\n\\n            // get the fully protected amount (+ fees)\\n            fullyProtectedAmount = fullyProtectedAmount.add(\\n                _removeLiquidityTargetAmount(\\n                    poolRate,\\n                    removedPos.poolAmount,\\n                    removedPos.reserveAmount,\\n                    packedRates,\\n                    Fraction({ n: 1, d: 1 })\\n                )\\n            );\\n        }\\n\\n        // add the pool tokens to the system\\n        _systemStore.incSystemBalance(poolToken, poolTokenAmount);\\n\\n        // remove network token liquidity\\n        if (_isNetworkToken(reserveToken)) {\\n            // mint the fully protected amount (+ fees) and migrate it\\n            _mintNetworkTokens(address(this), poolToken, fullyProtectedAmount);\\n\\n            _networkToken.approve(address(_networkV3), fullyProtectedAmount);\\n\\n            _networkV3.migrateLiquidity(\\n                IReserveToken(address(_networkToken)),\\n                msg.sender,\\n                fullyProtectedAmount,\\n                fullyProtectedAmount,\\n                originalAmount\\n            );\\n\\n            return;\\n        }\\n\\n        // remove base token liquidity\\n\\n        // calculate the amount of pool tokens required for liquidation\\n        // note that the amount is doubled since it's not possible to liquidate one reserve only\\n        uint256 poolLiquidationAmount = _liquidationAmount(fullyProtectedAmount, poolRate, poolToken, 0);\\n\\n        // withdraw the pool tokens from the wallet\\n        _withdrawPoolTokens(poolToken, poolLiquidationAmount);\\n\\n        // remove liquidity\\n        _removeLiquidity(poolToken, poolLiquidationAmount, reserveToken, IReserveToken(address(_networkToken)));\\n\\n        // migrate the received tokens\\n        uint256 removedAmount = reserveToken.balanceOf(address(this));\\n        uint256 value;\\n        if (reserveToken.isNativeToken()) {\\n            value = removedAmount;\\n        } else {\\n            IERC20(address(reserveToken)).safeApprove(address(_networkV3), removedAmount);\\n        }\\n        _networkV3.migrateLiquidity{ value: value }(\\n            reserveToken,\\n            msg.sender,\\n            fullyProtectedAmount,\\n            removedAmount,\\n            originalAmount\\n        );\\n\\n        // if the contract still holds network tokens, burn them\\n        uint256 networkBalance = _networkToken.balanceOf(address(this));\\n        if (networkBalance > 0) {\\n            _burnNetworkTokens(poolToken, networkBalance);\\n        }\\n    }\\n\\n    /**\\n     * @dev returns the amount the provider will receive for removing liquidity\\n     */\\n    function _removeLiquidityTargetAmount(\\n        IDSToken poolToken,\\n        IReserveToken reserveToken,\\n        uint256 poolAmount,\\n        uint256 reserveAmount,\\n        PackedRates memory packedRates,\\n        uint256 addTimestamp,\\n        uint256 removeTimestamp\\n    ) internal view returns (uint256) {\\n        // get the rate between the pool token and the reserve token\\n        Fraction memory poolRate = _poolTokenRate(poolToken, reserveToken);\\n\\n        // calculate the protection level\\n        Fraction memory level = _protectionLevel(addTimestamp, removeTimestamp);\\n\\n        return _removeLiquidityTargetAmount(poolRate, poolAmount, reserveAmount, packedRates, level);\\n    }\\n\\n    /**\\n     * @dev returns the amount the provider will receive for removing liquidity\\n     */\\n    function _removeLiquidityTargetAmount(\\n        Fraction memory poolRate,\\n        uint256 poolAmount,\\n        uint256 reserveAmount,\\n        PackedRates memory packedRates,\\n        Fraction memory level\\n    ) internal pure returns (uint256) {\\n        // get the rate between the reserves upon adding liquidity and now\\n        Fraction memory addSpotRate = Fraction({ n: packedRates.addSpotRateN, d: packedRates.addSpotRateD });\\n        Fraction memory removeSpotRate = Fraction({ n: packedRates.removeSpotRateN, d: packedRates.removeSpotRateD });\\n        Fraction memory removeAverageRate = Fraction({\\n            n: packedRates.removeAverageRateN,\\n            d: packedRates.removeAverageRateD\\n        });\\n\\n        // calculate the protected amount of reserve tokens plus accumulated fee before compensation\\n        uint256 total = _protectedAmountPlusFee(poolAmount, poolRate, addSpotRate, removeSpotRate);\\n\\n        // calculate the impermanent loss\\n        Fraction memory loss = _impLoss(addSpotRate, removeAverageRate);\\n\\n        // calculate the compensation amount\\n        return _compensationAmount(reserveAmount, Math.max(reserveAmount, total), loss, level);\\n    }\\n\\n    /**\\n     * @dev transfers a position to a new provider\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of the position\\n     */\\n    function transferPosition(uint256 id, address newProvider)\\n        external\\n        override\\n        nonReentrant\\n        validAddress(newProvider)\\n        returns (uint256)\\n    {\\n        return _transferPosition(msg.sender, id, newProvider);\\n    }\\n\\n    /**\\n     * @dev transfers a position to a new provider and optionally notifies another contract\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of the position\\n     */\\n    function transferPositionAndNotify(\\n        uint256 id,\\n        address newProvider,\\n        ITransferPositionCallback callback,\\n        bytes calldata data\\n    ) external override nonReentrant validAddress(newProvider) validAddress(address(callback)) returns (uint256) {\\n        uint256 newId = _transferPosition(msg.sender, id, newProvider);\\n\\n        callback.onTransferPosition(newId, msg.sender, data);\\n\\n        return newId;\\n    }\\n\\n    /**\\n     * @dev migrates system pool tokens to v3\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of this contract\\n     */\\n    function migrateSystemPoolTokens(IConverterAnchor[] calldata poolAnchors) external nonReentrant ownerOnly {\\n        uint256 length = poolAnchors.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            IDSToken poolToken = IDSToken(address(poolAnchors[i]));\\n            uint256 poolAmount = _systemStore.systemBalance(poolToken);\\n\\n            _withdrawPoolTokens(poolToken, poolAmount);\\n\\n            ILiquidityPoolConverter converter = ILiquidityPoolConverter(payable(_ownedBy(poolToken)));\\n            (IReserveToken[] memory reserveTokens, uint256[] memory minReturns) = _removeLiquidityInput(\\n                IReserveToken(address(_networkToken)),\\n                _converterOtherReserve(converter, IReserveToken(address(_networkToken)))\\n            );\\n\\n            uint256[] memory reserveAmounts = converter.removeLiquidity(poolAmount, reserveTokens, minReturns);\\n\\n            _burnNetworkTokens(poolAnchors[i], reserveAmounts[0]);\\n            if (reserveTokens[1].isNativeToken()) {\\n                _vaultV3.sendValue(reserveAmounts[1]);\\n            } else {\\n                reserveTokens[1].safeTransfer(_vaultV3, reserveAmounts[1]);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev transfers a position to a new provider\\n     */\\n    function _transferPosition(\\n        address provider,\\n        uint256 id,\\n        address newProvider\\n    ) internal returns (uint256) {\\n        // remove the position from the store and update the stats\\n        Position memory removedPos = _removePosition(provider, id, PPM_RESOLUTION);\\n\\n        // add the position to the store, update the stats, and return the new id\\n        return\\n            _addPosition(\\n                newProvider,\\n                removedPos.poolToken,\\n                removedPos.reserveToken,\\n                removedPos.poolAmount,\\n                removedPos.reserveAmount,\\n                removedPos.timestamp\\n            );\\n    }\\n\\n    /**\\n     * @dev allows the caller to claim network token balance that is no longer locked\\n     *\\n     * note that the function can revert if the range is too large\\n     */\\n    function claimBalance(uint256 startIndex, uint256 endIndex) external nonReentrant {\\n        // get the locked balances from the store\\n        (uint256[] memory amounts, uint256[] memory expirationTimes) = _store.lockedBalanceRange(\\n            msg.sender,\\n            startIndex,\\n            endIndex\\n        );\\n\\n        uint256 totalAmount = 0;\\n        uint256 length = amounts.length;\\n        assert(length == expirationTimes.length);\\n\\n        // reverse iteration since we're removing from the list\\n        for (uint256 i = length; i > 0; i--) {\\n            uint256 index = i - 1;\\n            if (expirationTimes[index] > _time()) {\\n                continue;\\n            }\\n\\n            // remove the locked balance item\\n            _store.removeLockedBalance(msg.sender, startIndex + index);\\n            totalAmount = totalAmount.add(amounts[index]);\\n        }\\n\\n        if (totalAmount > 0) {\\n            // transfer the tokens to the caller in a single call\\n            _wallet.withdrawTokens(IReserveToken(address(_networkToken)), msg.sender, totalAmount);\\n        }\\n    }\\n\\n    /**\\n     * @dev returns the ROI for removing liquidity in the current state after providing liquidity with the given args\\n     *\\n     * note that the function assumes full protection is in effect and that the return value is in PPM and can be\\n     * larger than PPM_RESOLUTION for positive ROI, 1M = 0% ROI\\n     */\\n    function poolROI(\\n        IDSToken poolToken,\\n        IReserveToken reserveToken,\\n        uint256 reserveAmount,\\n        uint256 poolRateN,\\n        uint256 poolRateD,\\n        uint256 reserveRateN,\\n        uint256 reserveRateD\\n    ) external view returns (uint256) {\\n        // calculate the amount of pool tokens based on the amount of reserve tokens\\n        uint256 poolAmount = _mulDivF(reserveAmount, poolRateD, poolRateN);\\n\\n        // get the various rates between the reserves upon adding liquidity and now\\n        PackedRates memory packedRates = _packRates(poolToken, reserveToken, reserveRateN, reserveRateD);\\n\\n        // get the current return\\n        uint256 protectedReturn = _removeLiquidityTargetAmount(\\n            poolToken,\\n            reserveToken,\\n            poolAmount,\\n            reserveAmount,\\n            packedRates,\\n            _time().sub(_settings.maxProtectionDelay()),\\n            _time()\\n        );\\n\\n        // calculate the ROI as the ratio between the current fully protected return and the initial amount\\n        return _mulDivF(protectedReturn, PPM_RESOLUTION, reserveAmount);\\n    }\\n\\n    /**\\n     * @dev adds the position to the store and updates the stats\\n     */\\n    function _addPosition(\\n        address provider,\\n        IDSToken poolToken,\\n        IReserveToken reserveToken,\\n        uint256 poolAmount,\\n        uint256 reserveAmount,\\n        uint256 timestamp\\n    ) internal returns (uint256) {\\n        // verify rate deviation as early as possible in order to reduce gas-cost for failing transactions\\n        (Fraction memory spotRate, Fraction memory averageRate) = _reserveTokenRates(poolToken, reserveToken);\\n        _verifyRateDeviation(spotRate.n, spotRate.d, averageRate.n, averageRate.d);\\n\\n        _stats.increaseTotalAmounts(provider, poolToken, reserveToken, poolAmount, reserveAmount);\\n        _stats.addProviderPool(provider, poolToken);\\n\\n        return\\n            _store.addProtectedLiquidity(\\n                provider,\\n                poolToken,\\n                reserveToken,\\n                poolAmount,\\n                reserveAmount,\\n                spotRate.n,\\n                spotRate.d,\\n                timestamp\\n            );\\n    }\\n\\n    /**\\n     * @dev removes the position from the store and updates the stats\\n     */\\n    function _removePosition(\\n        address provider,\\n        uint256 id,\\n        uint32 portion\\n    ) private returns (Position memory) {\\n        Position memory pos = _providerPosition(id, provider);\\n\\n        // verify that the pool is whitelisted\\n        _poolWhitelisted(pos.poolToken);\\n\\n        // verify that the position is not removed on the same block in which it was added\\n        require(pos.timestamp < _time(), \\\"ERR_TOO_EARLY\\\");\\n\\n        if (portion == PPM_RESOLUTION) {\\n            // remove the position from the provider\\n            _store.removeProtectedLiquidity(id);\\n        } else {\\n            // remove a portion of the position from the provider\\n            uint256 fullPoolAmount = pos.poolAmount;\\n            uint256 fullReserveAmount = pos.reserveAmount;\\n            (pos.poolAmount, pos.reserveAmount) = _portionAmounts(pos.poolAmount, pos.reserveAmount, portion);\\n\\n            _store.updateProtectedLiquidityAmounts(\\n                id,\\n                fullPoolAmount - pos.poolAmount,\\n                fullReserveAmount - pos.reserveAmount\\n            );\\n        }\\n\\n        // update the statistics\\n        _stats.decreaseTotalAmounts(pos.provider, pos.poolToken, pos.reserveToken, pos.poolAmount, pos.reserveAmount);\\n\\n        return pos;\\n    }\\n\\n    /**\\n     * @dev locks network tokens for the provider and emits the tokens locked event\\n     */\\n    function _lockTokens(address provider, uint256 amount) internal {\\n        uint256 expirationTime = _time().add(_settings.lockDuration());\\n        _store.addLockedBalance(provider, amount, expirationTime);\\n    }\\n\\n    /**\\n     * @dev returns the rate of 1 pool token in reserve token units\\n     */\\n    function _poolTokenRate(IDSToken poolToken, IReserveToken reserveToken)\\n        internal\\n        view\\n        virtual\\n        returns (Fraction memory)\\n    {\\n        // get the pool token supply\\n        uint256 poolTokenSupply = poolToken.totalSupply();\\n\\n        // get the reserve balance\\n        IConverter converter = IConverter(payable(_ownedBy(poolToken)));\\n        uint256 reserveBalance = converter.getConnectorBalance(reserveToken);\\n\\n        // for standard pools, 50% of the pool supply value equals the value of each reserve\\n        return Fraction({ n: reserveBalance.mul(2), d: poolTokenSupply });\\n    }\\n\\n    /**\\n     * @dev returns the spot rate and average rate of 1 reserve token in the other reserve token units\\n     */\\n    function _reserveTokenRates(IDSToken poolToken, IReserveToken reserveToken)\\n        internal\\n        view\\n        returns (Fraction memory, Fraction memory)\\n    {\\n        ILiquidityPoolConverter converter = ILiquidityPoolConverter(payable(_ownedBy(poolToken)));\\n        IReserveToken otherReserve = _converterOtherReserve(converter, reserveToken);\\n\\n        (uint256 spotRateN, uint256 spotRateD) = _converterReserveBalances(converter, otherReserve, reserveToken);\\n        (uint256 averageRateN, uint256 averageRateD) = converter.recentAverageRate(reserveToken);\\n\\n        return (Fraction({ n: spotRateN, d: spotRateD }), Fraction({ n: averageRateN, d: averageRateD }));\\n    }\\n\\n    /**\\n     * @dev returns the various rates between the reserves\\n     */\\n    function _packRates(\\n        IDSToken poolToken,\\n        IReserveToken reserveToken,\\n        uint256 addSpotRateN,\\n        uint256 addSpotRateD\\n    ) internal view returns (PackedRates memory) {\\n        (Fraction memory removeSpotRate, Fraction memory removeAverageRate) = _reserveTokenRates(\\n            poolToken,\\n            reserveToken\\n        );\\n\\n        assert((removeSpotRate.n | removeSpotRate.d | removeAverageRate.n | removeAverageRate.d) <= MAX_UINT128);\\n\\n        return _packRates(addSpotRateN, addSpotRateD, removeSpotRate, removeAverageRate);\\n    }\\n\\n    /**\\n     * @dev returns the various rates between the reserves\\n     */\\n    function _packRates(\\n        uint256 addSpotRateN,\\n        uint256 addSpotRateD,\\n        Fraction memory removeSpotRate,\\n        Fraction memory removeAverageRate\\n    ) internal pure returns (PackedRates memory) {\\n        assert((addSpotRateN | addSpotRateD) <= MAX_UINT128);\\n\\n        return\\n            PackedRates({\\n                addSpotRateN: uint128(addSpotRateN),\\n                addSpotRateD: uint128(addSpotRateD),\\n                removeSpotRateN: uint128(removeSpotRate.n),\\n                removeSpotRateD: uint128(removeSpotRate.d),\\n                removeAverageRateN: uint128(removeAverageRate.n),\\n                removeAverageRateD: uint128(removeAverageRate.d)\\n            });\\n    }\\n\\n    /**\\n     * @dev verifies that the deviation of the average rate from the spot rate is within the permitted range\\n     *\\n     * for example, if the maximum permitted deviation is 5%, then verify `95/100 <= average/spot <= 100/95`\\n     */\\n    function _verifyRateDeviation(\\n        uint256 spotRateN,\\n        uint256 spotRateD,\\n        uint256 averageRateN,\\n        uint256 averageRateD\\n    ) internal view {\\n        uint256 ppmDelta = PPM_RESOLUTION - _settings.averageRateMaxDeviation();\\n        uint256 min = spotRateN.mul(averageRateD).mul(ppmDelta).mul(ppmDelta);\\n        uint256 mid = spotRateD.mul(averageRateN).mul(ppmDelta).mul(PPM_RESOLUTION);\\n        uint256 max = spotRateN.mul(averageRateD).mul(PPM_RESOLUTION).mul(PPM_RESOLUTION);\\n        require(min <= mid && mid <= max, \\\"ERR_INVALID_RATE\\\");\\n    }\\n\\n    /**\\n     * @dev utility to add liquidity to a converter\\n     */\\n    function _addLiquidity(\\n        ILiquidityPoolConverter converter,\\n        IReserveToken reserveToken1,\\n        IReserveToken reserveToken2,\\n        uint256 reserveAmount1,\\n        uint256 reserveAmount2,\\n        uint256 value\\n    ) internal {\\n        IReserveToken[] memory reserveTokens = new IReserveToken[](2);\\n        uint256[] memory amounts = new uint256[](2);\\n        reserveTokens[0] = reserveToken1;\\n        reserveTokens[1] = reserveToken2;\\n        amounts[0] = reserveAmount1;\\n        amounts[1] = reserveAmount2;\\n        converter.addLiquidity{ value: value }(reserveTokens, amounts, 1);\\n    }\\n\\n    /**\\n     * @dev utility to remove liquidity from a converter\\n     */\\n    function _removeLiquidity(\\n        IDSToken poolToken,\\n        uint256 poolAmount,\\n        IReserveToken reserveToken1,\\n        IReserveToken reserveToken2\\n    ) internal {\\n        ILiquidityPoolConverter converter = ILiquidityPoolConverter(payable(_ownedBy(poolToken)));\\n        (IReserveToken[] memory reserveTokens, uint256[] memory minReturns) = _removeLiquidityInput(\\n            reserveToken1,\\n            reserveToken2\\n        );\\n        converter.removeLiquidity(poolAmount, reserveTokens, minReturns);\\n    }\\n\\n    /**\\n     * @dev returns a position from the store\\n     */\\n    function _position(uint256 id) internal view returns (Position memory) {\\n        Position memory pos;\\n        (\\n            pos.provider,\\n            pos.poolToken,\\n            pos.reserveToken,\\n            pos.poolAmount,\\n            pos.reserveAmount,\\n            pos.reserveRateN,\\n            pos.reserveRateD,\\n            pos.timestamp\\n        ) = _store.protectedLiquidity(id);\\n\\n        return pos;\\n    }\\n\\n    /**\\n     * @dev returns a position from the store\\n     */\\n    function _providerPosition(uint256 id, address provider) internal view returns (Position memory) {\\n        Position memory pos = _position(id);\\n        require(pos.provider == provider, \\\"ERR_ACCESS_DENIED\\\");\\n\\n        return pos;\\n    }\\n\\n    /**\\n     * @dev returns the protected amount of reserve tokens plus accumulated fee before compensation\\n     */\\n    function _protectedAmountPlusFee(\\n        uint256 poolAmount,\\n        Fraction memory poolRate,\\n        Fraction memory addRate,\\n        Fraction memory removeRate\\n    ) internal pure returns (uint256) {\\n        uint256 n = MathEx.ceilSqrt(addRate.d.mul(removeRate.n)).mul(poolRate.n);\\n        uint256 d = MathEx.floorSqrt(addRate.n.mul(removeRate.d)).mul(poolRate.d);\\n\\n        uint256 x = n * poolAmount;\\n        if (x / n == poolAmount) {\\n            return x / d;\\n        }\\n\\n        (uint256 hi, uint256 lo) = n > poolAmount ? (n, poolAmount) : (poolAmount, n);\\n        (uint256 p, uint256 q) = MathEx.reducedRatio(hi, d, MAX_UINT256 / lo);\\n        uint256 min = (hi / d).mul(lo);\\n\\n        if (q > 0) {\\n            return Math.max(min, (p * lo) / q);\\n        }\\n        return min;\\n    }\\n\\n    /**\\n     * @dev returns the impermanent loss incurred due to the change in rates between the reserve tokens\\n     */\\n    function _impLoss(Fraction memory prevRate, Fraction memory newRate) internal pure returns (Fraction memory) {\\n        uint256 ratioN = newRate.n.mul(prevRate.d);\\n        uint256 ratioD = newRate.d.mul(prevRate.n);\\n\\n        uint256 prod = ratioN * ratioD;\\n        uint256 root = prod / ratioN == ratioD\\n            ? MathEx.floorSqrt(prod)\\n            : MathEx.floorSqrt(ratioN) * MathEx.floorSqrt(ratioD);\\n        uint256 sum = ratioN.add(ratioD);\\n\\n        // the arithmetic below is safe because `x + y >= sqrt(x * y) * 2`\\n        if (sum % 2 == 0) {\\n            sum /= 2;\\n            return Fraction({ n: sum - root, d: sum });\\n        }\\n        return Fraction({ n: sum - root * 2, d: sum });\\n    }\\n\\n    /**\\n     * @dev returns the protection level based on the timestamp and protection delays\\n     */\\n    function _protectionLevel(uint256 addTimestamp, uint256 removeTimestamp) internal view returns (Fraction memory) {\\n        uint256 timeElapsed = removeTimestamp.sub(addTimestamp);\\n        uint256 minProtectionDelay = _settings.minProtectionDelay();\\n        uint256 maxProtectionDelay = _settings.maxProtectionDelay();\\n        if (timeElapsed < minProtectionDelay) {\\n            return Fraction({ n: 0, d: 1 });\\n        }\\n\\n        if (timeElapsed >= maxProtectionDelay) {\\n            return Fraction({ n: 1, d: 1 });\\n        }\\n\\n        return Fraction({ n: timeElapsed, d: maxProtectionDelay });\\n    }\\n\\n    /**\\n     * @dev returns the compensation amount based on the impermanent loss and the protection level\\n     */\\n    function _compensationAmount(\\n        uint256 amount,\\n        uint256 total,\\n        Fraction memory loss,\\n        Fraction memory level\\n    ) internal pure returns (uint256) {\\n        uint256 levelN = level.n.mul(amount);\\n        uint256 levelD = level.d;\\n        uint256 maxVal = Math.max(Math.max(levelN, levelD), total);\\n        (uint256 lossN, uint256 lossD) = MathEx.reducedRatio(loss.n, loss.d, MAX_UINT256 / maxVal);\\n        return total.mul(lossD.sub(lossN)).div(lossD).add(lossN.mul(levelN).div(lossD.mul(levelD)));\\n    }\\n\\n    function _networkCompensation(\\n        uint256 targetAmount,\\n        uint256 baseAmount,\\n        PackedRates memory packedRates\\n    ) internal view returns (uint256) {\\n        if (targetAmount <= baseAmount) {\\n            return 0;\\n        }\\n\\n        // calculate the delta in network tokens\\n        uint256 delta = _mulDivF(\\n            targetAmount - baseAmount,\\n            packedRates.removeAverageRateN,\\n            packedRates.removeAverageRateD\\n        );\\n\\n        // the delta might be very small due to precision loss\\n        // in which case no compensation will take place (gas optimization)\\n        if (delta >= _settings.minNetworkCompensation()) {\\n            return delta;\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev utility to mint network tokens\\n     */\\n    function _mintNetworkTokens(\\n        address owner,\\n        IConverterAnchor poolAnchor,\\n        uint256 amount\\n    ) private {\\n        _systemStore.incNetworkTokensMinted(poolAnchor, amount);\\n        _networkTokenGovernance.mint(owner, amount);\\n    }\\n\\n    /**\\n     * @dev utility to burn network tokens\\n     */\\n    function _burnNetworkTokens(IConverterAnchor poolAnchor, uint256 amount) private {\\n        _systemStore.decNetworkTokensMinted(poolAnchor, amount);\\n        _networkTokenGovernance.burn(amount);\\n    }\\n\\n    /**\\n     * @dev utility to get the reserve balances\\n     */\\n    function _converterReserveBalances(\\n        IConverter converter,\\n        IReserveToken reserveToken1,\\n        IReserveToken reserveToken2\\n    ) private view returns (uint256, uint256) {\\n        return (converter.getConnectorBalance(reserveToken1), converter.getConnectorBalance(reserveToken2));\\n    }\\n\\n    /**\\n     * @dev utility to get the other reserve\\n     */\\n    function _converterOtherReserve(IConverter converter, IReserveToken thisReserve)\\n        private\\n        view\\n        returns (IReserveToken)\\n    {\\n        IReserveToken otherReserve = converter.connectorTokens(0);\\n        return otherReserve != thisReserve ? otherReserve : converter.connectorTokens(1);\\n    }\\n\\n    /**\\n     * @dev utility to get the owner\\n     */\\n    function _ownedBy(IOwned owned) private view returns (address) {\\n        return owned.owner();\\n    }\\n\\n    /**\\n     * @dev returns whether the provided reserve token is the network token\\n     */\\n    function _isNetworkToken(IReserveToken reserveToken) private view returns (bool) {\\n        return address(reserveToken) == address(_networkToken);\\n    }\\n\\n    /**\\n     * @dev returns custom input for the `removeLiquidity` converter function\\n     */\\n    function _removeLiquidityInput(IReserveToken reserveToken1, IReserveToken reserveToken2)\\n        private\\n        pure\\n        returns (IReserveToken[] memory, uint256[] memory)\\n    {\\n        IReserveToken[] memory reserveTokens = new IReserveToken[](2);\\n        uint256[] memory minReturns = new uint256[](2);\\n        reserveTokens[0] = reserveToken1;\\n        reserveTokens[1] = reserveToken2;\\n        minReturns[0] = 1;\\n        minReturns[1] = 1;\\n        return (reserveTokens, minReturns);\\n    }\\n\\n    /**\\n     * @dev returns the relative position amounts\\n     */\\n    function _portionAmounts(\\n        uint256 poolAmount,\\n        uint256 reserveAmount,\\n        uint256 portion\\n    ) private pure returns (uint256, uint256) {\\n        return (_mulDivF(poolAmount, portion, PPM_RESOLUTION), _mulDivF(reserveAmount, portion, PPM_RESOLUTION));\\n    }\\n\\n    /**\\n     * @dev returns the network token minting limit\\n     */\\n    function _networkTokenMintingLimit(IConverterAnchor poolAnchor) private view returns (uint256) {\\n        uint256 mintingLimit = _settings.networkTokenMintingLimits(poolAnchor);\\n        return mintingLimit > 0 ? mintingLimit : _settings.defaultNetworkTokenMintingLimit();\\n    }\\n\\n    /**\\n     * @dev returns the amount of pool tokens required for liquidation\\n     */\\n    function _liquidationAmount(\\n        uint256 targetAmount,\\n        Fraction memory poolRate,\\n        IDSToken poolToken,\\n        uint256 additionalAmount\\n    ) private view returns (uint256) {\\n        // note that the amount is doubled since it's not possible to liquidate one reserve only\\n        uint256 poolAmount = _mulDivF(targetAmount, poolRate.d.mul(2), poolRate.n);\\n        // limit the amount of pool tokens by the amount the system/caller holds\\n        return Math.min(poolAmount, _systemStore.systemBalance(poolToken).add(additionalAmount));\\n    }\\n\\n    /**\\n     * @dev withdraw pool tokens from the wallet\\n     */\\n    function _withdrawPoolTokens(IDSToken poolToken, uint256 poolAmount) private {\\n        _systemStore.decSystemBalance(poolToken, poolAmount);\\n        _wallet.withdrawTokens(IReserveToken(address(poolToken)), address(this), poolAmount);\\n    }\\n\\n    /**\\n     * @dev returns `x * y / z`\\n     */\\n    function _mulDivF(\\n        uint256 x,\\n        uint256 y,\\n        uint256 z\\n    ) private pure returns (uint256) {\\n        return x.mul(y).div(z);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@bancor/token-governance/contracts/ITokenGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\nimport \\\"./IMintableToken.sol\\\";\\n\\n/// @title The interface for mintable/burnable token governance.\\ninterface ITokenGovernance {\\n    // The address of the mintable ERC20 token.\\n    function token() external view returns (IMintableToken);\\n\\n    /// @dev Mints new tokens.\\n    ///\\n    /// @param to Account to receive the new amount.\\n    /// @param amount Amount to increase the supply by.\\n    ///\\n    function mint(address to, uint256 amount) external;\\n\\n    /// @dev Burns tokens from the caller.\\n    ///\\n    /// @param amount Amount to decrease the supply by.\\n    ///\\n    function burn(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/utility/MathEx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev This library provides a set of complex math operations.\\n */\\nlibrary MathEx {\\n    uint256 private constant MAX_EXP_BIT_LEN = 4;\\n    uint256 private constant MAX_EXP = 2**MAX_EXP_BIT_LEN - 1;\\n    uint256 private constant MAX_UINT256 = uint256(-1);\\n\\n    /**\\n     * @dev returns the largest integer smaller than or equal to the square root of a positive integer\\n     */\\n    function floorSqrt(uint256 num) internal pure returns (uint256) {\\n        uint256 x = num / 2 + 1;\\n        uint256 y = (x + num / x) / 2;\\n        while (x > y) {\\n            x = y;\\n            y = (x + num / x) / 2;\\n        }\\n        return x;\\n    }\\n\\n    /**\\n     * @dev returns the smallest integer larger than or equal to the square root of a positive integer\\n     */\\n    function ceilSqrt(uint256 num) internal pure returns (uint256) {\\n        uint256 x = floorSqrt(num);\\n\\n        return x * x == num ? x : x + 1;\\n    }\\n\\n    /**\\n     * @dev computes the product of two given ratios\\n     */\\n    function productRatio(\\n        uint256 xn,\\n        uint256 yn,\\n        uint256 xd,\\n        uint256 yd\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 n = mulDivC(xn, yn, MAX_UINT256);\\n        uint256 d = mulDivC(xd, yd, MAX_UINT256);\\n        uint256 z = n > d ? n : d;\\n        if (z > 1) {\\n            return (mulDivC(xn, yn, z), mulDivC(xd, yd, z));\\n        }\\n        return (xn * yn, xd * yd);\\n    }\\n\\n    /**\\n     * @dev computes a reduced-scalar ratio\\n     */\\n    function reducedRatio(\\n        uint256 n,\\n        uint256 d,\\n        uint256 max\\n    ) internal pure returns (uint256, uint256) {\\n        (uint256 newN, uint256 newD) = (n, d);\\n        if (newN > max || newD > max) {\\n            (newN, newD) = normalizedRatio(newN, newD, max);\\n        }\\n        if (newN != newD) {\\n            return (newN, newD);\\n        }\\n        return (1, 1);\\n    }\\n\\n    /**\\n     * @dev computes \\\"scale * a / (a + b)\\\" and \\\"scale * b / (a + b)\\\".\\n     */\\n    function normalizedRatio(\\n        uint256 a,\\n        uint256 b,\\n        uint256 scale\\n    ) internal pure returns (uint256, uint256) {\\n        if (a <= b) {\\n            return accurateRatio(a, b, scale);\\n        }\\n        (uint256 y, uint256 x) = accurateRatio(b, a, scale);\\n        return (x, y);\\n    }\\n\\n    /**\\n     * @dev computes \\\"scale * a / (a + b)\\\" and \\\"scale * b / (a + b)\\\", assuming that \\\"a <= b\\\".\\n     */\\n    function accurateRatio(\\n        uint256 a,\\n        uint256 b,\\n        uint256 scale\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 maxVal = MAX_UINT256 / scale;\\n        if (a > maxVal) {\\n            uint256 c = a / (maxVal + 1) + 1;\\n            a /= c; // we can now safely compute `a * scale`\\n            b /= c;\\n        }\\n        if (a != b) {\\n            uint256 newN = a * scale;\\n            uint256 newD = unsafeAdd(a, b); // can overflow\\n            if (newD >= a) {\\n                // no overflow in `a + b`\\n                uint256 x = roundDiv(newN, newD); // we can now safely compute `scale - x`\\n                uint256 y = scale - x;\\n                return (x, y);\\n            }\\n            if (newN < b - (b - a) / 2) {\\n                return (0, scale); // `a * scale < (a + b) / 2 < MAX_UINT256 < a + b`\\n            }\\n            return (1, scale - 1); // `(a + b) / 2 < a * scale < MAX_UINT256 < a + b`\\n        }\\n        return (scale / 2, scale / 2); // allow reduction to `(1, 1)` in the calling function\\n    }\\n\\n    /**\\n     * @dev computes the nearest integer to a given quotient without overflowing or underflowing.\\n     */\\n    function roundDiv(uint256 n, uint256 d) internal pure returns (uint256) {\\n        return n / d + (n % d) / (d - d / 2);\\n    }\\n\\n    /**\\n     * @dev returns the average number of decimal digits in a given list of positive integers\\n     */\\n    function geometricMean(uint256[] memory values) internal pure returns (uint256) {\\n        uint256 numOfDigits = 0;\\n        uint256 length = values.length;\\n        for (uint256 i = 0; i < length; ++i) {\\n            numOfDigits += decimalLength(values[i]);\\n        }\\n        return uint256(10)**(roundDivUnsafe(numOfDigits, length) - 1);\\n    }\\n\\n    /**\\n     * @dev returns the number of decimal digits in a given positive integer\\n     */\\n    function decimalLength(uint256 x) internal pure returns (uint256) {\\n        uint256 y = 0;\\n        for (uint256 tmpX = x; tmpX > 0; tmpX /= 10) {\\n            ++y;\\n        }\\n        return y;\\n    }\\n\\n    /**\\n     * @dev returns the nearest integer to a given quotient\\n     *\\n     * note the computation is overflow-safe assuming that the input is sufficiently small\\n     */\\n    function roundDivUnsafe(uint256 n, uint256 d) internal pure returns (uint256) {\\n        return (n + d / 2) / d;\\n    }\\n\\n    /**\\n     * @dev returns the largest integer smaller than or equal to `x * y / z`\\n     */\\n    function mulDivF(\\n        uint256 x,\\n        uint256 y,\\n        uint256 z\\n    ) internal pure returns (uint256) {\\n        (uint256 xyh, uint256 xyl) = mul512(x, y);\\n\\n        // if `x * y < 2 ^ 256`\\n        if (xyh == 0) {\\n            return xyl / z;\\n        }\\n\\n        // assert `x * y / z < 2 ^ 256`\\n        require(xyh < z, \\\"ERR_OVERFLOW\\\");\\n\\n        uint256 m = mulMod(x, y, z); // `m = x * y % z`\\n        (uint256 nh, uint256 nl) = sub512(xyh, xyl, m); // `n = x * y - m` hence `n / z = floor(x * y / z)`\\n\\n        // if `n < 2 ^ 256`\\n        if (nh == 0) {\\n            return nl / z;\\n        }\\n\\n        uint256 p = unsafeSub(0, z) & z; // `p` is the largest power of 2 which `z` is divisible by\\n        uint256 q = div512(nh, nl, p); // `n` is divisible by `p` because `n` is divisible by `z` and `z` is divisible by `p`\\n        uint256 r = inv256(z / p); // `z / p = 1 mod 2` hence `inverse(z / p) = 1 mod 2 ^ 256`\\n        return unsafeMul(q, r); // `q * r = (n / p) * inverse(z / p) = n / z`\\n    }\\n\\n    /**\\n     * @dev returns the smallest integer larger than or equal to `x * y / z`\\n     */\\n    function mulDivC(\\n        uint256 x,\\n        uint256 y,\\n        uint256 z\\n    ) internal pure returns (uint256) {\\n        uint256 w = mulDivF(x, y, z);\\n        if (mulMod(x, y, z) > 0) {\\n            require(w < MAX_UINT256, \\\"ERR_OVERFLOW\\\");\\n            return w + 1;\\n        }\\n        return w;\\n    }\\n\\n    /**\\n     * @dev returns the value of `x * y` as a pair of 256-bit values\\n     */\\n    function mul512(uint256 x, uint256 y) private pure returns (uint256, uint256) {\\n        uint256 p = mulModMax(x, y);\\n        uint256 q = unsafeMul(x, y);\\n        if (p >= q) {\\n            return (p - q, q);\\n        }\\n        return (unsafeSub(p, q) - 1, q);\\n    }\\n\\n    /**\\n     * @dev returns the value of `2 ^ 256 * xh + xl - y`, where `2 ^ 256 * xh + xl >= y`\\n     */\\n    function sub512(\\n        uint256 xh,\\n        uint256 xl,\\n        uint256 y\\n    ) private pure returns (uint256, uint256) {\\n        if (xl >= y) {\\n            return (xh, xl - y);\\n        }\\n        return (xh - 1, unsafeSub(xl, y));\\n    }\\n\\n    /**\\n     * @dev returns the value of `(2 ^ 256 * xh + xl) / pow2n`, where `xl` is divisible by `pow2n`\\n     */\\n    function div512(\\n        uint256 xh,\\n        uint256 xl,\\n        uint256 pow2n\\n    ) private pure returns (uint256) {\\n        uint256 pow2nInv = unsafeAdd(unsafeSub(0, pow2n) / pow2n, 1); // `1 << (256 - n)`\\n        return unsafeMul(xh, pow2nInv) | (xl / pow2n); // `(xh << (256 - n)) | (xl >> n)`\\n    }\\n\\n    /**\\n     * @dev returns the inverse of `d` modulo `2 ^ 256`, where `d` is congruent to `1` modulo `2`\\n     */\\n    function inv256(uint256 d) private pure returns (uint256) {\\n        // approximate the root of `f(x) = 1 / x - d` using the newton\u2013raphson convergence method\\n        uint256 x = 1;\\n        for (uint256 i = 0; i < 8; ++i) {\\n            x = unsafeMul(x, unsafeSub(2, unsafeMul(x, d))); // `x = x * (2 - x * d) mod 2 ^ 256`\\n        }\\n        return x;\\n    }\\n\\n    /**\\n     * @dev returns `(x + y) % 2 ^ 256`\\n     */\\n    function unsafeAdd(uint256 x, uint256 y) private pure returns (uint256) {\\n        return x + y;\\n    }\\n\\n    /**\\n     * @dev returns `(x - y) % 2 ^ 256`\\n     */\\n    function unsafeSub(uint256 x, uint256 y) private pure returns (uint256) {\\n        return x - y;\\n    }\\n\\n    /**\\n     * @dev returns `(x * y) % 2 ^ 256`\\n     */\\n    function unsafeMul(uint256 x, uint256 y) private pure returns (uint256) {\\n        return x * y;\\n    }\\n\\n    /**\\n     * @dev returns `x * y % (2 ^ 256 - 1)`\\n     */\\n    function mulModMax(uint256 x, uint256 y) private pure returns (uint256) {\\n        return mulmod(x, y, MAX_UINT256);\\n    }\\n\\n    /**\\n     * @dev returns `x * y % z`\\n     */\\n    function mulMod(\\n        uint256 x,\\n        uint256 y,\\n        uint256 z\\n    ) private pure returns (uint256) {\\n        return mulmod(x, y, z);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utility/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev This contract provides types which can be used by various contracts.\\n */\\n\\nstruct Fraction {\\n    uint256 n; // numerator\\n    uint256 d; // denominator\\n}\\n\"\r\n    },\r\n    \"contracts/utility/Time.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\n/*\\n    Time implementing contract\\n*/\\ncontract Time {\\n    /**\\n     * @dev returns the current time\\n     */\\n    function _time() internal view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utility/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev Utilities & Common Modifiers\\n */\\ncontract Utils {\\n    uint32 internal constant PPM_RESOLUTION = 1000000;\\n\\n    // verifies that a value is greater than zero\\n    modifier greaterThanZero(uint256 value) {\\n        _greaterThanZero(value);\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _greaterThanZero(uint256 value) internal pure {\\n        require(value > 0, \\\"ERR_ZERO_VALUE\\\");\\n    }\\n\\n    // validates an address - currently only checks that it isn't null\\n    modifier validAddress(address addr) {\\n        _validAddress(addr);\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _validAddress(address addr) internal pure {\\n        require(addr != address(0), \\\"ERR_INVALID_ADDRESS\\\");\\n    }\\n\\n    // ensures that the portion is valid\\n    modifier validPortion(uint32 _portion) {\\n        _validPortion(_portion);\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _validPortion(uint32 _portion) internal pure {\\n        require(_portion > 0 && _portion <= PPM_RESOLUTION, \\\"ERR_INVALID_PORTION\\\");\\n    }\\n\\n    // validates an external address - currently only checks that it isn't null or this\\n    modifier validExternalAddress(address addr) {\\n        _validExternalAddress(addr);\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _validExternalAddress(address addr) internal view {\\n        require(addr != address(0) && addr != address(this), \\\"ERR_INVALID_EXTERNAL_ADDRESS\\\");\\n    }\\n\\n    // ensures that the fee is valid\\n    modifier validFee(uint32 fee) {\\n        _validFee(fee);\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _validFee(uint32 fee) internal pure {\\n        require(fee <= PPM_RESOLUTION, \\\"ERR_INVALID_FEE\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utility/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"./interfaces/IOwned.sol\\\";\\n\\n/**\\n * @dev This contract provides support and utilities for contract ownership.\\n */\\ncontract Owned is IOwned {\\n    address private _owner;\\n    address private _newOwner;\\n\\n    /**\\n     * @dev triggered when the owner is updated\\n     */\\n    event OwnerUpdate(address indexed prevOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev initializes a new Owned instance\\n     */\\n    constructor() public {\\n        _owner = msg.sender;\\n    }\\n\\n    // allows execution by the owner only\\n    modifier ownerOnly() {\\n        _ownerOnly();\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _ownerOnly() private view {\\n        require(msg.sender == _owner, \\\"ERR_ACCESS_DENIED\\\");\\n    }\\n\\n    /**\\n     * @dev allows transferring the contract ownership\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     *\\n     * note the new owner still needs to accept the transfer\\n     */\\n    function transferOwnership(address newOwner) public override ownerOnly {\\n        require(newOwner != _owner, \\\"ERR_SAME_OWNER\\\");\\n\\n        _newOwner = newOwner;\\n    }\\n\\n    /**\\n     * @dev used by a new owner to accept an ownership transfer\\n     */\\n    function acceptOwnership() public override {\\n        require(msg.sender == _newOwner, \\\"ERR_ACCESS_DENIED\\\");\\n\\n        emit OwnerUpdate(_owner, _newOwner);\\n\\n        _owner = _newOwner;\\n        _newOwner = address(0);\\n    }\\n\\n    /**\\n     * @dev returns the address of the current owner\\n     */\\n    function owner() public view override returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev returns the address of the new owner candidate\\n     */\\n    function newOwner() external view returns (address) {\\n        return _newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/interfaces/IDSToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../../converter/interfaces/IConverterAnchor.sol\\\";\\nimport \\\"../../utility/interfaces/IOwned.sol\\\";\\n\\n/**\\n * @dev DSToken interface\\n */\\ninterface IDSToken is IConverterAnchor, IERC20 {\\n    function issue(address recipient, uint256 amount) external;\\n\\n    function destroy(address recipient, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/token/ReserveToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./interfaces/IReserveToken.sol\\\";\\n\\nimport \\\"./SafeERC20Ex.sol\\\";\\n\\n/**\\n * @dev This library implements ERC20 and SafeERC20 utilities for reserve tokens, which can be either ERC20 tokens or ETH\\n */\\nlibrary ReserveToken {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20Ex for IERC20;\\n\\n    // the address that represents an ETH reserve\\n    IReserveToken public constant NATIVE_TOKEN_ADDRESS = IReserveToken(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    /**\\n     * @dev returns whether the provided token represents an ERC20 or ETH reserve\\n     */\\n    function isNativeToken(IReserveToken reserveToken) internal pure returns (bool) {\\n        return reserveToken == NATIVE_TOKEN_ADDRESS;\\n    }\\n\\n    /**\\n     * @dev returns the balance of the reserve token\\n     */\\n    function balanceOf(IReserveToken reserveToken, address account) internal view returns (uint256) {\\n        if (isNativeToken(reserveToken)) {\\n            return account.balance;\\n        }\\n\\n        return toIERC20(reserveToken).balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev transfers a specific amount of the reserve token\\n     */\\n    function safeTransfer(\\n        IReserveToken reserveToken,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        if (isNativeToken(reserveToken)) {\\n            payable(to).transfer(amount);\\n        } else {\\n            toIERC20(reserveToken).safeTransfer(to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev transfers a specific amount of the reserve token from a specific holder using the allowance mechanism\\n     *\\n     * note that the function ignores a reserve token which represents an ETH reserve\\n     */\\n    function safeTransferFrom(\\n        IReserveToken reserveToken,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount == 0 || isNativeToken(reserveToken)) {\\n            return;\\n        }\\n\\n        toIERC20(reserveToken).safeTransferFrom(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev ensures that the spender has sufficient allowance\\n     *\\n     * note that this function ignores a reserve token which represents an ETH reserve\\n     */\\n    function ensureApprove(\\n        IReserveToken reserveToken,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        if (isNativeToken(reserveToken)) {\\n            return;\\n        }\\n\\n        toIERC20(reserveToken).ensureApprove(spender, amount);\\n    }\\n\\n    /**\\n     * @dev utility function that converts an IReserveToken to an IERC20\\n     */\\n    function toIERC20(IReserveToken reserveToken) private pure returns (IERC20) {\\n        return IERC20(address(reserveToken));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/converter/interfaces/IConverterAnchor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"../../utility/interfaces/IOwned.sol\\\";\\n\\n/**\\n * @dev Converter Anchor interface\\n */\\ninterface IConverterAnchor is IOwned {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/converter/interfaces/IConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IConverterAnchor.sol\\\";\\n\\nimport \\\"../../utility/interfaces/IOwned.sol\\\";\\n\\nimport \\\"../../token/interfaces/IReserveToken.sol\\\";\\n\\n/**\\n * @dev Converter interface\\n */\\ninterface IConverter is IOwned {\\n    function converterType() external pure returns (uint16);\\n\\n    function anchor() external view returns (IConverterAnchor);\\n\\n    function isActive() external view returns (bool);\\n\\n    function targetAmountAndFee(\\n        IReserveToken sourceToken,\\n        IReserveToken targetToken,\\n        uint256 sourceAmount\\n    ) external view returns (uint256, uint256);\\n\\n    function convert(\\n        IReserveToken sourceToken,\\n        IReserveToken targetToken,\\n        uint256 sourceAmount,\\n        address trader,\\n        address payable beneficiary\\n    ) external payable returns (uint256);\\n\\n    function conversionFee() external view returns (uint32);\\n\\n    function maxConversionFee() external view returns (uint32);\\n\\n    function reserveBalance(IReserveToken reserveToken) external view returns (uint256);\\n\\n    receive() external payable;\\n\\n    function transferAnchorOwnership(address newOwner) external;\\n\\n    function acceptAnchorOwnership() external;\\n\\n    function setConversionFee(uint32 fee) external;\\n\\n    function addReserve(IReserveToken token, uint32 weight) external;\\n\\n    function transferReservesOnUpgrade(address newConverter) external;\\n\\n    function onUpgradeComplete() external;\\n\\n    // deprecated, backward compatibility\\n    function token() external view returns (IConverterAnchor);\\n\\n    function transferTokenOwnership(address newOwner) external;\\n\\n    function acceptTokenOwnership() external;\\n\\n    function reserveTokenCount() external view returns (uint16);\\n\\n    function reserveTokens() external view returns (IReserveToken[] memory);\\n\\n    function connectors(IReserveToken reserveToken)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint32,\\n            bool,\\n            bool,\\n            bool\\n        );\\n\\n    function getConnectorBalance(IReserveToken connectorToken) external view returns (uint256);\\n\\n    function connectorTokens(uint256 index) external view returns (IReserveToken);\\n\\n    function connectorTokenCount() external view returns (uint16);\\n\\n    /**\\n     * @dev triggered when the converter is activated\\n     */\\n    event Activation(uint16 indexed converterType, IConverterAnchor indexed anchor, bool indexed activated);\\n\\n    /**\\n     * @dev triggered when a conversion between two tokens occurs\\n     */\\n    event Conversion(\\n        IReserveToken indexed sourceToken,\\n        IReserveToken indexed targetToken,\\n        address indexed trader,\\n        uint256 sourceAmount,\\n        uint256 targetAmount,\\n        int256 conversionFee\\n    );\\n\\n    /**\\n     * @dev triggered when the rate between two tokens in the converter changes\\n     *\\n     * note that the event might be dispatched for rate updates between any two tokens in the converter\\n     */\\n    event TokenRateUpdate(address indexed token1, address indexed token2, uint256 rateN, uint256 rateD);\\n\\n    /**\\n     * @dev triggered when the conversion fee is updated\\n     */\\n    event ConversionFeeUpdate(uint32 prevFee, uint32 newFee);\\n}\\n\"\r\n    },\r\n    \"contracts/converter/interfaces/IConverterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"../../token/interfaces/IReserveToken.sol\\\";\\n\\nimport \\\"./IConverterAnchor.sol\\\";\\n\\n/**\\n * @dev Converter Registry interface\\n */\\ninterface IConverterRegistry {\\n    function getAnchorCount() external view returns (uint256);\\n\\n    function getAnchors() external view returns (address[] memory);\\n\\n    function getAnchor(uint256 index) external view returns (IConverterAnchor);\\n\\n    function isAnchor(address value) external view returns (bool);\\n\\n    function getLiquidityPoolCount() external view returns (uint256);\\n\\n    function getLiquidityPools() external view returns (address[] memory);\\n\\n    function getLiquidityPool(uint256 index) external view returns (IConverterAnchor);\\n\\n    function isLiquidityPool(address value) external view returns (bool);\\n\\n    function getConvertibleTokenCount() external view returns (uint256);\\n\\n    function getConvertibleTokens() external view returns (address[] memory);\\n\\n    function getConvertibleToken(uint256 index) external view returns (IReserveToken);\\n\\n    function isConvertibleToken(address value) external view returns (bool);\\n\\n    function getConvertibleTokenAnchorCount(IReserveToken convertibleToken) external view returns (uint256);\\n\\n    function getConvertibleTokenAnchors(IReserveToken convertibleToken) external view returns (address[] memory);\\n\\n    function getConvertibleTokenAnchor(IReserveToken convertibleToken, uint256 index)\\n        external\\n        view\\n        returns (IConverterAnchor);\\n\\n    function isConvertibleTokenAnchor(IReserveToken convertibleToken, address value) external view returns (bool);\\n\\n    function getLiquidityPoolByConfig(\\n        uint16 converterType,\\n        IReserveToken[] memory reserveTokens,\\n        uint32[] memory reserveWeights\\n    ) external view returns (IConverterAnchor);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity-protection/interfaces/ILiquidityProtection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"./ILiquidityProtectionStore.sol\\\";\\nimport \\\"./ILiquidityProtectionStats.sol\\\";\\nimport \\\"./ILiquidityProtectionSettings.sol\\\";\\nimport \\\"./ILiquidityProtectionSystemStore.sol\\\";\\nimport \\\"./ITransferPositionCallback.sol\\\";\\n\\nimport \\\"../../utility/interfaces/ITokenHolder.sol\\\";\\n\\nimport \\\"../../token/interfaces/IReserveToken.sol\\\";\\n\\nimport \\\"../../converter/interfaces/IConverterAnchor.sol\\\";\\n\\n/**\\n * @dev Liquidity Protection interface\\n */\\ninterface ILiquidityProtection {\\n    function store() external view returns (ILiquidityProtectionStore);\\n\\n    function stats() external view returns (ILiquidityProtectionStats);\\n\\n    function settings() external view returns (ILiquidityProtectionSettings);\\n\\n    function addLiquidityFor(\\n        address owner,\\n        IConverterAnchor poolAnchor,\\n        IReserveToken reserveToken,\\n        uint256 amount\\n    ) external payable returns (uint256);\\n\\n    function addLiquidity(\\n        IConverterAnchor poolAnchor,\\n        IReserveToken reserveToken,\\n        uint256 amount\\n    ) external payable returns (uint256);\\n\\n    function removeLiquidity(uint256 id, uint32 portion) external;\\n\\n    function transferPosition(uint256 id, address newProvider) external returns (uint256);\\n\\n    function transferPositionAndNotify(\\n        uint256 id,\\n        address newProvider,\\n        ITransferPositionCallback callback,\\n        bytes calldata data\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@bancor/token-governance/contracts/IMintableToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IClaimable.sol\\\";\\n\\n/// @title Mintable Token interface\\ninterface IMintableToken is IERC20, IClaimable {\\n    function issue(address to, uint256 amount) external;\\n\\n    function destroy(address from, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@bancor/token-governance/contracts/IClaimable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\n/// @title Claimable contract interface\\ninterface IClaimable {\\n    function owner() external view returns (address);\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"contracts/utility/interfaces/IOwned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Owned interface\\n */\\ninterface IOwned {\\n    function owner() external view returns (address);\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"contracts/token/interfaces/IReserveToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev This contract is used to represent reserve tokens, which are tokens that can either be regular ERC20 tokens or\\n * native ETH (represented by the NATIVE_TOKEN_ADDRESS address)\\n *\\n * Please note that this interface is intentionally doesn't inherit from IERC20, so that it'd be possible to effectively\\n * override its balanceOf() function in the ReserveToken library\\n */\\ninterface IReserveToken {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/token/SafeERC20Ex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\n/**\\n * @dev Extends the SafeERC20 library with additional operations\\n */\\nlibrary SafeERC20Ex {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     * @dev ensures that the spender has sufficient allowance\\n     */\\n    function ensureApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (allowance >= amount) {\\n            return;\\n        }\\n\\n        if (allowance > 0) {\\n            token.safeApprove(spender, 0);\\n        }\\n        token.safeApprove(spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity-protection/interfaces/ILiquidityProtectionStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"../../converter/interfaces/IConverterAnchor.sol\\\";\\n\\nimport \\\"../../token/interfaces/IDSToken.sol\\\";\\nimport \\\"../../token/interfaces/IReserveToken.sol\\\";\\n\\nimport \\\"../../utility/interfaces/IOwned.sol\\\";\\n\\n/**\\n * @dev Liquidity Protection Store interface\\n */\\ninterface ILiquidityProtectionStore is IOwned {\\n    function withdrawTokens(\\n        IReserveToken token,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function protectedLiquidity(uint256 id)\\n        external\\n        view\\n        returns (\\n            address,\\n            IDSToken,\\n            IReserveToken,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function addProtectedLiquidity(\\n        address provider,\\n        IDSToken poolToken,\\n        IReserveToken reserveToken,\\n        uint256 poolAmount,\\n        uint256 reserveAmount,\\n        uint256 reserveRateN,\\n        uint256 reserveRateD,\\n        uint256 timestamp\\n    ) external returns (uint256);\\n\\n    function updateProtectedLiquidityAmounts(\\n        uint256 id,\\n        uint256 poolNewAmount,\\n        uint256 reserveNewAmount\\n    ) external;\\n\\n    function removeProtectedLiquidity(uint256 id) external;\\n\\n    function lockedBalance(address provider, uint256 index) external view returns (uint256, uint256);\\n\\n    function lockedBalanceRange(\\n        address provider,\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (uint256[] memory, uint256[] memory);\\n\\n    function addLockedBalance(\\n        address provider,\\n        uint256 reserveAmount,\\n        uint256 expirationTime\\n    ) external returns (uint256);\\n\\n    function removeLockedBalance(address provider, uint256 index) external;\\n\\n    function systemBalance(IReserveToken poolToken) external view returns (uint256);\\n\\n    function incSystemBalance(IReserveToken poolToken, uint256 poolAmount) external;\\n\\n    function decSystemBalance(IReserveToken poolToken, uint256 poolAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity-protection/interfaces/ILiquidityProtectionStats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"../../converter/interfaces/IConverterAnchor.sol\\\";\\n\\nimport \\\"../../token/interfaces/IDSToken.sol\\\";\\nimport \\\"../../token/interfaces/IReserveToken.sol\\\";\\n\\n/**\\n * @dev Liquidity Protection Stats interface\\n */\\ninterface ILiquidityProtectionStats {\\n    function increaseTotalAmounts(\\n        address provider,\\n        IDSToken poolToken,\\n        IReserveToken reserveToken,\\n        uint256 poolAmount,\\n        uint256 reserveAmount\\n    ) external;\\n\\n    function decreaseTotalAmounts(\\n        address provider,\\n        IDSToken poolToken,\\n        IReserveToken reserveToken,\\n        uint256 poolAmount,\\n        uint256 reserveAmount\\n    ) external;\\n\\n    function addProviderPool(address provider, IDSToken poolToken) external returns (bool);\\n\\n    function removeProviderPool(address provider, IDSToken poolToken) external returns (bool);\\n\\n    function totalPoolAmount(IDSToken poolToken) external view returns (uint256);\\n\\n    function totalReserveAmount(IDSToken poolToken, IReserveToken reserveToken) external view returns (uint256);\\n\\n    function totalProviderAmount(\\n        address provider,\\n        IDSToken poolToken,\\n        IReserveToken reserveToken\\n    ) external view returns (uint256);\\n\\n    function providerPools(address provider) external view returns (IDSToken[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity-protection/interfaces/ILiquidityProtectionSettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"../../converter/interfaces/IConverterAnchor.sol\\\";\\n\\nimport \\\"../../token/interfaces/IReserveToken.sol\\\";\\n\\nimport \\\"./ILiquidityProvisionEventsSubscriber.sol\\\";\\n\\n/**\\n * @dev Liquidity Protection Settings interface\\n */\\ninterface ILiquidityProtectionSettings {\\n    function isPoolWhitelisted(IConverterAnchor poolAnchor) external view returns (bool);\\n\\n    function poolWhitelist() external view returns (address[] memory);\\n\\n    function subscribers() external view returns (address[] memory);\\n\\n    function isPoolSupported(IConverterAnchor poolAnchor) external view returns (bool);\\n\\n    function minNetworkTokenLiquidityForMinting() external view returns (uint256);\\n\\n    function defaultNetworkTokenMintingLimit() external view returns (uint256);\\n\\n    function networkTokenMintingLimits(IConverterAnchor poolAnchor) external view returns (uint256);\\n\\n    function addLiquidityDisabled(IConverterAnchor poolAnchor, IReserveToken reserveToken) external view returns (bool);\\n\\n    function minProtectionDelay() external view returns (uint256);\\n\\n    function maxProtectionDelay() external view returns (uint256);\\n\\n    function minNetworkCompensation() external view returns (uint256);\\n\\n    function lockDuration() external view returns (uint256);\\n\\n    function averageRateMaxDeviation() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity-protection/interfaces/ILiquidityProtectionSystemStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../../converter/interfaces/IConverterAnchor.sol\\\";\\n\\n/**\\n * @dev Liquidity Protection System Store interface\\n */\\ninterface ILiquidityProtectionSystemStore {\\n    function systemBalance(IERC20 poolToken) external view returns (uint256);\\n\\n    function incSystemBalance(IERC20 poolToken, uint256 poolAmount) external;\\n\\n    function decSystemBalance(IERC20 poolToken, uint256 poolAmount) external;\\n\\n    function networkTokensMinted(IConverterAnchor poolAnchor) external view returns (uint256);\\n\\n    function incNetworkTokensMinted(IConverterAnchor poolAnchor, uint256 amount) external;\\n\\n    function decNetworkTokensMinted(IConverterAnchor poolAnchor, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity-protection/interfaces/ITransferPositionCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Transfer position event callback interface\\n */\\ninterface ITransferPositionCallback {\\n    function onTransferPosition(\\n        uint256 newId,\\n        address provider,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/utility/interfaces/ITokenHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"../../token/interfaces/IReserveToken.sol\\\";\\n\\nimport \\\"./IOwned.sol\\\";\\n\\n/**\\n * @dev Token Holder interface\\n */\\ninterface ITokenHolder is IOwned {\\n    receive() external payable;\\n\\n    function withdrawTokens(\\n        IReserveToken reserveToken,\\n        address payable to,\\n        uint256 amount\\n    ) external;\\n\\n    function withdrawTokensMultiple(\\n        IReserveToken[] calldata reserveTokens,\\n        address payable to,\\n        uint256[] calldata amounts\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity-protection/interfaces/ILiquidityProvisionEventsSubscriber.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.6.12;\\n\\nimport \\\"../../converter/interfaces/IConverterAnchor.sol\\\";\\n\\nimport \\\"../../token/interfaces/IReserveToken.sol\\\";\\n\\n/**\\n * @dev Liquidity provision events subscriber interface\\n */\\ninterface ILiquidityProvisionEventsSubscriber {\\n    function onAddingLiquidity(\\n        address provider,\\n        IConverterAnchor poolAnchor,\\n        IReserveToken reserveToken,\\n        uint256 poolAmount,\\n        uint256 reserveAmount\\n    ) external;\\n\\n    function onRemovingLiquidity(\\n        uint256 id,\\n        address provider,\\n        IConverterAnchor poolAnchor,\\n        IReserveToken reserveToken,\\n        uint256 poolAmount,\\n        uint256 reserveAmount\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBancorNetworkV3\",\"name\":\"networkV3\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"vaultV3\",\"type\":\"address\"},{\"internalType\":\"contract ILiquidityProtectionSettings\",\"name\":\"settings\",\"type\":\"address\"},{\"internalType\":\"contract ILiquidityProtectionStore\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"contract ILiquidityProtectionStats\",\"name\":\"stats\",\"type\":\"address\"},{\"internalType\":\"contract ILiquidityProtectionSystemStore\",\"name\":\"systemStore\",\"type\":\"address\"},{\"internalType\":\"contract ITokenHolder\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"contract ITokenGovernance\",\"name\":\"networkTokenGovernance\",\"type\":\"address\"},{\"internalType\":\"contract ITokenGovernance\",\"name\":\"govTokenGovernance\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptStoreOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptWalletOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConverterAnchor\",\"name\":\"poolAnchor\",\"type\":\"address\"},{\"internalType\":\"contract IReserveToken\",\"name\":\"reserveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"contract IConverterAnchor\",\"name\":\"poolAnchor\",\"type\":\"address\"},{\"internalType\":\"contract IReserveToken\",\"name\":\"reserveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidityFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IDSToken\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"contract IReserveToken\",\"name\":\"reserveToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"positionIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct LiquidityProtection.PositionList[]\",\"name\":\"positionLists\",\"type\":\"tuple[]\"}],\"name\":\"migratePositions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConverterAnchor[]\",\"name\":\"poolAnchors\",\"type\":\"address[]\"}],\"name\":\"migrateSystemPoolTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConverterAnchor\",\"name\":\"poolAnchor\",\"type\":\"address\"}],\"name\":\"poolAvailableSpace\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDSToken\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"contract IReserveToken\",\"name\":\"reserveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reserveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolRateN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolRateD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveRateN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveRateD\",\"type\":\"uint256\"}],\"name\":\"poolROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"portion\",\"type\":\"uint32\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"portion\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"removeTimestamp\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settings\",\"outputs\":[{\"internalType\":\"contract ILiquidityProtectionSettings\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stats\",\"outputs\":[{\"internalType\":\"contract ILiquidityProtectionStats\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"store\",\"outputs\":[{\"internalType\":\"contract ILiquidityProtectionStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newProvider\",\"type\":\"address\"}],\"name\":\"transferPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newProvider\",\"type\":\"address\"},{\"internalType\":\"contract ITransferPositionCallback\",\"name\":\"callback\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferPositionAndNotify\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferStoreOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferWalletOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LiquidityProtection", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000eef417e1d5cc832e619ae18d2f140de2999dd4fb000000000000000000000000649765821d9f64198c905ec0b2b037a4a52bc373000000000000000000000000f7d28faa1fe9ea53279fe6e3cde75175859bdf46000000000000000000000000f5fab5dbd2f3bf675de4cb76517d4767013cfb550000000000000000000000009712bb50dc6efb8a3d7d12cea500a50967d2d471000000000000000000000000c4c5634de585d43daec8fa2a6fb6286cd9b87131000000000000000000000000d1d846312b819743974786050848d9b3d06b9b55000000000000000000000000a489c2b5b36835a327851ab917a80562b5afc2440000000000000000000000000887ae1251e180d7d453aedebee26e1639f20113", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}