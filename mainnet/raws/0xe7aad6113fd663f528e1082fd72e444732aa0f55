{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\n/*\\n\\n\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551        \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2554\u255d\\n\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551        \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2588\u2588\u2557   \u2588\u2588\u2554\u255d \\n \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551  \\n  \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d  \\nhttps://vetcor37.com                                                           \\n\\nIf you use this contract, please consider donating to support our initiatives:\\n\\n* Ethereum: 0xf32d4B3A52F98E0793A40609025f450Bb98f40C5\\n* Polygon: 0xdCB281707B5Fedf0f3cD05e003F55C1E58c5cbd8\\n* Arbitrum: 0x6D380f1949Ba2D272375F94ee689ce9BaB4F1892\\n\\n*/\\n\\nimport \\\"./utils/Fixidity.sol\\\";\\n\\n/// @custom:security-contact 0xdarni@pm.me\\ncontract ChainlinkEurEthPriceOracle {\\n    AggregatorV3Interface internal EurUsd;\\n    AggregatorV3Interface internal EthUsd;\\n\\n    constructor() {\\n        // EUR / USD\\n        // https://data.chain.link/ethereum/mainnet/fiat/eur-usd\\n        EurUsd = AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\\n        // ETH / USD\\n        // https://data.chain.link/ethereum/mainnet/crypto-usd/eth-usd\\n        EthUsd = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\\n\\n    }\\n\\n    function getLatestPriceEthEur() public view returns (int) {\\n        (\\n            /*uint80 roundIDEurUsd*/,\\n            int priceEurUsd,\\n            /*uint startedAtEurUsd*/,\\n            /*uint timeStampEurUsd*/,\\n            /*uint80 answeredInRoundEurUsd*/\\n        ) = EurUsd.latestRoundData();\\n\\n        (\\n            /*uint80 roundIDEthUsd*/,\\n            int priceEthUsd,\\n            /*uint startedAtEthUsd*/,\\n            /*uint timeStampEthUsd*/,\\n            /*uint80 answeredInRoundEthUsd*/\\n        ) = EthUsd.latestRoundData();\\n        \\n        int256 P1 = Fixidity.convertFixed(priceEurUsd, 8, Fixidity.digits());\\n        int256 P2 = Fixidity.convertFixed(priceEthUsd, 8, Fixidity.digits());\\n\\n        return Fixidity.convertFixed(Fixidity.divide(P2, P1), 24, 8);\\n    }\\n\\n    function getLatestPriceEurEth() public view returns (int) {\\n        (\\n            uint80 roundIDEurUsd,\\n            int priceEurUsd,\\n            uint startedAtEurUsd,\\n            uint timeStampEurUsd,\\n            uint80 answeredInRoundEurUsd\\n        ) = EurUsd.latestRoundData();\\n\\n        (\\n            uint80 roundIDEthUsd,\\n            int priceEthUsd,\\n            uint startedAtEthUsd,\\n            uint timeStampEthUsd,\\n            uint80 answeredInRoundEthUsd\\n        ) = EthUsd.latestRoundData();\\n\\n        int256 P1 = Fixidity.convertFixed(priceEurUsd, 8, Fixidity.digits());\\n        int256 P2 = Fixidity.convertFixed(priceEthUsd, 8, Fixidity.digits());\\n\\n        return Fixidity.convertFixed(Fixidity.divide(P1, P2), 24, 8);\\n    }\\n}\\n\\ninterface AggregatorV3Interface {\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int answer,\\n            uint startedAt,\\n            uint updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\"\r\n    },\r\n    \"contracts/utils/Fixidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\n\\n/**\\n * @title Fixidity\\n * @author Gadi Guy, Alberto Cuesta Canada\\n * @notice This library provides fixed point arithmetic with protection against\\n * overflow. \\n * All operations are done with int256 and the operands must have been created \\n * with any of the newFrom* functions, which shift the comma digits() to the \\n * right and check for limits.\\n * When using this library be sure of using maxNewFixed() as the upper limit for\\n * creation of fixed point numbers. Use maxFixedMul(), maxFixedDiv() and\\n * maxFixedAdd() if you want to be certain that those operations don't \\n * overflow.\\n */\\nlibrary Fixidity {\\n\\n    /**\\n     * @notice Number of positions that the comma is shifted to the right.\\n     */\\n    function digits() public pure returns(int8) {\\n        return 24;\\n    }\\n    \\n    /**\\n     * @notice This is 1 in the fixed point units used in this library.\\n     * @dev Test fixed1() equals 10^digits()\\n     * Hardcoded to 24 digits.\\n     */\\n    function fixed1() public pure returns(int256) {\\n        return 1000000000000000000000000;\\n    }\\n\\n    /**\\n     * @notice The amount of decimals lost on each multiplication operand.\\n     * @dev Test mulPrecision() equals sqrt(fixed1)\\n     * Hardcoded to 24 digits.\\n     */\\n    function mulPrecision() public pure returns(int256) {\\n        return 1000000000000;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be represented in an int256\\n     * @dev Test maxInt256() equals 2^255 -1\\n     */\\n    function maxInt256() public pure returns(int256) {\\n        return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\\n    }\\n\\n    /**\\n     * @notice Minimum value that can be represented in an int256\\n     * @dev Test minInt256 equals (2^255) * (-1)\\n     */\\n    function minInt256() public pure returns(int256) {\\n        return -57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be converted to fixed point. Optimize for\\n     * @dev deployment. \\n     * Test maxNewFixed() equals maxInt256() / fixed1()\\n     * Hardcoded to 24 digits.\\n     */\\n    function maxNewFixed() public pure returns(int256) {\\n        return 57896044618658097711785492504343953926634992332820282;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be converted to fixed point. Optimize for\\n     * deployment. \\n     * @dev Test minNewFixed() equals -(maxInt256()) / fixed1()\\n     * Hardcoded to 24 digits.\\n     */\\n    function minNewFixed() public pure returns(int256) {\\n        return -57896044618658097711785492504343953926634992332820282;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be safely used as an addition operator.\\n     * @dev Test maxFixedAdd() equals maxInt256()-1 / 2\\n     * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\\n     * Test add(maxFixedAdd()+1,maxFixedAdd()) throws \\n     * Test add(-maxFixedAdd(),-maxFixedAdd()) equals -maxFixedAdd() - maxFixedAdd()\\n     * Test add(-maxFixedAdd(),-maxFixedAdd()-1) throws \\n     */\\n    function maxFixedAdd() public pure returns(int256) {\\n        return 28948022309329048855892746252171976963317496166410141009864396001978282409983;\\n    }\\n\\n    /**\\n     * @notice Maximum negative value that can be safely in a subtraction.\\n     * @dev Test maxFixedSub() equals minInt256() / 2\\n     */\\n    function maxFixedSub() public pure returns(int256) {\\n        return -28948022309329048855892746252171976963317496166410141009864396001978282409984;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be safely used as a multiplication operator.\\n     * @dev Calculated as sqrt(maxInt256()*fixed1()). \\n     * Be careful with your sqrt() implementation. I couldn't find a calculator\\n     * that would give the exact square root of maxInt256*fixed1 so this number\\n     * is below the real number by no more than 3*10**28. It is safe to use as\\n     * a limit for your multiplications, although powers of two of numbers over\\n     * this value might still work.\\n     * Test multiply(maxFixedMul(),maxFixedMul()) equals maxFixedMul() * maxFixedMul()\\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) throws \\n     * Test multiply(-maxFixedMul(),maxFixedMul()) equals -maxFixedMul() * maxFixedMul()\\n     * Test multiply(-maxFixedMul(),maxFixedMul()+1) throws \\n     * Hardcoded to 24 digits.\\n     */\\n    function maxFixedMul() public pure returns(int256) {\\n        return 240615969168004498257251713877715648331380787511296;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be safely used as a dividend.\\n     * @dev divide(maxFixedDiv,newFixedFraction(1,fixed1())) = maxInt256().\\n     * Test maxFixedDiv() equals maxInt256()/fixed1()\\n     * Test divide(maxFixedDiv(),multiply(mulPrecision(),mulPrecision())) = maxFixedDiv()*(10^digits())\\n     * Test divide(maxFixedDiv()+1,multiply(mulPrecision(),mulPrecision())) throws\\n     * Hardcoded to 24 digits.\\n     */\\n    function maxFixedDiv() public pure returns(int256) {\\n        return 57896044618658097711785492504343953926634992332820282;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be safely used as a divisor.\\n     * @dev Test maxFixedDivisor() equals fixed1()*fixed1() - Or 10**(digits()*2)\\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2)) = returns 10*fixed1()\\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2 + 1)) = throws\\n     * Hardcoded to 24 digits.\\n     */\\n    function maxFixedDivisor() public pure returns(int256) {\\n        return 1000000000000000000000000000000000000000000000000;\\n    }\\n\\n    /**\\n     * @notice Converts an int256 to fixed point units, equivalent to multiplying\\n     * by 10^digits().\\n     * @dev Test newFixed(0) returns 0\\n     * Test newFixed(1) returns fixed1()\\n     * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\\n     * Test newFixed(maxNewFixed()+1) fails\\n     */\\n    function newFixed(int256 x)\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        assert(x <= maxNewFixed());\\n        assert(x >= minNewFixed());\\n        return x * fixed1();\\n    }\\n\\n    /**\\n     * @notice Converts an int256 in the fixed point representation of this \\n     * library to a non decimal. All decimal digits will be truncated.\\n     */\\n    function fromFixed(int256 x)\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        return x / fixed1();\\n    }\\n\\n    /**\\n     * @notice Converts an int256 which is already in some fixed point \\n     * representation to a different fixed precision representation.\\n     * Both the origin and destination precisions must be 38 or less digits.\\n     * Origin values with a precision higher than the destination precision\\n     * will be truncated accordingly.\\n     * @dev \\n     * Test convertFixed(1,0,0) returns 1;\\n     * Test convertFixed(1,1,1) returns 1;\\n     * Test convertFixed(1,1,0) returns 0;\\n     * Test convertFixed(1,0,1) returns 10;\\n     * Test convertFixed(10,1,0) returns 1;\\n     * Test convertFixed(10,0,1) returns 100;\\n     * Test convertFixed(100,1,0) returns 10;\\n     * Test convertFixed(100,0,1) returns 1000;\\n     * Test convertFixed(1000,2,0) returns 10;\\n     * Test convertFixed(1000,0,2) returns 100000;\\n     * Test convertFixed(1000,2,1) returns 100;\\n     * Test convertFixed(1000,1,2) returns 10000;\\n     * Test convertFixed(maxInt256,1,0) returns maxInt256/10;\\n     * Test convertFixed(maxInt256,0,1) throws\\n     * Test convertFixed(maxInt256,38,0) returns maxInt256/(10**38);\\n     * Test convertFixed(1,0,38) returns 10**38;\\n     * Test convertFixed(maxInt256,39,0) throws\\n     * Test convertFixed(1,0,39) throws\\n     */\\n    function convertFixed(int256 x, int8 _originDigits, int8 _destinationDigits)\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        assert(_originDigits <= 38 && _destinationDigits <= 38);\\n        \\n        int8 decimalDifference;\\n        if ( _originDigits > _destinationDigits ){\\n            decimalDifference = _originDigits - _destinationDigits;\\n            return x/(int128(10)**uint8(decimalDifference));\\n        }\\n        else if ( _originDigits < _destinationDigits ){\\n            decimalDifference = _destinationDigits - _originDigits;\\n            // Cast uint8 -> uint128 is safe\\n            // Exponentiation is safe:\\n            //     _originDigits and _destinationDigits limited to 38 or less\\n            //     decimalDifference = abs(_destinationDigits - _originDigits)\\n            //     decimalDifference < 38\\n            //     10**38 < 2**128-1\\n            assert(x <= maxInt256()/int128(10)**uint8(decimalDifference));\\n            assert(x >= minInt256()/int128(10)**uint8(decimalDifference));\\n            return x*(int128(10)**uint8(decimalDifference));\\n        }\\n        // _originDigits == digits()) \\n        return x;\\n    }\\n\\n    /**\\n     * @notice Converts an int256 which is already in some fixed point \\n     * representation to that of this library. The _originDigits parameter is the\\n     * precision of x. Values with a precision higher than FixidityLib.digits()\\n     * will be truncated accordingly.\\n     */\\n    function newFixed(int256 x, int8 _originDigits)\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        return convertFixed(x, _originDigits, digits());\\n    }\\n\\n    /**\\n     * @notice Converts an int256 in the fixed point representation of this \\n     * library to a different representation. The _destinationDigits parameter is the\\n     * precision of the output x. Values with a precision below than \\n     * FixidityLib.digits() will be truncated accordingly.\\n     */\\n    function fromFixed(int256 x, int8 _destinationDigits)\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        return convertFixed(x, digits(), _destinationDigits);\\n    }\\n\\n    /**\\n     * @notice Converts two int256 representing a fraction to fixed point units,\\n     * equivalent to multiplying dividend and divisor by 10^digits().\\n     * @dev \\n     * Test newFixedFraction(maxFixedDiv()+1,1) fails\\n     * Test newFixedFraction(1,maxFixedDiv()+1) fails\\n     * Test newFixedFraction(1,0) fails     \\n     * Test newFixedFraction(0,1) returns 0\\n     * Test newFixedFraction(1,1) returns fixed1()\\n     * Test newFixedFraction(maxFixedDiv(),1) returns maxFixedDiv()*fixed1()\\n     * Test newFixedFraction(1,fixed1()) returns 1\\n     * Test newFixedFraction(1,fixed1()-1) returns 0\\n     */\\n    function newFixedFraction(\\n        int256 numerator, \\n        int256 denominator\\n        )\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        assert(numerator <= maxNewFixed());\\n        assert(denominator <= maxNewFixed());\\n        assert(denominator != 0);\\n        int256 convertedNumerator = newFixed(numerator);\\n        int256 convertedDenominator = newFixed(denominator);\\n        return divide(convertedNumerator, convertedDenominator);\\n    }\\n\\n    /**\\n     * @notice Returns the integer part of a fixed point number.\\n     * @dev \\n     * Test integer(0) returns 0\\n     * Test integer(fixed1()) returns fixed1()\\n     * Test integer(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\\n     * Test integer(-fixed1()) returns -fixed1()\\n     * Test integer(newFixed(-maxNewFixed())) returns -maxNewFixed()*fixed1()\\n     */\\n    function integer(int256 x) public pure returns (int256) {\\n        return (x / fixed1()) * fixed1(); // Can't overflow\\n    }\\n\\n    /**\\n     * @notice Returns the fractional part of a fixed point number. \\n     * In the case of a negative number the fractional is also negative.\\n     * @dev \\n     * Test fractional(0) returns 0\\n     * Test fractional(fixed1()) returns 0\\n     * Test fractional(fixed1()-1) returns 10^24-1\\n     * Test fractional(-fixed1()) returns 0\\n     * Test fractional(-fixed1()+1) returns -10^24-1\\n     */\\n    function fractional(int256 x) public pure returns (int256) {\\n        return x - (x / fixed1()) * fixed1(); // Can't overflow\\n    }\\n\\n    /**\\n     * @notice Converts to positive if negative.\\n     * Due to int256 having one more negative number than positive numbers \\n     * abs(minInt256) reverts.\\n     * @dev \\n     * Test abs(0) returns 0\\n     * Test abs(fixed1()) returns -fixed1()\\n     * Test abs(-fixed1()) returns fixed1()\\n     * Test abs(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\\n     * Test abs(newFixed(minNewFixed())) returns -minNewFixed()*fixed1()\\n     */\\n    function abs(int256 x) public pure returns (int256) {\\n        if (x >= 0) {\\n            return x;\\n        } else {\\n            int256 result = -x;\\n            assert (result > 0);\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice x+y. If any operator is higher than maxFixedAdd() it \\n     * might overflow.\\n     * In solidity maxInt256 + 1 = minInt256 and viceversa.\\n     * @dev \\n     * Test add(maxFixedAdd(),maxFixedAdd()) returns maxInt256()-1\\n     * Test add(maxFixedAdd()+1,maxFixedAdd()+1) fails\\n     * Test add(-maxFixedSub(),-maxFixedSub()) returns minInt256()\\n     * Test add(-maxFixedSub()-1,-maxFixedSub()-1) fails\\n     * Test add(maxInt256(),maxInt256()) fails\\n     * Test add(minInt256(),minInt256()) fails\\n     */\\n    function add(int256 x, int256 y) public pure returns (int256) {\\n        int256 z = x + y;\\n        if (x > 0 && y > 0) assert(z > x && z > y);\\n        if (x < 0 && y < 0) assert(z < x && z < y);\\n        return z;\\n    }\\n\\n    /**\\n     * @notice x-y. You can use add(x,-y) instead. \\n     * @dev Tests covered by add(x,y)\\n     */\\n    function subtract(int256 x, int256 y) public pure returns (int256) {\\n        return add(x,-y);\\n    }\\n\\n    /**\\n     * @notice x*y. If any of the operators is higher than maxFixedMul() it \\n     * might overflow.\\n     * @dev \\n     * Test multiply(0,0) returns 0\\n     * Test multiply(maxFixedMul(),0) returns 0\\n     * Test multiply(0,maxFixedMul()) returns 0\\n     * Test multiply(maxFixedMul(),fixed1()) returns maxFixedMul()\\n     * Test multiply(fixed1(),maxFixedMul()) returns maxFixedMul()\\n     * Test all combinations of (2,-2), (2, 2.5), (2, -2.5) and (0.5, -0.5)\\n     * Test multiply(fixed1()/mulPrecision(),fixed1()*mulPrecision())\\n     * Test multiply(maxFixedMul()-1,maxFixedMul()) equals multiply(maxFixedMul(),maxFixedMul()-1)\\n     * Test multiply(maxFixedMul(),maxFixedMul()) returns maxInt256() // Probably not to the last digits\\n     * Test multiply(maxFixedMul()+1,maxFixedMul()) fails\\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) fails\\n     */\\n    function multiply(int256 x, int256 y) public pure returns (int256) {\\n        if (x == 0 || y == 0) return 0;\\n        if (y == fixed1()) return x;\\n        if (x == fixed1()) return y;\\n\\n        // Separate into integer and fractional parts\\n        // x = x1 + x2, y = y1 + y2\\n        int256 x1 = integer(x) / fixed1();\\n        int256 x2 = fractional(x);\\n        int256 y1 = integer(y) / fixed1();\\n        int256 y2 = fractional(y);\\n        \\n        // (x1 + x2) * (y1 + y2) = (x1 * y1) + (x1 * y2) + (x2 * y1) + (x2 * y2)\\n        int256 x1y1 = x1 * y1;\\n        if (x1 != 0) assert(x1y1 / x1 == y1); // Overflow x1y1\\n        \\n        // x1y1 needs to be multiplied back by fixed1\\n        // solium-disable-next-line mixedcase\\n        int256 fixed_x1y1 = x1y1 * fixed1();\\n        if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed1()); // Overflow x1y1 * fixed1\\n        x1y1 = fixed_x1y1;\\n\\n        int256 x2y1 = x2 * y1;\\n        if (x2 != 0) assert(x2y1 / x2 == y1); // Overflow x2y1\\n\\n        int256 x1y2 = x1 * y2;\\n        if (x1 != 0) assert(x1y2 / x1 == y2); // Overflow x1y2\\n\\n        x2 = x2 / mulPrecision();\\n        y2 = y2 / mulPrecision();\\n        int256 x2y2 = x2 * y2;\\n        if (x2 != 0) assert(x2y2 / x2 == y2); // Overflow x2y2\\n\\n        // result = fixed1() * x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2 / fixed1();\\n        int256 result = x1y1;\\n        result = add(result, x2y1); // Add checks for overflow\\n        result = add(result, x1y2); // Add checks for overflow\\n        result = add(result, x2y2); // Add checks for overflow\\n        return result;\\n    }\\n    \\n    /**\\n     * @notice 1/x\\n     * @dev \\n     * Test reciprocal(0) fails\\n     * Test reciprocal(fixed1()) returns fixed1()\\n     * Test reciprocal(fixed1()*fixed1()) returns 1 // Testing how the fractional is truncated\\n     * Test reciprocal(2*fixed1()*fixed1()) returns 0 // Testing how the fractional is truncated\\n     */\\n    function reciprocal(int256 x) public pure returns (int256) {\\n        assert(x != 0);\\n        return (fixed1()*fixed1()) / x; // Can't overflow\\n    }\\n\\n    /**\\n     * @notice x/y. If the dividend is higher than maxFixedDiv() it \\n     * might overflow. You can use multiply(x,reciprocal(y)) instead.\\n     * There is a loss of precision on division for the lower mulPrecision() decimals.\\n     * @dev \\n     * Test divide(fixed1(),0) fails\\n     * Test divide(maxFixedDiv(),1) = maxFixedDiv()*(10^digits())\\n     * Test divide(maxFixedDiv()+1,1) throws\\n     * Test divide(maxFixedDiv(),maxFixedDiv()) returns fixed1()\\n     */\\n    function divide(int256 x, int256 y) public pure returns (int256) {\\n        if (y == fixed1()) return x;\\n        assert(y != 0);\\n        assert(y <= maxFixedDivisor());\\n        return multiply(x, reciprocal(y));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"abs\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"add\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"},{\"internalType\":\"int8\",\"name\":\"_originDigits\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"_destinationDigits\",\"type\":\"int8\"}],\"name\":\"convertFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"digits\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"divide\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixed1\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"fractional\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"fromFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"},{\"internalType\":\"int8\",\"name\":\"_destinationDigits\",\"type\":\"int8\"}],\"name\":\"fromFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"integer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFixedAdd\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFixedDiv\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFixedDivisor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFixedMul\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFixedSub\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxInt256\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxNewFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minInt256\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minNewFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mulPrecision\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"multiply\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"},{\"internalType\":\"int8\",\"name\":\"_originDigits\",\"type\":\"int8\"}],\"name\":\"newFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"newFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"numerator\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"denominator\",\"type\":\"int256\"}],\"name\":\"newFixedFraction\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"reciprocal\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"subtract\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Fixidity", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}