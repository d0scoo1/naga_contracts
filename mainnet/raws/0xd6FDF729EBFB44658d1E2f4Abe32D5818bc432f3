{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"basic.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport { TokenInterface } from \\\"./interfaces.sol\\\";\\nimport { Stores } from \\\"./stores.sol\\\";\\nimport { DSMath } from \\\"./math.sol\\\";\\n\\nabstract contract Basic is DSMath, Stores {\\n\\tfunction convert18ToDec(uint256 _dec, uint256 _amt)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256 amt)\\n\\t{\\n\\t\\tamt = (_amt / 10**(18 - _dec));\\n\\t}\\n\\n\\tfunction convertTo18(uint256 _dec, uint256 _amt)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256 amt)\\n\\t{\\n\\t\\tamt = mul(_amt, 10**(18 - _dec));\\n\\t}\\n\\n\\tfunction getTokenBal(TokenInterface token)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint256 _amt)\\n\\t{\\n\\t\\t_amt = address(token) == ethAddr\\n\\t\\t\\t? address(this).balance\\n\\t\\t\\t: token.balanceOf(address(this));\\n\\t}\\n\\n\\tfunction getTokensDec(TokenInterface buyAddr, TokenInterface sellAddr)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint256 buyDec, uint256 sellDec)\\n\\t{\\n\\t\\tbuyDec = address(buyAddr) == ethAddr ? 18 : buyAddr.decimals();\\n\\t\\tsellDec = address(sellAddr) == ethAddr ? 18 : sellAddr.decimals();\\n\\t}\\n\\n\\tfunction encodeEvent(string memory eventName, bytes memory eventParam)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn abi.encode(eventName, eventParam);\\n\\t}\\n\\n\\tfunction approve(\\n\\t\\tTokenInterface token,\\n\\t\\taddress spender,\\n\\t\\tuint256 amount\\n\\t) internal {\\n\\t\\ttry token.approve(spender, amount) {} catch {\\n\\t\\t\\ttoken.approve(spender, 0);\\n\\t\\t\\ttoken.approve(spender, amount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction changeEthAddress(address buy, address sell)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (TokenInterface _buy, TokenInterface _sell)\\n\\t{\\n\\t\\t_buy = buy == ethAddr ? TokenInterface(wethAddr) : TokenInterface(buy);\\n\\t\\t_sell = sell == ethAddr\\n\\t\\t\\t? TokenInterface(wethAddr)\\n\\t\\t\\t: TokenInterface(sell);\\n\\t}\\n\\n\\tfunction changeEthAddrToWethAddr(address token)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (address tokenAddr)\\n\\t{\\n\\t\\ttokenAddr = token == ethAddr ? wethAddr : token;\\n\\t}\\n\\n\\tfunction convertEthToWeth(\\n\\t\\tbool isEth,\\n\\t\\tTokenInterface token,\\n\\t\\tuint256 amount\\n\\t) internal {\\n\\t\\tif (isEth) token.deposit{ value: amount }();\\n\\t}\\n\\n\\tfunction convertWethToEth(\\n\\t\\tbool isEth,\\n\\t\\tTokenInterface token,\\n\\t\\tuint256 amount\\n\\t) internal {\\n\\t\\tif (isEth) {\\n\\t\\t\\tapprove(token, address(token), amount);\\n\\t\\t\\ttoken.withdraw(amount);\\n\\t\\t}\\n\\t}\\n}\\n\"},\"events.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\n\\ncontract Events {\\n\\tevent LogDeposit(address token, uint256 amount, address path, bool stake);\\n\\tevent LogWithdraw(\\n\\t\\taddress token,\\n\\t\\tuint256 amount,\\n\\t\\taddress path,\\n\\t\\tbool unstake\\n\\t);\\n\\tevent LogClaimRewards(address token, uint256 amount);\\n\\tevent LogSwap(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOut\\n\\t);\\n}\\n\"},\"helpers.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\n\\nimport { DSMath } from \\\"./math.sol\\\";\\nimport { Basic } from \\\"./basic.sol\\\";\\n\\nimport { TokenInterface } from \\\"./interfaces.sol\\\";\\nimport { ISavingsContractV2, IBoostedSavingsVault } from \\\"./interface.sol\\\";\\n\\nabstract contract Helpers is DSMath, Basic {\\n\\taddress internal constant mUsdToken =\\n\\t\\t0xe2f2a5C287993345a840Db3B0845fbC70f5935a5;\\n\\taddress internal constant imUsdToken =\\n\\t\\t0x30647a72Dc82d7Fbb1123EA74716aB8A317Eac19;\\n\\taddress internal constant imUsdVault =\\n\\t\\t0x78BefCa7de27d07DC6e71da295Cc2946681A6c7B;\\n\\n\\t/***************************************\\n                    Internal\\n    ****************************************/\\n\\n\\t/**\\n\\t * @dev Deposit to Save from any asset\\n\\t * @notice Called internally from deposit functions\\n\\t * @param _token Address of token to deposit\\n\\t * @param _amount Amount of token to deposit\\n\\t * @param _path Path to mint mUSD (only needed for Feeder Pool)\\n\\t * @param _stake stake token in Vault?\\n\\t * @return _eventName Event name\\n\\t * @return _eventParam Event parameters\\n\\t */\\n\\n\\tfunction _deposit(\\n\\t\\taddress _token,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _path,\\n\\t\\tbool _stake\\n\\t) internal returns (string memory _eventName, bytes memory _eventParam) {\\n\\t\\t// 1. Deposit mUSD to Save\\n\\t\\tapprove(TokenInterface(mUsdToken), imUsdToken, _amount);\\n\\t\\tuint256 credits = ISavingsContractV2(imUsdToken).depositSavings(\\n\\t\\t\\t_amount\\n\\t\\t);\\n\\n\\t\\tif (_stake) {\\n\\t\\t\\t// 2. Stake imUSD to Vault\\n\\t\\t\\tapprove(TokenInterface(imUsdToken), imUsdVault, credits);\\n\\t\\t\\tIBoostedSavingsVault(imUsdVault).stake(credits);\\n\\t\\t}\\n\\t\\t// 3. Log Events\\n\\t\\t_eventName = \\\"LogDeposit(address,uint256,address,bool)\\\";\\n\\t\\t_eventParam = abi.encode(_token, _amount, _path, _stake);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Withdraws from Save\\n\\t * @notice Withdraws token supported by mStable from Save\\n\\t * @param _credits Credits to withdraw\\n\\t * @param _unstake unstake from Vault?\\n\\t * @return amountWithdrawn Amount withdrawn in mUSD\\n\\t */\\n\\n\\tfunction _withdraw(uint256 _credits, bool _unstake)\\n\\t\\tinternal\\n\\t\\treturns (uint256 amountWithdrawn)\\n\\t{\\n\\t\\tuint256 credits;\\n\\t\\t// 1. Withdraw from Vault\\n\\t\\tif (_unstake) {\\n\\t\\t\\tcredits = _credits == uint256(-1)\\n\\t\\t\\t\\t? TokenInterface(imUsdVault).balanceOf(address(this))\\n\\t\\t\\t\\t: _credits;\\n\\t\\t\\tIBoostedSavingsVault(imUsdVault).withdraw(credits);\\n\\t\\t}\\n\\n\\t\\t// 2. Withdraw from Save\\n\\t\\tcredits = _credits == uint256(-1)\\n\\t\\t\\t? TokenInterface(imUsdToken).balanceOf(address(this))\\n\\t\\t\\t: _credits;\\n\\t\\tapprove(TokenInterface(imUsdToken), imUsdVault, _credits);\\n\\t\\tamountWithdrawn = ISavingsContractV2(imUsdToken).redeemCredits(credits);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the reward tokens\\n\\t * @notice Gets the reward tokens from the vault contract\\n\\t * @return rewardToken Address of reward token\\n\\t */\\n\\n\\tfunction _getRewardTokens() internal view returns (address rewardToken) {\\n\\t\\trewardToken = address(\\n\\t\\t\\tIBoostedSavingsVault(imUsdVault).getRewardToken()\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the internal balances of the rewardToken and platformToken\\n\\t * @notice Gets current balances of rewardToken and platformToken, used for calculating rewards accrued\\n\\t * @param _rewardToken Address of reward token\\n\\t * @return a Amount of reward token\\n\\t */\\n\\n\\tfunction _getRewardInternalBal(address _rewardToken)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint256 a)\\n\\t{\\n\\t\\ta = TokenInterface(_rewardToken).balanceOf(address(this));\\n\\t}\\n}\\n\"},\"interface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\n\\ninterface IMasset {\\n\\tfunction mint(\\n\\t\\taddress _input,\\n\\t\\tuint256 _inputQuantity,\\n\\t\\tuint256 _minOutputQuantity,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256 mintOutput);\\n\\n\\tfunction mintMulti(\\n\\t\\taddress[] calldata _inputs,\\n\\t\\tuint256[] calldata _inputQuantities,\\n\\t\\tuint256 _minOutputQuantity,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256 mintOutput);\\n\\n\\tfunction getMintOutput(address _input, uint256 _inputQuantity)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256 mintOutput);\\n\\n\\tfunction getMintMultiOutput(\\n\\t\\taddress[] calldata _inputs,\\n\\t\\tuint256[] calldata _inputQuantities\\n\\t) external view returns (uint256 mintOutput);\\n\\n\\tfunction swap(\\n\\t\\taddress _input,\\n\\t\\taddress _output,\\n\\t\\tuint256 _inputQuantity,\\n\\t\\tuint256 _minOutputQuantity,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256 swapOutput);\\n\\n\\tfunction getSwapOutput(\\n\\t\\taddress _input,\\n\\t\\taddress _output,\\n\\t\\tuint256 _inputQuantity\\n\\t) external view returns (uint256 swapOutput);\\n\\n\\tfunction redeem(\\n\\t\\taddress _output,\\n\\t\\tuint256 _mAssetQuantity,\\n\\t\\tuint256 _minOutputQuantity,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256 outputQuantity);\\n\\n\\tfunction redeemMasset(\\n\\t\\tuint256 _mAssetQuantity,\\n\\t\\tuint256[] calldata _minOutputQuantities,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256[] memory outputQuantities);\\n\\n\\tfunction redeemExactBassets(\\n\\t\\taddress[] calldata _outputs,\\n\\t\\tuint256[] calldata _outputQuantities,\\n\\t\\tuint256 _maxMassetQuantity,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256 mAssetRedeemed);\\n\\n\\tfunction getRedeemOutput(address _output, uint256 _mAssetQuantity)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256 bAssetOutput);\\n\\n\\tfunction getRedeemExactBassetsOutput(\\n\\t\\taddress[] calldata _outputs,\\n\\t\\tuint256[] calldata _outputQuantities\\n\\t) external view returns (uint256 mAssetAmount);\\n\\n\\t// Views\\n\\t// This return an index, could be used to check if it\\u0027s part of the basket\\n\\tfunction bAssetIndexes(address) external view returns (uint8);\\n\\n\\tfunction getPrice() external view returns (uint256 price, uint256 k);\\n}\\n\\ninterface ISavingsContractV2 {\\n\\tfunction depositInterest(uint256 _amount) external; // V1 \\u0026 V2\\n\\n\\tfunction depositSavings(uint256 _amount)\\n\\t\\texternal\\n\\t\\treturns (uint256 creditsIssued); // V1 \\u0026 V2\\n\\n\\tfunction depositSavings(uint256 _amount, address _beneficiary)\\n\\t\\texternal\\n\\t\\treturns (uint256 creditsIssued); // V2\\n\\n\\tfunction redeemCredits(uint256 _amount)\\n\\t\\texternal\\n\\t\\treturns (uint256 underlyingReturned); // V2\\n\\n\\tfunction redeemUnderlying(uint256 _amount)\\n\\t\\texternal\\n\\t\\treturns (uint256 creditsBurned); // V2\\n\\n\\tfunction exchangeRate() external view returns (uint256); // V1 \\u0026 V2\\n\\n\\tfunction balanceOfUnderlying(address _user)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256 balance); // V2\\n\\n\\tfunction underlyingToCredits(uint256 _credits)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256 underlying); // V2\\n\\n\\tfunction creditsToUnderlying(uint256 _underlying)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256 credits); // V2\\n}\\n\\ninterface IBoostedSavingsVault {\\n\\t/**\\n\\t * @dev Stakes a given amount of the StakingToken for the sender\\n\\t * @param _amount Units of StakingToken\\n\\t */\\n\\tfunction stake(uint256 _amount) external;\\n\\n\\t/**\\n\\t * @dev Stakes a given amount of the StakingToken for a given beneficiary\\n\\t * @param _beneficiary Staked tokens are credited to this address\\n\\t * @param _amount      Units of StakingToken\\n\\t */\\n\\tfunction stake(address _beneficiary, uint256 _amount) external;\\n\\n\\t/**\\n\\t * @dev Withdraws stake from pool and claims any unlocked rewards.\\n\\t * Note, this function is costly - the args for _claimRewards\\n\\t * should be determined off chain and then passed to other fn\\n\\t */\\n\\tfunction exit() external;\\n\\n\\t/**\\n\\t * @dev Withdraws stake from pool and claims any unlocked rewards.\\n\\t * @param _first    Index of the first array element to claim\\n\\t * @param _last     Index of the last array element to claim\\n\\t */\\n\\tfunction exit(uint256 _first, uint256 _last) external;\\n\\n\\t/**\\n\\t * @dev Withdraws given stake amount from the pool\\n\\t * @param _amount Units of the staked token to withdraw\\n\\t */\\n\\tfunction withdraw(uint256 _amount) external;\\n\\n\\t/**\\n\\t * @dev Claims only the tokens that have been immediately unlocked, not including\\n\\t * those that are in the lockers.\\n\\t */\\n\\tfunction claimReward() external;\\n\\n\\t/**\\n\\t * @dev Claims all unlocked rewards for sender.\\n\\t * Note, this function is costly - the args for _claimRewards\\n\\t * should be determined off chain and then passed to other fn\\n\\t */\\n\\tfunction claimRewards() external;\\n\\n\\t/**\\n\\t * @dev Claims all unlocked rewards for sender. Both immediately unlocked\\n\\t * rewards and also locked rewards past their time lock.\\n\\t * @param _first    Index of the first array element to claim\\n\\t * @param _last     Index of the last array element to claim\\n\\t */\\n\\tfunction claimRewards(uint256 _first, uint256 _last) external;\\n\\n\\t/**\\n\\t * @dev Pokes a given account to reset the boost\\n\\t */\\n\\tfunction pokeBoost(address _account) external;\\n\\n\\t/**\\n\\t * @dev Gets the RewardsToken\\n\\t */\\n\\tfunction getRewardToken() external view returns (IERC20);\\n\\n\\t/**\\n\\t * @dev Gets the last applicable timestamp for this reward period\\n\\t */\\n\\tfunction lastTimeRewardApplicable() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Calculates the amount of unclaimed rewards per token since last update,\\n\\t * and sums with stored to give the new cumulative reward per token\\n\\t * @return \\u0027Reward\\u0027 per staked token\\n\\t */\\n\\tfunction rewardPerToken() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returned the units of IMMEDIATELY claimable rewards a user has to receive. Note - this\\n\\t * does NOT include the majority of rewards which will be locked up.\\n\\t * @param _account User address\\n\\t * @return Total reward amount earned\\n\\t */\\n\\tfunction earned(address _account) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Calculates all unclaimed reward data, finding both immediately unlocked rewards\\n\\t * and those that have passed their time lock.\\n\\t * @param _account User address\\n\\t * @return amount Total units of unclaimed rewards\\n\\t * @return first Index of the first userReward that has unlocked\\n\\t * @return last Index of the last userReward that has unlocked\\n\\t */\\n\\tfunction unclaimedRewards(address _account)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint256 amount,\\n\\t\\t\\tuint256 first,\\n\\t\\t\\tuint256 last\\n\\t\\t);\\n}\\n\\ninterface IFeederPool {\\n\\t// Mint\\n\\tfunction mint(\\n\\t\\taddress _input,\\n\\t\\tuint256 _inputQuantity,\\n\\t\\tuint256 _minOutputQuantity,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256 mintOutput);\\n\\n\\tfunction mintMulti(\\n\\t\\taddress[] calldata _inputs,\\n\\t\\tuint256[] calldata _inputQuantities,\\n\\t\\tuint256 _minOutputQuantity,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256 mintOutput);\\n\\n\\tfunction getMintOutput(address _input, uint256 _inputQuantity)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256 mintOutput);\\n\\n\\tfunction getMintMultiOutput(\\n\\t\\taddress[] calldata _inputs,\\n\\t\\tuint256[] calldata _inputQuantities\\n\\t) external view returns (uint256 mintOutput);\\n\\n\\t// Swaps\\n\\tfunction swap(\\n\\t\\taddress _input,\\n\\t\\taddress _output,\\n\\t\\tuint256 _inputQuantity,\\n\\t\\tuint256 _minOutputQuantity,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256 swapOutput);\\n\\n\\tfunction getSwapOutput(\\n\\t\\taddress _input,\\n\\t\\taddress _output,\\n\\t\\tuint256 _inputQuantity\\n\\t) external view returns (uint256 swapOutput);\\n\\n\\t// Redemption\\n\\tfunction redeem(\\n\\t\\taddress _output,\\n\\t\\tuint256 _fpTokenQuantity,\\n\\t\\tuint256 _minOutputQuantity,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256 outputQuantity);\\n\\n\\tfunction redeemProportionately(\\n\\t\\tuint256 _fpTokenQuantity,\\n\\t\\tuint256[] calldata _minOutputQuantities,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256[] memory outputQuantities);\\n\\n\\tfunction redeemExactBassets(\\n\\t\\taddress[] calldata _outputs,\\n\\t\\tuint256[] calldata _outputQuantities,\\n\\t\\tuint256 _maxMassetQuantity,\\n\\t\\taddress _recipient\\n\\t) external returns (uint256 mAssetRedeemed);\\n\\n\\tfunction getRedeemOutput(address _output, uint256 _fpTokenQuantity)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256 bAssetOutput);\\n\\n\\tfunction getRedeemExactBassetsOutput(\\n\\t\\taddress[] calldata _outputs,\\n\\t\\tuint256[] calldata _outputQuantities\\n\\t) external view returns (uint256 mAssetAmount);\\n\\n\\t// Views\\n\\tfunction mAsset() external view returns (address);\\n\\n\\tfunction getPrice() external view returns (uint256 price, uint256 k);\\n}\\n\\ninterface IERC20 {\\n\\t/**\\n\\t * @dev Returns the amount of tokens in existence.\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the amount of tokens owned by `account`.\\n\\t */\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transfer(address recipient, uint256 amount)\\n\\t\\texternal\\n\\t\\treturns (bool);\\n\\n\\t/**\\n\\t * @dev Returns the remaining number of tokens that `spender` will be\\n\\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n\\t * zero by default.\\n\\t *\\n\\t * This value changes when {approve} or {transferFrom} are called.\\n\\t */\\n\\tfunction allowance(address owner, address spender)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\t/**\\n\\t * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n\\t * that someone may use both the old and the new allowance by unfortunate\\n\\t * transaction ordering. One possible solution to mitigate this race\\n\\t * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n\\t * desired value afterwards:\\n\\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t */\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n\\t * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n\\t * allowance.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\n\\t/**\\n\\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n\\t * another (`to`).\\n\\t *\\n\\t * Note that `value` may be zero.\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\t/**\\n\\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n\\t * a call to {approve}. `value` is the new allowance.\\n\\t */\\n\\tevent Approval(\\n\\t\\taddress indexed owner,\\n\\t\\taddress indexed spender,\\n\\t\\tuint256 value\\n\\t);\\n}\\n\"},\"interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\ninterface TokenInterface {\\n\\tfunction approve(address, uint256) external;\\n\\n\\tfunction transfer(address, uint256) external;\\n\\n\\tfunction transferFrom(\\n\\t\\taddress,\\n\\t\\taddress,\\n\\t\\tuint256\\n\\t) external;\\n\\n\\tfunction deposit() external payable;\\n\\n\\tfunction withdraw(uint256) external;\\n\\n\\tfunction balanceOf(address) external view returns (uint256);\\n\\n\\tfunction decimals() external view returns (uint256);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n}\\n\\ninterface MemoryInterface {\\n\\tfunction getUint(uint256 id) external returns (uint256 num);\\n\\n\\tfunction setUint(uint256 id, uint256 val) external;\\n}\\n\\ninterface InstaMapping {\\n\\tfunction cTokenMapping(address) external view returns (address);\\n\\n\\tfunction gemJoinMapping(bytes32) external view returns (address);\\n}\\n\\ninterface AccountInterface {\\n\\tfunction enable(address) external;\\n\\n\\tfunction disable(address) external;\\n\\n\\tfunction isAuth(address) external view returns (bool);\\n}\\n\"},\"main.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\n\\n/**\\n * @title mStable SAVE.\\n * @dev Depositing and withdrawing directly to Save\\n */\\n\\nimport { Helpers } from \\\"./helpers.sol\\\";\\nimport { Events } from \\\"./events.sol\\\";\\n\\nimport { TokenInterface } from \\\"./interfaces.sol\\\";\\nimport { IMasset, IBoostedSavingsVault, IFeederPool } from \\\"./interface.sol\\\";\\n\\nabstract contract mStableResolver is Events, Helpers {\\n\\t/***************************************\\n                    CORE\\n    ****************************************/\\n\\n\\t/**\\n\\t * @dev Deposit to Save via mUSD or bAsset\\n\\t * @notice Deposits token supported by mStable to Save\\n\\t * @param _token Address of token to deposit\\n\\t * @param _amount Amount of token to deposit\\n\\t * @param _minOut Minimum amount of token to mint/deposit, equal to _amount if mUSD\\n\\t * @param _stake stake token in Vault?\\n\\t * @param _getId ID to retrieve amt\\n\\t * @param _setId ID stores the amount of tokens deposited\\n\\t * @return _eventName Event name\\n\\t * @return _eventParam Event parameters\\n\\t */\\n\\n\\tfunction deposit(\\n\\t\\taddress _token,\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _minOut,\\n\\t\\tbool _stake,\\n\\t\\tuint256 _setId,\\n\\t\\tuint256 _getId\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (string memory _eventName, bytes memory _eventParam)\\n\\t{\\n\\t\\tuint256 amount = getUint(_getId, _amount);\\n\\t\\tamount = amount == uint256(-1)\\n\\t\\t\\t? TokenInterface(_token).balanceOf(address(this))\\n\\t\\t\\t: amount;\\n\\t\\tuint256 mintedAmount;\\n\\t\\taddress path;\\n\\n\\t\\t// Check if needs to be minted first\\n\\t\\tif (IMasset(mUsdToken).bAssetIndexes(_token) != 0) {\\n\\t\\t\\t// mint first\\n\\t\\t\\tapprove(TokenInterface(_token), mUsdToken, amount);\\n\\t\\t\\tmintedAmount = IMasset(mUsdToken).mint(\\n\\t\\t\\t\\t_token,\\n\\t\\t\\t\\tamount,\\n\\t\\t\\t\\t_minOut,\\n\\t\\t\\t\\taddress(this)\\n\\t\\t\\t);\\n\\t\\t\\tpath = mUsdToken;\\n\\t\\t} else {\\n\\t\\t\\trequire(amount \\u003e= _minOut, \\\"mintedAmount \\u003c _minOut\\\");\\n\\t\\t\\tmintedAmount = amount;\\n\\t\\t\\tpath = imUsdToken;\\n\\t\\t}\\n\\n\\t\\tsetUint(_setId, mintedAmount);\\n\\t\\t(_eventName, _eventParam) = _deposit(\\n\\t\\t\\t_token,\\n\\t\\t\\tmintedAmount,\\n\\t\\t\\tpath,\\n\\t\\t\\t_stake\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Deposit to Save via feeder pool\\n\\t * @notice Deposits token, requires _minOut for minting and _path\\n\\t * @param _token Address of token to deposit\\n\\t * @param _amount Amount of token to deposit\\n\\t * @param _minOut Minimum amount of token to mint\\n\\t * @param _path Feeder Pool address for _token\\n\\t * @param _stake stake token in Vault?\\n\\t * @param _getId ID to retrieve amt\\n\\t * @param _setId ID stores the amount of tokens deposited\\n\\t * @return _eventName Event name\\n\\t * @return _eventParam Event parameters\\n\\t */\\n\\n\\tfunction depositViaSwap(\\n\\t\\taddress _token,\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _minOut,\\n\\t\\taddress _path,\\n\\t\\tbool _stake,\\n\\t\\tuint256 _setId,\\n\\t\\tuint256 _getId\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (string memory _eventName, bytes memory _eventParam)\\n\\t{\\n\\t\\trequire(_path != address(0), \\\"Path must be set\\\");\\n\\t\\trequire(\\n\\t\\t\\tIMasset(mUsdToken).bAssetIndexes(_token) == 0,\\n\\t\\t\\t\\\"Token is bAsset\\\"\\n\\t\\t);\\n\\n\\t\\tuint256 amount = getUint(_getId, _amount);\\n\\t\\tamount = amount == uint256(-1)\\n\\t\\t\\t? TokenInterface(_token).balanceOf(address(this))\\n\\t\\t\\t: amount;\\n\\n\\t\\tapprove(TokenInterface(_token), _path, amount);\\n\\t\\tuint256 mintedAmount = IFeederPool(_path).swap(\\n\\t\\t\\t_token,\\n\\t\\t\\tmUsdToken,\\n\\t\\t\\tamount,\\n\\t\\t\\t_minOut,\\n\\t\\t\\taddress(this)\\n\\t\\t);\\n\\n\\t\\tsetUint(_setId, mintedAmount);\\n\\t\\t(_eventName, _eventParam) = _deposit(\\n\\t\\t\\t_token,\\n\\t\\t\\tmintedAmount,\\n\\t\\t\\t_path,\\n\\t\\t\\t_stake\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Withdraw from Save to mUSD or bAsset\\n\\t * @notice Withdraws from Save Vault to mUSD\\n\\t * @param _token Address of token to withdraw\\n\\t * @param _credits Credits to withdraw\\n\\t * @param _minOut Minimum amount of token to withdraw\\n\\t * @param _unstake from the Vault first?\\n\\t * @param _getId ID to retrieve amt\\n\\t * @param _setId ID stores the amount of tokens withdrawn\\n\\t * @return _eventName Event name\\n\\t * @return _eventParam Event parameters\\n\\t */\\n\\n\\tfunction withdraw(\\n\\t\\taddress _token,\\n\\t\\tuint256 _credits,\\n\\t\\tuint256 _minOut,\\n\\t\\tbool _unstake,\\n\\t\\tuint256 _getId,\\n\\t\\tuint256 _setId\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (string memory _eventName, bytes memory _eventParam)\\n\\t{\\n\\t\\tuint256 credits = getUint(_getId, _credits);\\n\\t\\tuint256 amountWithdrawn = _withdraw(credits, _unstake);\\n\\n\\t\\t// Check if needs to be redeemed\\n\\t\\tif (IMasset(mUsdToken).bAssetIndexes(_token) != 0) {\\n\\t\\t\\tamountWithdrawn = IMasset(mUsdToken).redeem(\\n\\t\\t\\t\\t_token,\\n\\t\\t\\t\\tamountWithdrawn,\\n\\t\\t\\t\\t_minOut,\\n\\t\\t\\t\\taddress(this)\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\trequire(amountWithdrawn \\u003e= _minOut, \\\"amountWithdrawn \\u003c _minOut\\\");\\n\\t\\t}\\n\\n\\t\\tsetUint(_setId, amountWithdrawn);\\n\\t\\t_eventName = \\\"LogWithdraw(address,uint256,address,bool)\\\";\\n\\t\\t_eventParam = abi.encode(\\n\\t\\t\\tmUsdToken,\\n\\t\\t\\tamountWithdrawn,\\n\\t\\t\\timUsdToken,\\n\\t\\t\\t_unstake\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Withdraw from Save via Feeder Pool\\n\\t * @notice Withdraws from Save Vault to asset via Feeder Pool\\n\\t * @param _token bAsset to withdraw to\\n\\t * @param _credits Credits to withdraw\\n\\t * @param _minOut Minimum amount of token to mint\\n\\t * @param _path Feeder Pool address for _token\\n\\t * @param _unstake from the Vault first?\\n\\t * @param _getId ID to retrieve amt\\n\\t * @param _setId ID stores the amount of tokens withdrawn\\n\\t * @return _eventName Event name\\n\\t * @return _eventParam Event parameters\\n\\t */\\n\\n\\tfunction withdrawViaSwap(\\n\\t\\taddress _token,\\n\\t\\tuint256 _credits,\\n\\t\\tuint256 _minOut,\\n\\t\\taddress _path,\\n\\t\\tbool _unstake,\\n\\t\\tuint256 _getId,\\n\\t\\tuint256 _setId\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (string memory _eventName, bytes memory _eventParam)\\n\\t{\\n\\t\\trequire(_path != address(0), \\\"Path must be set\\\");\\n\\t\\trequire(\\n\\t\\t\\tIMasset(mUsdToken).bAssetIndexes(_token) == 0,\\n\\t\\t\\t\\\"Token is bAsset\\\"\\n\\t\\t);\\n\\n\\t\\tuint256 credits = getUint(_getId, _credits);\\n\\n\\t\\tuint256 amountWithdrawn = _withdraw(credits, _unstake);\\n\\n\\t\\tapprove(TokenInterface(mUsdToken), _path, amountWithdrawn);\\n\\t\\tuint256 amountRedeemed = IFeederPool(_path).swap(\\n\\t\\t\\tmUsdToken,\\n\\t\\t\\t_token,\\n\\t\\t\\tamountWithdrawn,\\n\\t\\t\\t_minOut,\\n\\t\\t\\taddress(this)\\n\\t\\t);\\n\\n\\t\\tsetUint(_setId, amountRedeemed);\\n\\n\\t\\t_eventName = \\\"LogWithdraw(address,uint256,address,bool)\\\";\\n\\t\\t_eventParam = abi.encode(_token, amountRedeemed, _path, _unstake);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Claims Rewards\\n\\t * @notice Claims accrued rewards from the Vault\\n\\t * @param _getId ID to retrieve amt\\n\\t * @param _setId ID stores the amount of tokens withdrawn\\n\\t * @return _eventName Event name\\n\\t * @return _eventParam Event parameters\\n\\t */\\n\\n\\tfunction claimRewards(uint256 _getId, uint256 _setId)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (string memory _eventName, bytes memory _eventParam)\\n\\t{\\n\\t\\taddress rewardToken = _getRewardTokens();\\n\\t\\tuint256 rewardAmount = _getRewardInternalBal(rewardToken);\\n\\n\\t\\tIBoostedSavingsVault(imUsdVault).claimReward();\\n\\n\\t\\tuint256 rewardAmountUpdated = _getRewardInternalBal(rewardToken);\\n\\n\\t\\tuint256 claimedRewardToken = sub(rewardAmountUpdated, rewardAmount);\\n\\n\\t\\tsetUint(_setId, claimedRewardToken);\\n\\n\\t\\t_eventName = \\\"LogClaimRewards(address,uint256)\\\";\\n\\t\\t_eventParam = abi.encode(rewardToken, claimedRewardToken);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Swap tokens\\n\\t * @notice Swaps tokens via Masset basket\\n\\t * @param _input Token address to swap from\\n\\t * @param _output Token address to swap to\\n\\t * @param _amount Amount of tokens to swap\\n\\t * @param _minOut Minimum amount of token to mint\\n\\t * @param _getId ID to retrieve amt\\n\\t * @param _setId ID stores the amount of tokens swapped\\n\\t * @return _eventName Event name\\n\\t * @return _eventParam Event parameters\\n\\t */\\n\\n\\tfunction swap(\\n\\t\\taddress _input,\\n\\t\\taddress _output,\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _minOut,\\n\\t\\tuint256 _getId,\\n\\t\\tuint256 _setId\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (string memory _eventName, bytes memory _eventParam)\\n\\t{\\n\\t\\tuint256 amount = getUint(_getId, _amount);\\n\\t\\tamount = amount == uint256(-1)\\n\\t\\t\\t? TokenInterface(_input).balanceOf(address(this))\\n\\t\\t\\t: amount;\\n\\t\\tapprove(TokenInterface(_input), mUsdToken, amount);\\n\\t\\tuint256 amountSwapped;\\n\\n\\t\\t// Check the assets and swap accordingly\\n\\t\\tif (_output == mUsdToken) {\\n\\t\\t\\t// bAsset to mUSD =\\u003e mint\\n\\t\\t\\tamountSwapped = IMasset(mUsdToken).mint(\\n\\t\\t\\t\\t_input,\\n\\t\\t\\t\\tamount,\\n\\t\\t\\t\\t_minOut,\\n\\t\\t\\t\\taddress(this)\\n\\t\\t\\t);\\n\\t\\t} else if (_input == mUsdToken) {\\n\\t\\t\\t// mUSD to bAsset =\\u003e redeem\\n\\t\\t\\tamountSwapped = IMasset(mUsdToken).redeem(\\n\\t\\t\\t\\t_output,\\n\\t\\t\\t\\tamount,\\n\\t\\t\\t\\t_minOut,\\n\\t\\t\\t\\taddress(this)\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\t// bAsset to another bAsset =\\u003e swap\\n\\t\\t\\tamountSwapped = IMasset(mUsdToken).swap(\\n\\t\\t\\t\\t_input,\\n\\t\\t\\t\\t_output,\\n\\t\\t\\t\\tamount,\\n\\t\\t\\t\\t_minOut,\\n\\t\\t\\t\\taddress(this)\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tsetUint(_setId, amountSwapped);\\n\\t\\t_eventName = \\\"LogSwap(address,address,uint256,uint256)\\\";\\n\\t\\t_eventParam = abi.encode(_input, _output, amount, amountSwapped);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Swap tokens via Feeder Pool\\n\\t * @notice Swaps tokens via Feeder Pool\\n\\t * @param _input Token address to swap from\\n\\t * @param _output Token address to swap to\\n\\t * @param _amount Amount of tokens to swap\\n\\t * @param _minOut Minimum amount of token to mint\\n\\t * @param _path Feeder Pool address to use\\n\\t * @param _getId ID to retrieve amt\\n\\t * @param _setId ID stores the amount of tokens swapped\\n\\t * @return _eventName Event name\\n\\t * @return _eventParam Event parameters\\n\\t */\\n\\n\\tfunction swapViaFeeder(\\n\\t\\taddress _input,\\n\\t\\taddress _output,\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _minOut,\\n\\t\\taddress _path,\\n\\t\\tuint256 _getId,\\n\\t\\tuint256 _setId\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (string memory _eventName, bytes memory _eventParam)\\n\\t{\\n\\t\\tuint256 amountSwapped;\\n\\t\\tuint256 amount = getUint(_getId, _amount);\\n\\t\\tamount = amount == uint256(-1)\\n\\t\\t\\t? TokenInterface(_input).balanceOf(address(this))\\n\\t\\t\\t: amount;\\n\\n\\t\\tapprove(TokenInterface(_input), _path, amount);\\n\\n\\t\\t// swaps fAsset to mUSD via Feeder Pool\\n\\t\\t// swaps mUSD to fAsset via Feeder Pool\\n\\t\\tamountSwapped = IFeederPool(_path).swap(\\n\\t\\t\\t_input,\\n\\t\\t\\t_output,\\n\\t\\t\\tamount,\\n\\t\\t\\t_minOut,\\n\\t\\t\\taddress(this)\\n\\t\\t);\\n\\n\\t\\tsetUint(_setId, amountSwapped);\\n\\n\\t\\t_eventName = \\\"LogSwap(address,address,uint256,uint256)\\\";\\n\\t\\t_eventParam = abi.encode(_input, _output, amount, amountSwapped);\\n\\t}\\n}\\n\\ncontract ConnectV2mStable is mStableResolver {\\n\\tstring public constant name = \\\"mStable-v1.0\\\";\\n}\\n\"},\"math.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\ncontract DSMath {\\n\\tuint256 constant WAD = 10**18;\\n\\tuint256 constant RAY = 10**27;\\n\\n\\tfunction add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = SafeMath.add(x, y);\\n\\t}\\n\\n\\tfunction sub(uint256 x, uint256 y)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\tvirtual\\n\\t\\treturns (uint256 z)\\n\\t{\\n\\t\\tz = SafeMath.sub(x, y);\\n\\t}\\n\\n\\tfunction mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = SafeMath.mul(x, y);\\n\\t}\\n\\n\\tfunction div(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = SafeMath.div(x, y);\\n\\t}\\n\\n\\tfunction wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = SafeMath.add(SafeMath.mul(x, y), WAD / 2) / WAD;\\n\\t}\\n\\n\\tfunction wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = SafeMath.add(SafeMath.mul(x, WAD), y / 2) / y;\\n\\t}\\n\\n\\tfunction rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = SafeMath.add(SafeMath.mul(x, RAY), y / 2) / y;\\n\\t}\\n\\n\\tfunction rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = SafeMath.add(SafeMath.mul(x, y), RAY / 2) / RAY;\\n\\t}\\n\\n\\tfunction toInt(uint256 x) internal pure returns (int256 y) {\\n\\t\\ty = int256(x);\\n\\t\\trequire(y \\u003e= 0, \\\"int-overflow\\\");\\n\\t}\\n\\n\\tfunction toRad(uint256 wad) internal pure returns (uint256 rad) {\\n\\t\\trad = mul(wad, 10**27);\\n\\t}\\n}\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n\\t/**\\n\\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryAdd(uint256 a, uint256 b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bool, uint256)\\n\\t{\\n\\t\\tuint256 c = a + b;\\n\\t\\tif (c \\u003c a) return (false, 0);\\n\\t\\treturn (true, c);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction trySub(uint256 a, uint256 b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bool, uint256)\\n\\t{\\n\\t\\tif (b \\u003e a) return (false, 0);\\n\\t\\treturn (true, a - b);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryMul(uint256 a, uint256 b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bool, uint256)\\n\\t{\\n\\t\\t// Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n\\t\\t// benefit is lost if \\u0027b\\u0027 is also tested.\\n\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n\\t\\tif (a == 0) return (true, 0);\\n\\t\\tuint256 c = a * b;\\n\\t\\tif (c / a != b) return (false, 0);\\n\\t\\treturn (true, c);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryDiv(uint256 a, uint256 b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bool, uint256)\\n\\t{\\n\\t\\tif (b == 0) return (false, 0);\\n\\t\\treturn (true, a / b);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryMod(uint256 a, uint256 b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bool, uint256)\\n\\t{\\n\\t\\tif (b == 0) return (false, 0);\\n\\t\\treturn (true, a % b);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the addition of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `+` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Addition cannot overflow.\\n\\t */\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\trequire(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `*` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Multiplication cannot overflow.\\n\\t */\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tif (a == 0) return 0;\\n\\t\\tuint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers, reverting on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * reverting when dividing by zero.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n\\t\\treturn a % b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\n\\t * message unnecessarily. For custom revert reasons use {trySub}.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003c= a, errorMessage);\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\n\\t * message unnecessarily. For custom revert reasons use {tryDiv}.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, errorMessage);\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * reverting with custom message when dividing by zero.\\n\\t *\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\n\\t * message unnecessarily. For custom revert reasons use {tryMod}.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, errorMessage);\\n\\t\\treturn a % b;\\n\\t}\\n}\\n\"},\"stores.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport { MemoryInterface, InstaMapping } from \\\"./interfaces.sol\\\";\\n\\nabstract contract Stores {\\n\\t/**\\n\\t * @dev Return ethereum address\\n\\t */\\n\\taddress internal constant ethAddr =\\n\\t\\t0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n\\t/**\\n\\t * @dev Return Wrapped ETH address\\n\\t */\\n\\taddress internal constant wethAddr =\\n\\t\\t0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n\\t/**\\n\\t * @dev Return memory variable address\\n\\t */\\n\\tMemoryInterface internal constant instaMemory =\\n\\t\\tMemoryInterface(0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F);\\n\\n\\t/**\\n\\t * @dev Return InstaDApp Mapping Addresses\\n\\t */\\n\\tInstaMapping internal constant instaMapping =\\n\\t\\tInstaMapping(0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88);\\n\\n\\t/**\\n\\t * @dev Get Uint value from InstaMemory Contract.\\n\\t */\\n\\tfunction getUint(uint256 getId, uint256 val)\\n\\t\\tinternal\\n\\t\\treturns (uint256 returnVal)\\n\\t{\\n\\t\\treturnVal = getId == 0 ? val : instaMemory.getUint(getId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Set Uint value in InstaMemory Contract.\\n\\t */\\n\\tfunction setUint(uint256 setId, uint256 val) internal virtual {\\n\\t\\tif (setId != 0) instaMemory.setUint(setId, val);\\n\\t}\\n}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"path\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"LogSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"path\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_setId\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_eventName\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_eventParam\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_stake\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_setId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_getId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_eventName\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_eventParam\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_path\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_stake\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_setId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_getId\",\"type\":\"uint256\"}],\"name\":\"depositViaSwap\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_eventName\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_eventParam\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_setId\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_eventName\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_eventParam\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_path\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_setId\",\"type\":\"uint256\"}],\"name\":\"swapViaFeeder\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_eventName\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_eventParam\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_credits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_unstake\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_setId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_eventName\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_eventParam\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_credits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_path\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_unstake\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_setId\",\"type\":\"uint256\"}],\"name\":\"withdrawViaSwap\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_eventName\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_eventParam\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "ConnectV2mStable", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://65f81cd8b2b79da5c6595fc0fdc2ddfbab1b2b0314382633307d36e95a8dc3b2"}]}