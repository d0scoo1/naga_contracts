{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/legacy-upgraded/imusd-mainnet-22.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\n/* is IERC20 */\\ninterface IERC4626Vault {\\n    /// @notice The address of the underlying token used for the Vault uses for accounting, depositing, and withdrawing\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /// @notice Total amount of the underlying asset that is \u201cmanaged\u201d by Vault\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @notice The amount of shares that the Vault would exchange for the amount of assets provided, in an ideal scenario where all the conditions are met.\\n     * @param assets The amount of underlying assets to be convert to vault shares.\\n     * @return shares The amount of vault shares converted from the underlying assets.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @notice The amount of assets that the Vault would exchange for the amount of shares provided, in an ideal scenario where all the conditions are met.\\n     * @param shares The amount of vault shares to be converted to the underlying assets.\\n     * @return assets The amount of underlying assets converted from the vault shares.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @notice The maximum number of underlying assets that caller can deposit.\\n     * @param caller Account that the assets will be transferred from.\\n     * @return maxAssets The maximum amount of underlying assets the caller can deposit.\\n     */\\n    function maxDeposit(address caller) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.\\n     * @param assets The amount of underlying assets to be transferred.\\n     * @return shares The amount of vault shares that will be minted.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @notice Mint vault shares to receiver by transferring exact amount of underlying asset tokens from the caller.\\n     * @param assets The amount of underlying assets to be transferred to the vault.\\n     * @param receiver The account that the vault shares will be minted to.\\n     * @return shares The amount of vault shares that were minted.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @notice The maximum number of vault shares that caller can mint.\\n     * @param caller Account that the underlying assets will be transferred from.\\n     * @return maxShares The maximum amount of vault shares the caller can mint.\\n     */\\n    function maxMint(address caller) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.\\n     * @param shares The amount of vault shares to be minted.\\n     * @return assets The amount of underlying assests that will be transferred from the caller.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @notice Mint exact amount of vault shares to the receiver by transferring enough underlying asset tokens from the caller.\\n     * @param shares The amount of vault shares to be minted.\\n     * @param receiver The account the vault shares will be minted to.\\n     * @return assets The amount of underlying assets that were transferred from the caller.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @notice The maximum number of underlying assets that owner can withdraw.\\n     * @param owner Account that owns the vault shares.\\n     * @return maxAssets The maximum amount of underlying assets the owner can withdraw.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.\\n     * @param assets The amount of underlying assets to be withdrawn.\\n     * @return shares The amount of vault shares that will be burnt.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @notice Burns enough vault shares from owner and transfers the exact amount of underlying asset tokens to the receiver.\\n     * @param assets The amount of underlying assets to be withdrawn from the vault.\\n     * @param receiver The account that the underlying assets will be transferred to.\\n     * @param owner Account that owns the vault shares to be burnt.\\n     * @return shares The amount of vault shares that were burnt.\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares);\\n\\n    /**\\n     * @notice The maximum number of shares an owner can redeem for underlying assets.\\n     * @param owner Account that owns the vault shares.\\n     * @return maxShares The maximum amount of shares the owner can redeem.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.\\n     * @param shares The amount of vault shares to be burnt.\\n     * @return assets The amount of underlying assests that will transferred to the receiver.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @notice Burns exact amount of vault shares from owner and transfers the underlying asset tokens to the receiver.\\n     * @param shares The amount of vault shares to be burnt.\\n     * @param receiver The account the underlying assets will be transferred to.\\n     * @param owner The account that owns the vault shares to be burnt.\\n     * @return assets The amount of underlying assets that were transferred to the receiver.\\n     */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                Events\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Emitted when caller has exchanged assets for shares, and transferred those shares to owner.\\n     *\\n     * Note It must be emitted when tokens are deposited into the Vault in ERC4626.mint or ERC4626.deposit methods.\\n     *\\n     */\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n    /**\\n     * @dev Emitted when sender has exchanged shares for assets, and transferred those assets to receiver.\\n     *\\n     * Note It must be emitted when shares are withdrawn from the Vault in ERC4626.redeem or ERC4626.withdraw methods.\\n     *\\n     */\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n}\\n\\ninterface IUnwrapper {\\n    // @dev Get bAssetOut status\\n    function getIsBassetOut(\\n        address _masset,\\n        bool _inputIsCredit,\\n        address _output\\n    ) external view returns (bool isBassetOut);\\n\\n    /// @dev Estimate output\\n    function getUnwrapOutput(\\n        bool _isBassetOut,\\n        address _router,\\n        address _input,\\n        bool _inputIsCredit,\\n        address _output,\\n        uint256 _amount\\n    ) external view returns (uint256 output);\\n\\n    /// @dev Unwrap and send\\n    function unwrapAndSend(\\n        bool _isBassetOut,\\n        address _router,\\n        address _input,\\n        address _output,\\n        uint256 _amount,\\n        uint256 _minAmountOut,\\n        address _beneficiary\\n    ) external returns (uint256 outputQuantity);\\n}\\n\\ninterface ISavingsManager {\\n    /** @dev Admin privs */\\n    function distributeUnallocatedInterest(address _mAsset) external;\\n\\n    /** @dev Liquidator */\\n    function depositLiquidation(address _mAsset, uint256 _liquidation) external;\\n\\n    /** @dev Liquidator */\\n    function collectAndStreamInterest(address _mAsset) external;\\n\\n    /** @dev Public privs */\\n    function collectAndDistributeInterest(address _mAsset) external;\\n}\\n\\ninterface ISavingsContractV1 {\\n    function depositInterest(uint256 _amount) external;\\n\\n    function depositSavings(uint256 _amount) external returns (uint256 creditsIssued);\\n\\n    function redeem(uint256 _amount) external returns (uint256 massetReturned);\\n\\n    function exchangeRate() external view returns (uint256);\\n\\n    function creditBalances(address) external view returns (uint256);\\n}\\n\\ninterface ISavingsContractV4 {\\n    // DEPRECATED but still backwards compatible\\n    function redeem(uint256 _amount) external returns (uint256 massetReturned);\\n\\n    function creditBalances(address) external view returns (uint256); // V1 & V2 (use balanceOf)\\n\\n    // --------------------------------------------\\n\\n    function depositInterest(uint256 _amount) external; // V1 & V2\\n\\n    function depositSavings(uint256 _amount) external returns (uint256 creditsIssued); // V1 & V2\\n\\n    function depositSavings(uint256 _amount, address _beneficiary)\\n        external\\n        returns (uint256 creditsIssued); // V2\\n\\n    function redeemCredits(uint256 _amount) external returns (uint256 underlyingReturned); // V2\\n\\n    function redeemUnderlying(uint256 _amount) external returns (uint256 creditsBurned); // V2\\n\\n    function exchangeRate() external view returns (uint256); // V1 & V2\\n\\n    function balanceOfUnderlying(address _user) external view returns (uint256 balance); // V2\\n\\n    function underlyingToCredits(uint256 _credits) external view returns (uint256 underlying); // V2\\n\\n    function creditsToUnderlying(uint256 _underlying) external view returns (uint256 credits); // V2\\n\\n    // --------------------------------------------\\n\\n    function redeemAndUnwrap(\\n        uint256 _amount,\\n        bool _isCreditAmt,\\n        uint256 _minAmountOut,\\n        address _output,\\n        address _beneficiary,\\n        address _router,\\n        bool _isBassetOut\\n    )\\n        external\\n        returns (\\n            uint256 creditsBurned,\\n            uint256 massetRedeemed,\\n            uint256 outputQuantity\\n        );\\n\\n    function depositSavings(\\n        uint256 _underlying,\\n        address _beneficiary,\\n        address _referrer\\n    ) external returns (uint256 creditsIssued);\\n\\n    // -------------------------------------------- V4\\n    function deposit(\\n        uint256 assets,\\n        address receiver,\\n        address referrer\\n    ) external returns (uint256 shares);\\n\\n    function mint(\\n        uint256 shares,\\n        address receiver,\\n        address referrer\\n    ) external returns (uint256 assets);\\n}\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor() internal {}\\n\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(\\n                amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(\\n                subtractedValue,\\n                \\\"ERC20: decreased allowance below zero\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(\\n            account,\\n            _msgSender(),\\n            _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\")\\n        );\\n    }\\n}\\n\\ncontract InitializableERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\\n     */\\n    function _initialize(\\n        string memory nameArg,\\n        string memory symbolArg,\\n        uint8 decimalsArg\\n    ) internal {\\n        _name = nameArg;\\n        _symbol = symbolArg;\\n        _decimals = decimalsArg;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\\ncontract InitializableToken is ERC20, InitializableERC20Detailed {\\n    /**\\n     * @dev Initialization function for implementing contract\\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\\n     */\\n    function _initialize(string memory _nameArg, string memory _symbolArg) internal {\\n        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\\n    }\\n}\\n\\ncontract ModuleKeys {\\n    // Governance\\n    // ===========\\n    // keccak256(\\\"Governance\\\");\\n    bytes32 internal constant KEY_GOVERNANCE =\\n        0x9409903de1e6fd852dfc61c9dacb48196c48535b60e25abf92acc92dd689078d;\\n    //keccak256(\\\"Staking\\\");\\n    bytes32 internal constant KEY_STAKING =\\n        0x1df41cd916959d1163dc8f0671a666ea8a3e434c13e40faef527133b5d167034;\\n    //keccak256(\\\"ProxyAdmin\\\");\\n    bytes32 internal constant KEY_PROXY_ADMIN =\\n        0x96ed0203eb7e975a4cbcaa23951943fa35c5d8288117d50c12b3d48b0fab48d1;\\n\\n    // mStable\\n    // =======\\n    // keccak256(\\\"OracleHub\\\");\\n    bytes32 internal constant KEY_ORACLE_HUB =\\n        0x8ae3a082c61a7379e2280f3356a5131507d9829d222d853bfa7c9fe1200dd040;\\n    // keccak256(\\\"Manager\\\");\\n    bytes32 internal constant KEY_MANAGER =\\n        0x6d439300980e333f0256d64be2c9f67e86f4493ce25f82498d6db7f4be3d9e6f;\\n    //keccak256(\\\"Recollateraliser\\\");\\n    bytes32 internal constant KEY_RECOLLATERALISER =\\n        0x39e3ed1fc335ce346a8cbe3e64dd525cf22b37f1e2104a755e761c3c1eb4734f;\\n    //keccak256(\\\"MetaToken\\\");\\n    bytes32 internal constant KEY_META_TOKEN =\\n        0xea7469b14936af748ee93c53b2fe510b9928edbdccac3963321efca7eb1a57a2;\\n    // keccak256(\\\"SavingsManager\\\");\\n    bytes32 internal constant KEY_SAVINGS_MANAGER =\\n        0x12fe936c77a1e196473c4314f3bed8eeac1d757b319abb85bdda70df35511bf1;\\n    // keccak256(\\\"Liquidator\\\");\\n    bytes32 internal constant KEY_LIQUIDATOR =\\n        0x1e9cb14d7560734a61fa5ff9273953e971ff3cd9283c03d8346e3264617933d4;\\n}\\n\\ninterface INexus {\\n    function governor() external view returns (address);\\n\\n    function getModule(bytes32 key) external view returns (address);\\n\\n    function proposeModule(bytes32 _key, address _addr) external;\\n\\n    function cancelProposedModule(bytes32 _key) external;\\n\\n    function acceptProposedModule(bytes32 _key) external;\\n\\n    function acceptProposedModules(bytes32[] calldata _keys) external;\\n\\n    function requestLockModule(bytes32 _key) external;\\n\\n    function cancelLockModule(bytes32 _key) external;\\n\\n    function lockModule(bytes32 _key) external;\\n}\\n\\ncontract InitializableModule2 is ModuleKeys {\\n    INexus public constant nexus = INexus(0xAFcE80b19A8cE13DEc0739a1aaB7A028d6845Eb3);\\n\\n    /**\\n     * @dev Modifier to allow function calls only from the Governor.\\n     */\\n    modifier onlyGovernor() {\\n        require(msg.sender == _governor(), \\\"Only governor can execute\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to allow function calls only from the Governance.\\n     *      Governance is either Governor address or Governance address.\\n     */\\n    modifier onlyGovernance() {\\n        require(\\n            msg.sender == _governor() || msg.sender == _governance(),\\n            \\\"Only governance can execute\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to allow function calls only from the ProxyAdmin.\\n     */\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"Only ProxyAdmin can execute\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to allow function calls only from the Manager.\\n     */\\n    modifier onlyManager() {\\n        require(msg.sender == _manager(), \\\"Only manager can execute\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns Governor address from the Nexus\\n     * @return Address of Governor Contract\\n     */\\n    function _governor() internal view returns (address) {\\n        return nexus.governor();\\n    }\\n\\n    /**\\n     * @dev Returns Governance Module address from the Nexus\\n     * @return Address of the Governance (Phase 2)\\n     */\\n    function _governance() internal view returns (address) {\\n        return nexus.getModule(KEY_GOVERNANCE);\\n    }\\n\\n    /**\\n     * @dev Return Staking Module address from the Nexus\\n     * @return Address of the Staking Module contract\\n     */\\n    function _staking() internal view returns (address) {\\n        return nexus.getModule(KEY_STAKING);\\n    }\\n\\n    /**\\n     * @dev Return ProxyAdmin Module address from the Nexus\\n     * @return Address of the ProxyAdmin Module contract\\n     */\\n    function _proxyAdmin() internal view returns (address) {\\n        return nexus.getModule(KEY_PROXY_ADMIN);\\n    }\\n\\n    /**\\n     * @dev Return MetaToken Module address from the Nexus\\n     * @return Address of the MetaToken Module contract\\n     */\\n    function _metaToken() internal view returns (address) {\\n        return nexus.getModule(KEY_META_TOKEN);\\n    }\\n\\n    /**\\n     * @dev Return OracleHub Module address from the Nexus\\n     * @return Address of the OracleHub Module contract\\n     */\\n    function _oracleHub() internal view returns (address) {\\n        return nexus.getModule(KEY_ORACLE_HUB);\\n    }\\n\\n    /**\\n     * @dev Return Manager Module address from the Nexus\\n     * @return Address of the Manager Module contract\\n     */\\n    function _manager() internal view returns (address) {\\n        return nexus.getModule(KEY_MANAGER);\\n    }\\n\\n    /**\\n     * @dev Return SavingsManager Module address from the Nexus\\n     * @return Address of the SavingsManager Module contract\\n     */\\n    function _savingsManager() internal view returns (address) {\\n        return nexus.getModule(KEY_SAVINGS_MANAGER);\\n    }\\n\\n    /**\\n     * @dev Return Recollateraliser Module address from the Nexus\\n     * @return  Address of the Recollateraliser Module contract (Phase 2)\\n     */\\n    function _recollateraliser() internal view returns (address) {\\n        return nexus.getModule(KEY_RECOLLATERALISER);\\n    }\\n}\\n\\ninterface IConnector {\\n    /**\\n     * @notice Deposits the mAsset into the connector\\n     * @param _amount Units of mAsset to receive and deposit\\n     */\\n    function deposit(uint256 _amount) external;\\n\\n    /**\\n     * @notice Withdraws a specific amount of mAsset from the connector\\n     * @param _amount Units of mAsset to withdraw\\n     */\\n    function withdraw(uint256 _amount) external;\\n\\n    /**\\n     * @notice Withdraws all mAsset from the connector\\n     */\\n    function withdrawAll() external;\\n\\n    /**\\n     * @notice Returns the available balance in the connector. In connections\\n     * where there is likely to be an initial dip in value due to conservative\\n     * exchange rates (e.g. with Curves `get_virtual_price`), it should return\\n     * max(deposited, balance) to avoid temporary negative yield. Any negative yield\\n     * should be corrected during a withdrawal or over time.\\n     * @return Balance of mAsset in the connector\\n     */\\n    function checkBalance() external view returns (uint256);\\n}\\n\\ncontract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private initializing;\\n\\n    /**\\n     * @dev Modifier to use in the initializer function of a contract.\\n     */\\n    modifier initializer() {\\n        require(\\n            initializing || isConstructor() || !initialized,\\n            \\\"Contract instance has already been initialized\\\"\\n        );\\n\\n        bool isTopLevelCall = !initializing;\\n        if (isTopLevelCall) {\\n            initializing = true;\\n            initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        address self = address(this);\\n        uint256 cs;\\n        assembly {\\n            cs := extcodesize(self)\\n        }\\n        return cs == 0;\\n    }\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\\nlibrary StableMath {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Scaling unit for use in specific calculations,\\n     * where 1 * 10**18, or 1e18 represents a unit '1'\\n     */\\n    uint256 private constant FULL_SCALE = 1e18;\\n\\n    /**\\n     * @notice Token Ratios are used when converting between units of bAsset, mAsset and MTA\\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\\n     * @dev bAsset ratio unit for use in exact calculations,\\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\\n     */\\n    uint256 private constant RATIO_SCALE = 1e8;\\n\\n    /**\\n     * @dev Provides an interface to the scaling unit\\n     * @return Scaling unit (1e18 or 1 * 10**18)\\n     */\\n    function getFullScale() internal pure returns (uint256) {\\n        return FULL_SCALE;\\n    }\\n\\n    /**\\n     * @dev Provides an interface to the ratio unit\\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\\n     */\\n    function getRatioScale() internal pure returns (uint256) {\\n        return RATIO_SCALE;\\n    }\\n\\n    /**\\n     * @dev Scales a given integer to the power of the full scale.\\n     * @param x   Simple uint256 to scale\\n     * @return    Scaled value a to an exact number\\n     */\\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\\n        return x.mul(FULL_SCALE);\\n    }\\n\\n    /***************************************\\n              PRECISE ARITHMETIC\\n    ****************************************/\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the full scale\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit\\n     */\\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulTruncateScale(x, y, FULL_SCALE);\\n    }\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @param scale Scale unit\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit\\n     */\\n    function mulTruncateScale(\\n        uint256 x,\\n        uint256 y,\\n        uint256 scale\\n    ) internal pure returns (uint256) {\\n        // e.g. assume scale = fullScale\\n        // z = 10e18 * 9e17 = 9e36\\n        uint256 z = x.mul(y);\\n        // return 9e38 / 1e18 = 9e18\\n        return z.div(scale);\\n    }\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit, rounded up to the closest base unit.\\n     */\\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // e.g. 8e17 * 17268172638 = 138145381104e17\\n        uint256 scaled = x.mul(y);\\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\\n        return ceil.div(FULL_SCALE);\\n    }\\n\\n    /**\\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\\n     * @param x     Left hand input to division\\n     * @param y     Right hand input to division\\n     * @return      Result after multiplying the left operand by the scale, and\\n     *              executing the division on the right hand input.\\n     */\\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // e.g. 8e18 * 1e18 = 8e36\\n        uint256 z = x.mul(FULL_SCALE);\\n        // e.g. 8e36 / 10e18 = 8e17\\n        return z.div(y);\\n    }\\n\\n    /***************************************\\n                  RATIO FUNCS\\n    ****************************************/\\n\\n    /**\\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\\n     *      i.e. How much mAsset is this bAsset worth?\\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\\n     * @param ratio bAsset ratio\\n     * @return      Result after multiplying the two inputs and then dividing by the ratio scale\\n     */\\n    function mulRatioTruncate(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\\n    }\\n\\n    /**\\n     * @dev Multiplies and truncates a token ratio, rounding up the result\\n     *      i.e. How much mAsset is this bAsset worth?\\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\\n     * @param ratio bAsset ratio\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              ratio scale, rounded up to the closest base unit.\\n     */\\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio) internal pure returns (uint256) {\\n        // e.g. How much mAsset should I burn for this bAsset (x)?\\n        // 1e18 * 1e8 = 1e26\\n        uint256 scaled = x.mul(ratio);\\n        // 1e26 + 9.99e7 = 100..00.999e8\\n        uint256 ceil = scaled.add(RATIO_SCALE.sub(1));\\n        // return 100..00.999e8 / 1e8 = 1e18\\n        return ceil.div(RATIO_SCALE);\\n    }\\n\\n    /**\\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\\n     *      i.e. How much bAsset is this mAsset worth?\\n     * @param x     Left hand operand in division\\n     * @param ratio bAsset ratio\\n     * @return      Result after multiplying the left operand by the scale, and\\n     *              executing the division on the right hand input.\\n     */\\n    function divRatioPrecisely(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\\n        // e.g. 1e14 * 1e8 = 1e22\\n        uint256 y = x.mul(RATIO_SCALE);\\n        // return 1e22 / 1e12 = 1e10\\n        return y.div(ratio);\\n    }\\n\\n    /***************************************\\n                    HELPERS\\n    ****************************************/\\n\\n    /**\\n     * @dev Calculates minimum of two numbers\\n     * @param x     Left hand input\\n     * @param y     Right hand input\\n     * @return      Minimum of the two inputs\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? y : x;\\n    }\\n\\n    /**\\n     * @dev Calculated maximum of two numbers\\n     * @param x     Left hand input\\n     * @param y     Right hand input\\n     * @return      Maximum of the two inputs\\n     */\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? x : y;\\n    }\\n\\n    /**\\n     * @dev Clamps a value to an upper bound\\n     * @param x           Left hand input\\n     * @param upperBound  Maximum possible value to return\\n     * @return            Input x clamped to a maximum value, upperBound\\n     */\\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\\n        return x > upperBound ? upperBound : x;\\n    }\\n}\\n\\n/**\\n * @title   SavingsContract\\n * @author  Stability Labs Pty. Ltd.\\n * @notice  Savings contract uses the ever increasing \\\"exchangeRate\\\" to increase\\n *          the value of the Savers \\\"credits\\\" (ERC20) relative to the amount of additional\\n *          underlying collateral that has been deposited into this contract (\\\"interest\\\")\\n * @dev     VERSION: 2.1\\n *          DATE:    2021-11-25\\n */\\ncontract SavingsContract_imusd_mainnet_22 is\\n    ISavingsContractV1,\\n    ISavingsContractV4,\\n    IERC4626Vault,\\n    Initializable,\\n    InitializableToken,\\n    InitializableModule2\\n{\\n    using SafeMath for uint256;\\n    using StableMath for uint256;\\n\\n    // Core events for depositing and withdrawing\\n    event ExchangeRateUpdated(uint256 newExchangeRate, uint256 interestCollected);\\n    event SavingsDeposited(address indexed saver, uint256 savingsDeposited, uint256 creditsIssued);\\n    event CreditsRedeemed(\\n        address indexed redeemer,\\n        uint256 creditsRedeemed,\\n        uint256 savingsCredited\\n    );\\n\\n    event AutomaticInterestCollectionSwitched(bool automationEnabled);\\n\\n    // Connector poking\\n    event PokerUpdated(address poker);\\n\\n    event FractionUpdated(uint256 fraction);\\n    event ConnectorUpdated(address connector);\\n    event EmergencyUpdate();\\n\\n    event Poked(uint256 oldBalance, uint256 newBalance, uint256 interestDetected);\\n    event PokedRaw();\\n\\n    // Tracking events\\n    event Referral(address indexed referrer, address beneficiary, uint256 amount);\\n\\n    // Rate between 'savings credits' and underlying\\n    // e.g. 1 credit (1e17) mulTruncate(exchangeRate) = underlying, starts at 10:1\\n    // exchangeRate increases over time\\n    uint256 private constant startingRate = 1e17;\\n    uint256 public exchangeRate;\\n\\n    // Underlying asset is underlying\\n    IERC20 public constant underlying = IERC20(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\\n    bool private automateInterestCollection;\\n\\n    // Yield\\n    // Poker is responsible for depositing/withdrawing from connector\\n    address public poker;\\n    // Last time a poke was made\\n    uint256 public lastPoke;\\n    // Last known balance of the connector\\n    uint256 public lastBalance;\\n    // Fraction of capital assigned to the connector (100% = 1e18)\\n    uint256 public fraction;\\n    // Address of the current connector (all IConnectors are mStable validated)\\n    IConnector public connector;\\n    // How often do we allow pokes\\n    uint256 private constant POKE_CADENCE = 4 hours;\\n    // Max APY generated on the capital in the connector\\n    uint256 private constant MAX_APY = 4e18;\\n    uint256 private constant SECONDS_IN_YEAR = 365 days;\\n    // Proxy contract for easy redemption\\n    address public constant unwrapper = 0xc1443Cb9ce81915fB914C270d74B0D57D1c87be0;\\n    uint256 private constant MAX_INT256 = 2**256 - 1;\\n\\n    // Add these constants to bytecode at deploytime\\n    function initialize(\\n        address _poker,\\n        string calldata _nameArg,\\n        string calldata _symbolArg\\n    ) external initializer {\\n        InitializableToken._initialize(_nameArg, _symbolArg);\\n\\n        require(_poker != address(0), \\\"Invalid poker address\\\");\\n        poker = _poker;\\n\\n        fraction = 2e17;\\n        automateInterestCollection = true;\\n        exchangeRate = startingRate;\\n    }\\n\\n    /** @dev Only the savings managaer (pulled from Nexus) can execute this */\\n    modifier onlySavingsManager() {\\n        require(msg.sender == _savingsManager(), \\\"Only savings manager can execute\\\");\\n        _;\\n    }\\n\\n    /***************************************\\n                    VIEW - E\\n    ****************************************/\\n\\n    /**\\n     * @dev Returns the underlying balance of a given user\\n     * @param _user     Address of the user to check\\n     * @return balance  Units of underlying owned by the user\\n     */\\n    function balanceOfUnderlying(address _user) external view returns (uint256 balance) {\\n        (balance, ) = _creditsToUnderlying(balanceOf(_user));\\n    }\\n\\n    /**\\n     * @dev Converts a given underlying amount into credits\\n     * @param _underlying  Units of underlying\\n     * @return credits     Credit units (a.k.a imUSD)\\n     */\\n    function underlyingToCredits(uint256 _underlying) external view returns (uint256 credits) {\\n        (credits, ) = _underlyingToCredits(_underlying);\\n    }\\n\\n    /**\\n     * @dev Converts a given credit amount into underlying\\n     * @param _credits  Units of credits\\n     * @return amount   Corresponding underlying amount\\n     */\\n    function creditsToUnderlying(uint256 _credits) external view returns (uint256 amount) {\\n        (amount, ) = _creditsToUnderlying(_credits);\\n    }\\n\\n    // Deprecated in favour of `balanceOf(address)`\\n    // Maintained for backwards compatibility\\n    // Returns the credit balance of a given user\\n    function creditBalances(address _user) external view returns (uint256) {\\n        return balanceOf(_user);\\n    }\\n\\n    /***************************************\\n                    INTEREST\\n    ****************************************/\\n\\n    /**\\n     * @dev Deposit interest (add to savings) and update exchange rate of contract.\\n     *      Exchange rate is calculated as the ratio between new savings q and credits:\\n     *                    exchange rate = savings / credits\\n     *\\n     * @param _amount   Units of underlying to add to the savings vault\\n     */\\n    function depositInterest(uint256 _amount) external onlySavingsManager {\\n        require(_amount > 0, \\\"Must deposit something\\\");\\n\\n        // Transfer the interest from sender to here\\n        require(underlying.transferFrom(msg.sender, address(this), _amount), \\\"Must receive tokens\\\");\\n\\n        // Calc new exchange rate, protect against initialisation case\\n        uint256 totalCredits = totalSupply();\\n        if (totalCredits > 0) {\\n            // new exchange rate is relationship between _totalCredits & totalSavings\\n            // _totalCredits * exchangeRate = totalSavings\\n            // exchangeRate = totalSavings/_totalCredits\\n            (uint256 totalCollat, ) = _creditsToUnderlying(totalCredits);\\n            uint256 newExchangeRate = _calcExchangeRate(totalCollat.add(_amount), totalCredits);\\n            exchangeRate = newExchangeRate;\\n\\n            emit ExchangeRateUpdated(newExchangeRate, _amount);\\n        }\\n    }\\n\\n    /** @dev Enable or disable the automation of fee collection during deposit process */\\n    function automateInterestCollectionFlag(bool _enabled) external onlyGovernor {\\n        automateInterestCollection = _enabled;\\n        emit AutomaticInterestCollectionSwitched(_enabled);\\n    }\\n\\n    /***************************************\\n                    DEPOSIT\\n    ****************************************/\\n\\n    /**\\n     * @dev During a migration period, allow savers to deposit underlying here before the interest has been redirected\\n     * @param _underlying      Units of underlying to deposit into savings vault\\n     * @param _beneficiary     Immediately transfer the imUSD token to this beneficiary address\\n     * @return creditsIssued   Units of credits (imUSD) issued\\n     */\\n    function preDeposit(uint256 _underlying, address _beneficiary)\\n        external\\n        returns (uint256 creditsIssued)\\n    {\\n        require(exchangeRate == startingRate, \\\"Can only use this method before streaming begins\\\");\\n        return _deposit(_underlying, _beneficiary, false);\\n    }\\n\\n    /**\\n     * @dev Deposit the senders savings to the vault, and credit them internally with \\\"credits\\\".\\n     *      Credit amount is calculated as a ratio of deposit amount and exchange rate:\\n     *                    credits = underlying / exchangeRate\\n     *      We will first update the internal exchange rate by collecting any interest generated on the underlying.\\n     * @param _underlying      Units of underlying to deposit into savings vault\\n     * @return creditsIssued   Units of credits (imUSD) issued\\n     */\\n    function depositSavings(uint256 _underlying) external returns (uint256 creditsIssued) {\\n        return _deposit(_underlying, msg.sender, true);\\n    }\\n\\n    /**\\n     * @dev Deposit the senders savings to the vault, and credit them internally with \\\"credits\\\".\\n     *      Credit amount is calculated as a ratio of deposit amount and exchange rate:\\n     *                    credits = underlying / exchangeRate\\n     *      We will first update the internal exchange rate by collecting any interest generated on the underlying.\\n     * @param _underlying      Units of underlying to deposit into savings vault\\n     * @param _beneficiary     Immediately transfer the imUSD token to this beneficiary address\\n     * @return creditsIssued   Units of credits (imUSD) issued\\n     */\\n    function depositSavings(uint256 _underlying, address _beneficiary)\\n        external\\n        returns (uint256 creditsIssued)\\n    {\\n        return _deposit(_underlying, _beneficiary, true);\\n    }\\n\\n    /**\\n     * @dev Overloaded `depositSavings` method with an optional referrer address.\\n     * @param _underlying      Units of underlying to deposit into savings vault\\n     * @param _beneficiary     Immediately transfer the imUSD token to this beneficiary address\\n     * @param _referrer        Referrer address for this deposit\\n     * @return creditsIssued   Units of credits (imUSD) issued\\n     */\\n    function depositSavings(\\n        uint256 _underlying,\\n        address _beneficiary,\\n        address _referrer\\n    ) external returns (uint256 creditsIssued) {\\n        emit Referral(_referrer, _beneficiary, _underlying);\\n        return _deposit(_underlying, _beneficiary, true);\\n    }\\n\\n    /**\\n     * @dev Internally deposit the _underlying from the sender and credit the beneficiary with new imUSD\\n     */\\n    function _deposit(\\n        uint256 _underlying,\\n        address _beneficiary,\\n        bool _collectInterest\\n    ) internal returns (uint256 creditsIssued) {\\n        creditsIssued = _transferAndMint(_underlying, _beneficiary, _collectInterest);\\n    }\\n\\n    /***************************************\\n                    REDEEM\\n    ****************************************/\\n\\n    // Deprecated in favour of redeemCredits\\n    // Maintaining backwards compatibility, this fn minimics the old redeem fn, in which\\n    // credits are redeemed but the interest from the underlying is not collected.\\n    function redeem(uint256 _credits) external returns (uint256 massetReturned) {\\n        require(_credits > 0, \\\"Must withdraw something\\\");\\n\\n        (, uint256 payout) = _redeem(_credits, true, true);\\n\\n        // Collect recent interest generated by basket and update exchange rate\\n        if (automateInterestCollection) {\\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(underlying));\\n        }\\n\\n        return payout;\\n    }\\n\\n    /**\\n     * @dev Redeem specific number of the senders \\\"credits\\\" in exchange for underlying.\\n     *      Payout amount is calculated as a ratio of credits and exchange rate:\\n     *                    payout = credits * exchangeRate\\n     * @param _credits         Amount of credits to redeem\\n     * @return massetReturned  Units of underlying mAsset paid out\\n     */\\n    function redeemCredits(uint256 _credits) external returns (uint256 massetReturned) {\\n        require(_credits > 0, \\\"Must withdraw something\\\");\\n\\n        // Collect recent interest generated by basket and update exchange rate\\n        if (automateInterestCollection) {\\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(underlying));\\n        }\\n\\n        (, uint256 payout) = _redeem(_credits, true, true);\\n\\n        return payout;\\n    }\\n\\n    /**\\n     * @dev Redeem credits into a specific amount of underlying.\\n     *      Credits needed to burn is calculated using:\\n     *                    credits = underlying / exchangeRate\\n     * @param _underlying     Amount of underlying to redeem\\n     * @return creditsBurned  Units of credits burned from sender\\n     */\\n    function redeemUnderlying(uint256 _underlying) external returns (uint256 creditsBurned) {\\n        require(_underlying > 0, \\\"Must withdraw something\\\");\\n\\n        // Collect recent interest generated by basket and update exchange rate\\n        if (automateInterestCollection) {\\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(underlying));\\n        }\\n\\n        // Ensure that the payout was sufficient\\n        (uint256 credits, uint256 massetReturned) = _redeem(_underlying, false, true);\\n        require(massetReturned == _underlying, \\\"Invalid output\\\");\\n\\n        return credits;\\n    }\\n\\n    /**\\n     * @notice Redeem credits into a specific amount of underlying, unwrap\\n     *      into a selected output asset, and send to a beneficiary\\n     *      Credits needed to burn is calculated using:\\n     *                    credits = underlying / exchangeRate\\n     * @param _amount         Units to redeem (either underlying or credit amount).\\n     * @param _isCreditAmt    `true` if `amount` is in credits. eg imUSD. `false` if `amount` is in underlying. eg mUSD.\\n     * @param _minAmountOut   Minimum amount of `output` tokens to unwrap for. This is to the same decimal places as the `output` token.\\n     * @param _output         Asset to receive in exchange for the redeemed mAssets. This can be a bAsset or a fAsset. For example:\\n        - bAssets (USDC, DAI, sUSD or USDT) or fAssets (GUSD, BUSD, alUSD, FEI or RAI) for mainnet imUSD Vault.\\n        - bAssets (USDC, DAI or USDT) or fAsset FRAX for Polygon imUSD Vault.\\n        - bAssets (WBTC, sBTC or renBTC) or fAssets (HBTC or TBTCV2) for mainnet imBTC Vault.\\n     * @param _beneficiary    Address to send `output` tokens to.\\n     * @param _router         mAsset address if the output is a bAsset. Feeder Pool address if the output is a fAsset.\\n     * @param _isBassetOut    `true` if `output` is a bAsset. `false` if `output` is a fAsset.\\n     * @return creditsBurned  Units of credits burned from sender. eg imUSD or imBTC.\\n     * @return massetReturned Units of the underlying mAssets that were redeemed or swapped for the output tokens. eg mUSD or mBTC.\\n     * @return outputQuantity Units of `output` tokens sent to the beneficiary.\\n     */\\n    function redeemAndUnwrap(\\n        uint256 _amount,\\n        bool _isCreditAmt,\\n        uint256 _minAmountOut,\\n        address _output,\\n        address _beneficiary,\\n        address _router,\\n        bool _isBassetOut\\n    )\\n        external\\n        returns (\\n            uint256 creditsBurned,\\n            uint256 massetReturned,\\n            uint256 outputQuantity\\n        )\\n    {\\n        require(_amount > 0, \\\"Must withdraw something\\\");\\n        require(_output != address(0), \\\"Output address is zero\\\");\\n        require(_beneficiary != address(0), \\\"Beneficiary address is zero\\\");\\n        require(_router != address(0), \\\"Router address is zero\\\");\\n\\n        // Collect recent interest generated by basket and update exchange rate\\n        if (automateInterestCollection) {\\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(underlying));\\n        }\\n\\n        // Ensure that the payout was sufficient\\n        (creditsBurned, massetReturned) = _redeem(_amount, _isCreditAmt, false);\\n        require(\\n            _isCreditAmt ? creditsBurned == _amount : massetReturned == _amount,\\n            \\\"Invalid output\\\"\\n        );\\n\\n        // Approve wrapper to spend contract's underlying; just for this tx\\n        underlying.approve(unwrapper, massetReturned);\\n\\n        // Unwrap the underlying into `output` and transfer to `beneficiary`\\n        outputQuantity = IUnwrapper(unwrapper).unwrapAndSend(\\n            _isBassetOut,\\n            _router,\\n            address(underlying),\\n            _output,\\n            massetReturned,\\n            _minAmountOut,\\n            _beneficiary\\n        );\\n    }\\n\\n    /**\\n     * @dev Internally burn the credits and send the underlying to msg.sender\\n     */\\n    function _redeem(\\n        uint256 _amt,\\n        bool _isCreditAmt,\\n        bool _transferUnderlying\\n    ) internal returns (uint256 creditsBurned, uint256 massetReturned) {\\n        // Centralise credit <> underlying calcs and minimise SLOAD count\\n        uint256 credits_;\\n        uint256 underlying_;\\n        uint256 exchangeRate_;\\n        // If the input is a credit amt, then calculate underlying payout and cache the exchangeRate\\n        if (_isCreditAmt) {\\n            credits_ = _amt;\\n            (underlying_, exchangeRate_) = _creditsToUnderlying(_amt);\\n        }\\n        // If the input is in underlying, then calculate credits needed to burn\\n        else {\\n            underlying_ = _amt;\\n            (credits_, exchangeRate_) = _underlyingToCredits(_amt);\\n        }\\n\\n        _burnTransfer(\\n            underlying_,\\n            credits_,\\n            msg.sender,\\n            msg.sender,\\n            exchangeRate_,\\n            _transferUnderlying\\n        );\\n\\n        emit CreditsRedeemed(msg.sender, credits_, underlying_);\\n\\n        return (credits_, underlying_);\\n    }\\n\\n    struct ConnectorStatus {\\n        // Limit is the max amount of units allowed in the connector\\n        uint256 limit;\\n        // Derived balance of the connector\\n        uint256 inConnector;\\n    }\\n\\n    /**\\n     * @dev Derives the units of collateral held in the connector\\n     * @param _data         Struct containing data on balances\\n     * @param _exchangeRate Current system exchange rate\\n     * @return status       Contains max amount of assets allowed in connector\\n     */\\n    function _getConnectorStatus(CachedData memory _data, uint256 _exchangeRate)\\n        internal\\n        pure\\n        returns (ConnectorStatus memory)\\n    {\\n        // Total units of underlying collateralised\\n        uint256 totalCollat = _data.totalCredits.mulTruncate(_exchangeRate);\\n        // Max amount of underlying that can be held in the connector\\n        uint256 limit = totalCollat.mulTruncate(_data.fraction.add(2e17));\\n        // Derives amount of underlying present in the connector\\n        uint256 inConnector = _data.rawBalance >= totalCollat\\n            ? 0\\n            : totalCollat.sub(_data.rawBalance);\\n\\n        return ConnectorStatus(limit, inConnector);\\n    }\\n\\n    /***************************************\\n                    YIELD - E\\n    ****************************************/\\n\\n    /** @dev Modifier allowing only the designated poker to execute the fn */\\n    modifier onlyPoker() {\\n        require(msg.sender == poker, \\\"Only poker can execute\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev External poke function allows for the redistribution of collateral between here and the\\n     * current connector, setting the ratio back to the defined optimal.\\n     */\\n    function poke() external onlyPoker {\\n        CachedData memory cachedData = _cacheData();\\n        _poke(cachedData, false);\\n    }\\n\\n    /**\\n     * @dev Governance action to set the address of a new poker\\n     * @param _newPoker     Address of the new poker\\n     */\\n    function setPoker(address _newPoker) external onlyGovernor {\\n        require(_newPoker != address(0) && _newPoker != poker, \\\"Invalid poker\\\");\\n\\n        poker = _newPoker;\\n\\n        emit PokerUpdated(_newPoker);\\n    }\\n\\n    /**\\n     * @dev Governance action to set the percentage of assets that should be held\\n     * in the connector.\\n     * @param _fraction     Percentage of assets that should be held there (where 20% == 2e17)\\n     */\\n    function setFraction(uint256 _fraction) external onlyGovernor {\\n        require(_fraction <= 5e17, \\\"Fraction must be <= 50%\\\");\\n\\n        fraction = _fraction;\\n\\n        CachedData memory cachedData = _cacheData();\\n        _poke(cachedData, true);\\n\\n        emit FractionUpdated(_fraction);\\n    }\\n\\n    /**\\n     * @dev Governance action to set the address of a new connector, and move funds (if any) across.\\n     * @param _newConnector     Address of the new connector\\n     */\\n    function setConnector(address _newConnector) external onlyGovernor {\\n        // Withdraw all from previous by setting target = 0\\n        CachedData memory cachedData = _cacheData();\\n        cachedData.fraction = 0;\\n        _poke(cachedData, true);\\n\\n        // Set new connector\\n        CachedData memory cachedDataNew = _cacheData();\\n        connector = IConnector(_newConnector);\\n        _poke(cachedDataNew, true);\\n\\n        emit ConnectorUpdated(_newConnector);\\n    }\\n\\n    /**\\n     * @dev Governance action to perform an emergency withdraw of the assets in the connector,\\n     * should it be the case that some or all of the liquidity is trapped in. This causes the total\\n     * collateral in the system to go down, causing a hard refresh.\\n     */\\n    function emergencyWithdraw(uint256 _withdrawAmount) external onlyGovernor {\\n        // withdraw _withdrawAmount from connection\\n        connector.withdraw(_withdrawAmount);\\n\\n        // reset the connector\\n        connector = IConnector(address(0));\\n        emit ConnectorUpdated(address(0));\\n\\n        // set fraction to 0\\n        fraction = 0;\\n        emit FractionUpdated(0);\\n\\n        // check total collateralisation of credits\\n        CachedData memory data = _cacheData();\\n        // use rawBalance as the remaining liquidity in the connector is now written off\\n        _refreshExchangeRate(data.rawBalance, data.totalCredits, true);\\n\\n        emit EmergencyUpdate();\\n    }\\n\\n    /***************************************\\n                    YIELD - I\\n    ****************************************/\\n\\n    /** @dev Internal poke function to keep the balance between connector and raw balance healthy */\\n    function _poke(CachedData memory _data, bool _ignoreCadence) internal {\\n        require(_data.totalCredits > 0, \\\"Must have something to poke\\\");\\n\\n        // 1. Verify that poke cadence is valid, unless this is a manual action by governance\\n        uint256 currentTime = uint256(now);\\n        uint256 timeSinceLastPoke = currentTime.sub(lastPoke);\\n        require(_ignoreCadence || timeSinceLastPoke > POKE_CADENCE, \\\"Not enough time elapsed\\\");\\n        lastPoke = currentTime;\\n\\n        // If there is a connector, check the balance and settle to the specified fraction %\\n        IConnector connector_ = connector;\\n        if (address(connector_) != address(0)) {\\n            // 2. Check and verify new connector balance\\n            uint256 lastBalance_ = lastBalance;\\n            uint256 connectorBalance = connector_.checkBalance();\\n            //      Always expect the collateral in the connector to increase in value\\n            require(connectorBalance >= lastBalance_, \\\"Invalid yield\\\");\\n            if (connectorBalance > 0) {\\n                //  Validate the collection by ensuring that the APY is not ridiculous\\n                _validateCollection(\\n                    connectorBalance,\\n                    connectorBalance.sub(lastBalance_),\\n                    timeSinceLastPoke\\n                );\\n            }\\n\\n            // 3. Level the assets to Fraction (connector) & 100-fraction (raw)\\n            uint256 sum = _data.rawBalance.add(connectorBalance);\\n            uint256 ideal = sum.mulTruncate(_data.fraction);\\n            //     If there is not enough mAsset in the connector, then deposit\\n            if (ideal > connectorBalance) {\\n                uint256 deposit = ideal.sub(connectorBalance);\\n                underlying.approve(address(connector_), deposit);\\n                connector_.deposit(deposit);\\n            }\\n            //     Else withdraw, if there is too much mAsset in the connector\\n            else if (connectorBalance > ideal) {\\n                // If fraction == 0, then withdraw everything\\n                if (ideal == 0) {\\n                    connector_.withdrawAll();\\n                    sum = IERC20(underlying).balanceOf(address(this));\\n                } else {\\n                    connector_.withdraw(connectorBalance.sub(ideal));\\n                }\\n            }\\n            //     Else ideal == connectorBalance (e.g. 0), do nothing\\n            require(connector_.checkBalance() >= ideal, \\\"Enforce system invariant\\\");\\n\\n            // 4i. Refresh exchange rate and emit event\\n            lastBalance = ideal;\\n            _refreshExchangeRate(sum, _data.totalCredits, false);\\n            emit Poked(lastBalance_, ideal, connectorBalance.sub(lastBalance_));\\n        } else {\\n            // 4ii. Refresh exchange rate and emit event\\n            lastBalance = 0;\\n            _refreshExchangeRate(_data.rawBalance, _data.totalCredits, false);\\n            emit PokedRaw();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal fn to refresh the exchange rate, based on the sum of collateral and the number of credits\\n     * @param _realSum          Sum of collateral held by the contract\\n     * @param _totalCredits     Total number of credits in the system\\n     * @param _ignoreValidation This is for use in the emergency situation, and ignores a decreasing exchangeRate\\n     */\\n    function _refreshExchangeRate(\\n        uint256 _realSum,\\n        uint256 _totalCredits,\\n        bool _ignoreValidation\\n    ) internal {\\n        // Based on the current exchange rate, how much underlying is collateralised?\\n        (uint256 totalCredited, ) = _creditsToUnderlying(_totalCredits);\\n\\n        // Require the amount of capital held to be greater than the previously credited units\\n        require(_ignoreValidation || _realSum >= totalCredited, \\\"ExchangeRate must increase\\\");\\n        // Work out the new exchange rate based on the current capital\\n        uint256 newExchangeRate = _calcExchangeRate(_realSum, _totalCredits);\\n        exchangeRate = newExchangeRate;\\n\\n        emit ExchangeRateUpdated(\\n            newExchangeRate,\\n            _realSum > totalCredited ? _realSum.sub(totalCredited) : 0\\n        );\\n    }\\n\\n    /**\\n     * FORKED DIRECTLY FROM SAVINGSMANAGER.sol\\n     * ---------------------------------------\\n     * @dev Validates that an interest collection does not exceed a maximum APY. If last collection\\n     * was under 30 mins ago, simply check it does not exceed 10bps\\n     * @param _newBalance              New balance of the underlying\\n     * @param _interest                Increase in total supply since last collection\\n     * @param _timeSinceLastCollection Seconds since last collection\\n     */\\n    function _validateCollection(\\n        uint256 _newBalance,\\n        uint256 _interest,\\n        uint256 _timeSinceLastCollection\\n    ) internal pure returns (uint256 extrapolatedAPY) {\\n        // Protect against division by 0\\n        uint256 protectedTime = StableMath.max(1, _timeSinceLastCollection);\\n\\n        uint256 oldSupply = _newBalance.sub(_interest);\\n        uint256 percentageIncrease = _interest.divPrecisely(oldSupply);\\n\\n        uint256 yearsSinceLastCollection = protectedTime.divPrecisely(SECONDS_IN_YEAR);\\n\\n        extrapolatedAPY = percentageIncrease.divPrecisely(yearsSinceLastCollection);\\n\\n        if (protectedTime > 30 minutes) {\\n            require(extrapolatedAPY < MAX_APY, \\\"Interest protected from inflating past maxAPY\\\");\\n        } else {\\n            require(percentageIncrease < 1e15, \\\"Interest protected from inflating past 10 Bps\\\");\\n        }\\n    }\\n\\n    /***************************************\\n                    VIEW - I\\n    ****************************************/\\n\\n    struct CachedData {\\n        // SLOAD from 'fraction'\\n        uint256 fraction;\\n        // ERC20 balance of underlying, held by this contract\\n        // underlying.balanceOf(address(this))\\n        uint256 rawBalance;\\n        // totalSupply()\\n        uint256 totalCredits;\\n    }\\n\\n    /**\\n     * @dev Retrieves generic data to avoid duplicate SLOADs\\n     */\\n    function _cacheData() internal view returns (CachedData memory) {\\n        uint256 balance = underlying.balanceOf(address(this));\\n        return CachedData(fraction, balance, totalSupply());\\n    }\\n\\n    /**\\n     * @dev Converts masset amount into credits based on exchange rate\\n     *               c = (masset / exchangeRate) + 1\\n     */\\n    function _underlyingToCredits(uint256 _underlying)\\n        internal\\n        view\\n        returns (uint256 credits, uint256 exchangeRate_)\\n    {\\n        // e.g. (1e20 * 1e18) / 1e18 = 1e20\\n        // e.g. (1e20 * 1e18) / 14e17 = 7.1429e19\\n        // e.g. 1 * 1e18 / 1e17 + 1 = 11 => 11 * 1e17 / 1e18 = 1.1e18 / 1e18 = 1\\n        exchangeRate_ = exchangeRate;\\n        credits = _underlying.divPrecisely(exchangeRate_).add(1);\\n    }\\n\\n    /**\\n     * @dev Works out a new exchange rate, given an amount of collateral and total credits\\n     *               e = underlying / (credits-1)\\n     */\\n    function _calcExchangeRate(uint256 _totalCollateral, uint256 _totalCredits)\\n        internal\\n        pure\\n        returns (uint256 _exchangeRate)\\n    {\\n        _exchangeRate = _totalCollateral.divPrecisely(_totalCredits.sub(1));\\n    }\\n\\n    /**\\n     * @dev Converts credit amount into masset based on exchange rate\\n     *               m = credits * exchangeRate\\n     */\\n    function _creditsToUnderlying(uint256 _credits)\\n        internal\\n        view\\n        returns (uint256 underlyingAmount, uint256 exchangeRate_)\\n    {\\n        // e.g. (1e20 * 1e18) / 1e18 = 1e20\\n        // e.g. (1e20 * 14e17) / 1e18 = 1.4e20\\n        exchangeRate_ = exchangeRate;\\n        underlyingAmount = _credits.mulTruncate(exchangeRate_);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                IERC4626Vault\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice it must be an ERC-20 token contract. Must not revert.\\n     *\\n     * @return assetTokenAddress the address of the underlying asset token. eg mUSD or mBTC\\n     */\\n    function asset() external view returns (address assetTokenAddress) {\\n        return address(underlying);\\n    }\\n\\n    /**\\n     * @return totalManagedAssets the total amount of the underlying asset tokens that is \u201cmanaged\u201d by Vault.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets) {\\n        return underlying.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @notice The amount of shares that the Vault would exchange for the amount of assets provided, in an ideal scenario where all the conditions are met.\\n     * @param assets The amount of underlying assets to be convert to vault shares.\\n     * @return shares The amount of vault shares converted from the underlying assets.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares) {\\n        (shares, ) = _underlyingToCredits(assets);\\n    }\\n\\n    /**\\n     * @notice The amount of assets that the Vault would exchange for the amount of shares provided, in an ideal scenario where all the conditions are met.\\n     * @param shares The amount of vault shares to be converted to the underlying assets.\\n     * @return assets The amount of underlying assets converted from the vault shares.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets) {\\n        (assets, ) = _creditsToUnderlying(shares);\\n    }\\n\\n    /**\\n     * @notice The maximum number of underlying assets that caller can deposit.\\n     * caller Account that the assets will be transferred from.\\n     * @return maxAssets The maximum amount of underlying assets the caller can deposit.\\n     */\\n    function maxDeposit(\\n        address /** caller **/\\n    ) external view returns (uint256 maxAssets) {\\n        maxAssets = MAX_INT256;\\n    }\\n\\n    /**\\n     * @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.\\n     * @param assets The amount of underlying assets to be transferred.\\n     * @return shares The amount of vault shares that will be minted.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares) {\\n        require(assets > 0, \\\"Must deposit something\\\");\\n        (shares, ) = _underlyingToCredits(assets);\\n    }\\n\\n    /**\\n     * @notice Mint vault shares to receiver by transferring exact amount of underlying asset tokens from the caller.\\n     *      Credit amount is calculated as a ratio of deposit amount and exchange rate:\\n     *                    credits = underlying / exchangeRate\\n     *      We will first update the internal exchange rate by collecting any interest generated on the underlying.\\n     * Emits a {Deposit} event.\\n     * @param assets      Units of underlying to deposit into savings vault. eg mUSD or mBTC\\n     * @param receiver    The address to receive the Vault shares.\\n     * @return shares     Units of credits issued. eg imUSD or imBTC\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares) {\\n        shares = _transferAndMint(assets, receiver, true);\\n    }\\n\\n    /**\\n     *\\n     * @notice Overloaded `deposit` method with an optional referrer address.\\n     * @param assets    Units of underlying to deposit into savings vault. eg mUSD or mBTC\\n     * @param receiver  Address to the new credits will be issued to.\\n     * @param referrer  Referrer address for this deposit.\\n     * @return shares   Units of credits issued. eg imUSD or imBTC\\n     */\\n    function deposit(\\n        uint256 assets,\\n        address receiver,\\n        address referrer\\n    ) external returns (uint256 shares) {\\n        shares = _transferAndMint(assets, receiver, true);\\n        emit Referral(referrer, receiver, assets);\\n    }\\n\\n    /**\\n     * @notice The maximum number of vault shares that caller can mint.\\n     * caller Account that the underlying assets will be transferred from.\\n     * @return maxShares The maximum amount of vault shares the caller can mint.\\n     */\\n    function maxMint(\\n        address /* caller */\\n    ) external view returns (uint256 maxShares) {\\n        maxShares = MAX_INT256;\\n    }\\n\\n    /**\\n     * @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.\\n     * @param shares The amount of vault shares to be minted.\\n     * @return assets The amount of underlying assests that will be transferred from the caller.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets) {\\n        (assets, ) = _creditsToUnderlying(shares);\\n        return assets;\\n    }\\n\\n    /**\\n     * @notice Mint exact amount of vault shares to the receiver by transferring enough underlying asset tokens from the caller.\\n     * Emits a {Deposit} event.\\n     *\\n     * @param shares The amount of vault shares to be minted.\\n     * @param receiver The account the vault shares will be minted to.\\n     * @return assets The amount of underlying assets that were transferred from the caller.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets) {\\n        (assets, ) = _creditsToUnderlying(shares);\\n        _transferAndMint(assets, receiver, true);\\n    }\\n\\n    /**\\n     * @notice Mint exact amount of vault shares to the receiver by transferring enough underlying asset tokens from the caller.\\n     * @param shares The amount of vault shares to be minted.\\n     * @param receiver The account the vault shares will be minted to.\\n     * @param referrer  Referrer address for this deposit.\\n     * @return assets The amount of underlying assets that were transferred from the caller.\\n     * Emits a {Deposit}, {Referral} events\\n     */\\n    function mint(\\n        uint256 shares,\\n        address receiver,\\n        address referrer\\n    ) external returns (uint256 assets) {\\n        (assets, ) = _creditsToUnderlying(shares);\\n        _transferAndMint(assets, receiver, true);\\n        emit Referral(referrer, receiver, assets);\\n    }\\n\\n    /**\\n     * @notice The maximum number of underlying assets that owner can withdraw.\\n     * @param owner Address that owns the underlying assets.\\n     * @return maxAssets The maximum amount of underlying assets the owner can withdraw.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets) {\\n        (maxAssets, ) = _creditsToUnderlying(balanceOf(owner));\\n    }\\n\\n    /**\\n     * @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.\\n     * @param assets The amount of underlying assets to be withdrawn.\\n     * @return shares The amount of vault shares that will be burnt.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares) {\\n        (shares, ) = _underlyingToCredits(assets);\\n    }\\n\\n    /**\\n     * @notice Burns enough vault shares from owner and transfers the exact amount of underlying asset tokens to the receiver.\\n     * Emits a {Withdraw} event.\\n     *\\n     * @param assets The amount of underlying assets to be withdrawn from the vault.\\n     * @param receiver The account that the underlying assets will be transferred to.\\n     * @param owner Account that owns the vault shares to be burnt.\\n     * @return shares The amount of vault shares that were burnt.\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares) {\\n        require(assets > 0, \\\"Must withdraw something\\\");\\n        uint256 _exchangeRate;\\n        if (automateInterestCollection) {\\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(underlying));\\n        }\\n        (shares, _exchangeRate) = _underlyingToCredits(assets);\\n\\n        _burnTransfer(assets, shares, receiver, owner, _exchangeRate, true);\\n    }\\n\\n    /**\\n     * @notice it must return a limited value if owner is subject to some withdrawal limit or timelock. must return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock. MAY be used in the previewRedeem or redeem methods for shares input parameter. must NOT revert.\\n     *\\n     * @param owner Address that owns the shares.\\n     * @return maxShares Total number of shares that owner can redeem.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares) {\\n        maxShares = balanceOf(owner);\\n    }\\n\\n    /**\\n     * @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.\\n     *\\n     * @return assets the exact amount of underlying assets that would be withdrawn by the caller if redeeming a given exact amount of Vault shares using the redeem method\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets) {\\n        (assets, ) = _creditsToUnderlying(shares);\\n        return assets;\\n    }\\n\\n    /**\\n     * @notice Burns exact amount of vault shares from owner and transfers the underlying asset tokens to the receiver.\\n     * Emits a {Withdraw} event.\\n     *\\n     * @param shares The amount of vault shares to be burnt.\\n     * @param receiver The account the underlying assets will be transferred to.\\n     * @param owner The account that owns the vault shares to be burnt.\\n     * @return assets The amount of underlying assets that were transferred to the receiver.\\n     */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets) {\\n        require(shares > 0, \\\"Must withdraw something\\\");\\n        uint256 _exchangeRate;\\n        if (automateInterestCollection) {\\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(underlying));\\n        }\\n        (assets, _exchangeRate) = _creditsToUnderlying(shares);\\n\\n        _burnTransfer(assets, shares, receiver, owner, _exchangeRate, true); //transferAssets=true\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        INTERNAL DEPOSIT/MINT\\n    //////////////////////////////////////////////////////////////*/\\n    function _transferAndMint(\\n        uint256 assets,\\n        address receiver,\\n        bool _collectInterest\\n    ) internal returns (uint256 shares) {\\n        require(assets > 0, \\\"Must deposit something\\\");\\n        require(receiver != address(0), \\\"Invalid beneficiary address\\\");\\n\\n        // Collect recent interest generated by basket and update exchange rate\\n        IERC20 mAsset = underlying;\\n        if (_collectInterest) {\\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(mAsset));\\n        }\\n\\n        // Transfer tokens from sender to here\\n        require(mAsset.transferFrom(msg.sender, address(this), assets), \\\"Must receive tokens\\\");\\n\\n        // Calc how many credits they receive based on currentRatio\\n        (shares, ) = _underlyingToCredits(assets);\\n\\n        // add credits to ERC20 balances\\n        _mint(receiver, shares);\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n        emit SavingsDeposited(receiver, assets, shares);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        INTERNAL WITHDRAW/REDEEM\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _burnTransfer(\\n        uint256 assets,\\n        uint256 shares,\\n        address receiver,\\n        address owner,\\n        uint256 _exchangeRate,\\n        bool transferAssets\\n    ) internal {\\n        require(receiver != address(0), \\\"Invalid beneficiary address\\\");\\n\\n        // If caller is not the owner of the shares\\n        uint256 allowed = allowance(owner, msg.sender);\\n        if (msg.sender != owner && allowed != MAX_INT256) {\\n            require(shares <= allowed, \\\"Amount exceeds allowance\\\");\\n            _approve(owner, msg.sender, allowed - shares);\\n        }\\n\\n        // Burn required shares from the owner FIRST\\n        _burn(owner, shares);\\n\\n        // Optionally, transfer tokens from here to receiver\\n        if (transferAssets) {\\n            require(underlying.transfer(receiver, assets), \\\"Must send tokens\\\");\\n            emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n        }\\n        // If this withdrawal pushes the portion of stored collateral in the `connector` over a certain\\n        // threshold (fraction + 20%), then this should trigger a _poke on the connector. This is to avoid\\n        // a situation in which there is a rush on withdrawals for some reason, causing the connector\\n        // balance to go up and thus having too large an exposure.\\n        CachedData memory cachedData = _cacheData();\\n        ConnectorStatus memory status = _getConnectorStatus(cachedData, _exchangeRate);\\n        if (status.inConnector > status.limit) {\\n            _poke(cachedData, false);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"automationEnabled\",\"type\":\"bool\"}],\"name\":\"AutomaticInterestCollectionSwitched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"ConnectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creditsRedeemed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"savingsCredited\",\"type\":\"uint256\"}],\"name\":\"CreditsRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EmergencyUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newExchangeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestCollected\",\"type\":\"uint256\"}],\"name\":\"ExchangeRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fraction\",\"type\":\"uint256\"}],\"name\":\"FractionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestDetected\",\"type\":\"uint256\"}],\"name\":\"Poked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PokedRaw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poker\",\"type\":\"address\"}],\"name\":\"PokerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Referral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"saver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"savingsDeposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creditsIssued\",\"type\":\"uint256\"}],\"name\":\"SavingsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"assetTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"automateInterestCollectionFlag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"connector\",\"outputs\":[{\"internalType\":\"contract IConnector\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"creditBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_credits\",\"type\":\"uint256\"}],\"name\":\"creditsToUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositInterest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_underlying\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"depositSavings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"creditsIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_underlying\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"depositSavings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"creditsIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_underlying\",\"type\":\"uint256\"}],\"name\":\"depositSavings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"creditsIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poker\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_nameArg\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbolArg\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPoke\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxAssets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxShares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxShares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxAssets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nexus\",\"outputs\":[{\"internalType\":\"contract INexus\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"poke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_underlying\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"preDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"creditsIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_credits\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"massetReturned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isCreditAmt\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBassetOut\",\"type\":\"bool\"}],\"name\":\"redeemAndUnwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"creditsBurned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"massetReturned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputQuantity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_credits\",\"type\":\"uint256\"}],\"name\":\"redeemCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"massetReturned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_underlying\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"creditsBurned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newConnector\",\"type\":\"address\"}],\"name\":\"setConnector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fraction\",\"type\":\"uint256\"}],\"name\":\"setFraction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPoker\",\"type\":\"address\"}],\"name\":\"setPoker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalManagedAssets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_underlying\",\"type\":\"uint256\"}],\"name\":\"underlyingToCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"credits\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unwrapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SavingsContract_imusd_mainnet_22", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}