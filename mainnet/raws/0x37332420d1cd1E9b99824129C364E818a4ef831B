{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ZDAORegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\r\\nimport \\\"./interfaces/IZDAORegistry.sol\\\";\\r\\nimport \\\"./interfaces/IZNSHub.sol\\\";\\r\\n\\r\\ncontract ZDAORegistry is IZDAORegistry, OwnableUpgradeable {\\r\\n  IZNSHub public znsHub;\\r\\n\\r\\n  mapping(uint256 => uint256) private ensTozDAO;\\r\\n  mapping(uint256 => uint256) private zNATozDAOId;\\r\\n  ZDAORecord[] public zDAORecords;\\r\\n\\r\\n  modifier onlyZNAOwner(uint256 zNA) {\\r\\n    require(znsHub.ownerOf(zNA) == msg.sender, \\\"Not zNA owner\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier onlyValidZDAO(uint256 daoId) {\\r\\n    require(daoId > 0 && daoId < zDAORecords.length, \\\"Invalid daoId\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function initialize(address _znsHub) external initializer {\\r\\n    __Ownable_init();\\r\\n\\r\\n    znsHub = IZNSHub(_znsHub);\\r\\n    zDAORecords.push(\\r\\n      ZDAORecord({id: 0, ensSpace: \\\"\\\", gnosisSafe: address(0), associatedzNAs: new uint256[](0)})\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function setZNSHub(address _znsHub) external onlyOwner {\\r\\n    znsHub = IZNSHub(_znsHub);\\r\\n  }\\r\\n\\r\\n  function addNewDAO(string calldata ensSpace, address gnosisSafe) external onlyOwner {\\r\\n    uint256 zDAOId = zDAORecords.length;\\r\\n    zDAORecords.push(\\r\\n      ZDAORecord({\\r\\n        id: zDAOId,\\r\\n        ensSpace: ensSpace,\\r\\n        gnosisSafe: gnosisSafe,\\r\\n        associatedzNAs: new uint256[](0)\\r\\n      })\\r\\n    );\\r\\n\\r\\n    emit DAOCreated(zDAOId, ensSpace, gnosisSafe);\\r\\n  }\\r\\n\\r\\n  function addZNAAssociation(uint256 daoId, uint256 zNA)\\r\\n    external\\r\\n    onlyValidZDAO(daoId)\\r\\n    onlyZNAOwner(zNA)\\r\\n  {\\r\\n    uint256 currentDAOAssociation = zNATozDAOId[zNA];\\r\\n    require(currentDAOAssociation != daoId, \\\"zNA already linked to DAO\\\");\\r\\n\\r\\n    // If an association already exists, remove it\\r\\n    if (currentDAOAssociation != 0) {\\r\\n      _removeZNAAssociation(currentDAOAssociation, zNA);\\r\\n    }\\r\\n\\r\\n    zNATozDAOId[zNA] = daoId;\\r\\n    zDAORecords[daoId].associatedzNAs.push(zNA);\\r\\n\\r\\n    emit LinkAdded(daoId, zNA);\\r\\n  }\\r\\n\\r\\n  function removeZNAAssociation(uint256 daoId, uint256 zNA)\\r\\n    external\\r\\n    onlyValidZDAO(daoId)\\r\\n    onlyZNAOwner(zNA)\\r\\n  {\\r\\n    uint256 currentDAOAssociation = zNATozDAOId[zNA];\\r\\n    require(currentDAOAssociation == daoId, \\\"zNA not associated\\\");\\r\\n\\r\\n    _removeZNAAssociation(daoId, zNA);\\r\\n  }\\r\\n\\r\\n  function numberOfzDAOs() external view returns (uint256) {\\r\\n    return zDAORecords.length - 1;\\r\\n  }\\r\\n\\r\\n  function getzDAOById(uint256 daoId) external view returns (ZDAORecord memory) {\\r\\n    return zDAORecords[daoId];\\r\\n  }\\r\\n\\r\\n  function listzDAOs(uint256 startIndex, uint256 endIndex)\\r\\n    external\\r\\n    view\\r\\n    returns (ZDAORecord[] memory)\\r\\n  {\\r\\n    uint256 numDaos = zDAORecords.length;\\r\\n    require(startIndex != 0, \\\"start index = 0, use 1\\\");\\r\\n    require(startIndex <= endIndex, \\\"start index > end\\\");\\r\\n    require(startIndex < numDaos, \\\"start index > length\\\");\\r\\n    require(endIndex < numDaos, \\\"end index > length\\\");\\r\\n\\r\\n    if (numDaos == 1) {\\r\\n      return new ZDAORecord[](0);\\r\\n    }\\r\\n\\r\\n    uint256 numRecords = endIndex - startIndex + 1;\\r\\n    ZDAORecord[] memory records = new ZDAORecord[](numRecords);\\r\\n\\r\\n    for (uint256 i = 0; i < numRecords; ++i) {\\r\\n      records[i] = zDAORecords[startIndex + i];\\r\\n    }\\r\\n\\r\\n    return records;\\r\\n  }\\r\\n\\r\\n  function getzDaoByZNA(uint256 zNA) external view returns (ZDAORecord memory) {\\r\\n    uint256 daoId = zNATozDAOId[zNA];\\r\\n    require(daoId != 0 && daoId < zDAORecords.length, \\\"No zDAO associated with zNA\\\");\\r\\n    return zDAORecords[daoId];\\r\\n  }\\r\\n\\r\\n  function getzDAOByEns(string calldata ensSpace) external view returns (ZDAORecord memory) {\\r\\n    uint256 ensHash = uint256(keccak256(abi.encodePacked(ensSpace)));\\r\\n    uint256 daoId = ensTozDAO[ensHash];\\r\\n    require(daoId != 0, \\\"No zDAO at ens space\\\");\\r\\n    return zDAORecords[daoId];\\r\\n  }\\r\\n\\r\\n  function doeszDAOExistForzNA(uint256 zNA) external view returns (bool) {\\r\\n    return zNATozDAOId[zNA] != 0;\\r\\n  }\\r\\n\\r\\n  function _removeZNAAssociation(uint256 daoId, uint256 zNA) internal {\\r\\n    ZDAORecord storage dao = zDAORecords[daoId];\\r\\n    uint256 length = zDAORecords[daoId].associatedzNAs.length;\\r\\n\\r\\n    for (uint256 i = 0; i < length; i++) {\\r\\n      if (dao.associatedzNAs[i] == zNA) {\\r\\n        dao.associatedzNAs[i] = dao.associatedzNAs[length - 1];\\r\\n        dao.associatedzNAs.pop();\\r\\n        zNATozDAOId[zNA] = 0;\\r\\n\\r\\n        emit LinkRemoved(daoId, zNA);\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IZDAORegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IZDAORegistry {\\r\\n  struct ZDAORecord {\\r\\n    uint256 id;\\r\\n    string ensSpace;\\r\\n    address gnosisSafe;\\r\\n    uint256[] associatedzNAs;\\r\\n  }\\r\\n\\r\\n  // function zNATozDAOId(uint256 zNA) external view returns (uint256);\\r\\n\\r\\n  function numberOfzDAOs() external view returns (uint256);\\r\\n\\r\\n  function getzDAOById(uint256 daoId) external view returns (ZDAORecord memory);\\r\\n\\r\\n  function getzDAOByEns(string calldata ensSpace) external view returns (ZDAORecord memory);\\r\\n\\r\\n  function listzDAOs(uint256 startIndex, uint256 endIndex)\\r\\n    external\\r\\n    view\\r\\n    returns (ZDAORecord[] memory);\\r\\n\\r\\n  function doeszDAOExistForzNA(uint256 zNA) external view returns (bool);\\r\\n\\r\\n  function getzDaoByZNA(uint256 zNA) external view returns (ZDAORecord memory);\\r\\n\\r\\n  event DAOCreated(uint256 indexed daoId, string ensSpace, address gnosisSafe);\\r\\n  event LinkAdded(uint256 indexed daoId, uint256 indexed zNA);\\r\\n  event LinkRemoved(uint256 indexed daoId, uint256 indexed zNA);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IZNSHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/**\\r\\nAddresses:\\r\\n  Rinkeby: 0x90098737eB7C3e73854daF1Da20dFf90d521929a\\r\\n*/\\r\\n\\r\\ninterface IZNSHub {\\r\\n  // Returns the owner of a zNA given by `domainId`\\r\\n  function ownerOf(uint256 domainId) external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ensSpace\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gnosisSafe\",\"type\":\"address\"}],\"name\":\"DAOCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"zNA\",\"type\":\"uint256\"}],\"name\":\"LinkAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"zNA\",\"type\":\"uint256\"}],\"name\":\"LinkRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ensSpace\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"gnosisSafe\",\"type\":\"address\"}],\"name\":\"addNewDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zNA\",\"type\":\"uint256\"}],\"name\":\"addZNAAssociation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"zNA\",\"type\":\"uint256\"}],\"name\":\"doeszDAOExistForzNA\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ensSpace\",\"type\":\"string\"}],\"name\":\"getzDAOByEns\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ensSpace\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"gnosisSafe\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"associatedzNAs\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IZDAORegistry.ZDAORecord\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"}],\"name\":\"getzDAOById\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ensSpace\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"gnosisSafe\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"associatedzNAs\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IZDAORegistry.ZDAORecord\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"zNA\",\"type\":\"uint256\"}],\"name\":\"getzDaoByZNA\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ensSpace\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"gnosisSafe\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"associatedzNAs\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IZDAORegistry.ZDAORecord\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_znsHub\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"listzDAOs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ensSpace\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"gnosisSafe\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"associatedzNAs\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IZDAORegistry.ZDAORecord[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfzDAOs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zNA\",\"type\":\"uint256\"}],\"name\":\"removeZNAAssociation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_znsHub\",\"type\":\"address\"}],\"name\":\"setZNSHub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"zDAORecords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ensSpace\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"gnosisSafe\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"znsHub\",\"outputs\":[{\"internalType\":\"contract IZNSHub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ZDAORegistry", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}