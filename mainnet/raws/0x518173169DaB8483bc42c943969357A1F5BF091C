{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/oracles/OracleAuthorityV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.14;\\n\\n//\\n//                                 (((((((((((()                                 \\n//                              (((((((((((((((((((                              \\n//                            ((((((           ((((((                            \\n//                           (((((               (((((                           \\n//                         (((((/                 ((((((                         \\n//                        (((((                     (((((                        \\n//                      ((((((                       ((((()                      \\n//                     (((((                           (((((                     \\n//                   ((((((                             (((((                    \\n//                  (((((                                                        \\n//                ((((((                        (((((((((((((((                  \\n//               (((((                       (((((((((((((((((((((               \\n//             ((((((                      ((((((             (((((.             \\n//            (((((                      ((((((.               ((((((            \\n//          ((((((                     ((((((((                  (((((           \\n//         (((((                      (((((((((                   ((((((         \\n//        (((((                     ((((((.(((((                    (((((        \\n//       (((((                     ((((((   (((((                    (((((       \\n//      (((((                    ((((((      ((((((                   (((((      \\n//      ((((.                  ((((((          (((((                  (((((      \\n//      (((((                .((((((            ((((((                (((((      \\n//       ((((()            (((((((                (((((             ((((((       \\n//        .(((((((      (((((((.                   ((((((((     ((((((((         \\n//           ((((((((((((((((                         ((((((((((((((((           \\n//                .((((.                                    (((()         \\n//                                  \\n//                               attrace.com\\n//\\n\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../settings/SettingsV1.sol\\\";\\nimport \\\"../settings/SettingValidatorV1.sol\\\";\\n\\n// Oracle Authority \\n//\\n// A single instance of this contract represent a genesis state for Attrace oracles to bootstrap from.\\n//\\n// Oracles start up with an OracleAuthorityV1 address and use it to resolve all their initialization state.\\n// After being operational, the oracles react to planned changes (and cancellations of planned changes if they are not yet in effect).\\n//\\n// This allows efficient internal design of the derived block code. All changes have to be announced, so all code can switch and prepare before processing blocks.\\n//\\n// This contract can live on a different chain than the pacemaker.\\n// All changes done to the oracles are event-like encoded on-chain and emitted. \\n//\\n// The contract can encode start before it's deployment time, allowing oracles to plug into chains from historical points before it's deployment time.\\n// Any changes after deployment have to wait until oracles are synced upto change times.\\n//\\n// The DAO will become owner of this contract.\\n//\\n// The contract applies \\\"irreversible\\\" behavior: even the future DAO cannot revert historically activated changes for those time periods.\\n//\\ncontract OracleAuthorityV1 is Ownable {\\n  \\n  // Pluggable setting validator\\n  SettingValidatorV1 public settingValidator;\\n\\n  // Settings change history\\n  // releaseTime=0 indicates genesis setting\\n  Setting[] private changeHistory;\\n\\n  // Static keys to set self address\\n  bytes32 constant AUTHORITY = \\\"authority\\\";\\n  bytes32 constant SETTING_VALIDATOR = \\\"settingValidator\\\";\\n\\n  // Emitted whenever a setting change is planned\\n  event SettingConfigured(bytes32 indexed path0, bytes32 indexed pathIdx, bytes32[] path, uint64 releaseTime, bytes value);\\n\\n  // Emitted whenever planned settings are cancelled\\n  event PendingSettingCancelled(bytes32 indexed path0, bytes32 indexed pathIdx, Setting setting);\\n\\n  // When created, it's created with a genesis state\\n  constructor(Setting[] memory genesisSettings) {\\n    // Inject our own address to guarantee a unique genesis state related to this authority contract\\n    addSetting(Setting(settingToPath(AUTHORITY), 0, abi.encode(block.chainid, address(this))));\\n\\n    // Add the requested genesis properties\\n    for(uint i = 0; i < genesisSettings.length; i++) {\\n      require(genesisSettings[i].releaseTime == 0, \\\"400\\\");\\n      addSetting(genesisSettings[i]);\\n    }\\n\\n    // It's required to configure a setting validator during deployment\\n    require(address(settingValidator) != address(0), \\\"400: settings\\\");\\n  }\\n\\n  // Return changeHistory size\\n  function changeCount() external view returns (uint256) {\\n    return changeHistory.length;\\n  }\\n\\n  // Get a specific change from the change history\\n  function getChange(uint256 idx) external view returns (Setting memory) {\\n    return changeHistory[idx];\\n  }\\n\\n  // Plan all future oracle changes. \\n  // When planning new changes, you replace all previous planned changed.\\n  function planChanges(Setting[] calldata settings) external onlyOwner {\\n    // Remove any planned changes which have not been activated yet\\n    for(uint256 i = changeHistory.length-1; i >= 0; i--) {\\n      // Keep already active changes\\n      if(changeHistory[i].releaseTime <= block.timestamp) {\\n        break;\\n      }\\n      // Remove one entry from the end of the array\\n      emit PendingSettingCancelled(changeHistory[i].path[0], hashPath(changeHistory[i].path), changeHistory[i]);\\n      changeHistory.pop();\\n    }\\n\\n    // Plan the new changes\\n    uint256 lastTime;\\n    for(uint i = 0; i < settings.length; i++) {\\n      require(\\n        // Validates it's a planned change\\n        settings[i].releaseTime > block.timestamp\\n        // Validates order\\n        && (lastTime > 0 ? settings[i].releaseTime >= lastTime : true)\\n        // Validates if it's allowed to change this setting\\n        && (settingValidator.isValidUnlockedSetting(settings[i].path, settings[i].releaseTime, settings[i].value) == true)\\n        , \\\"400\\\");\\n\\n      // Plan setting + emit event\\n      addSetting(settings[i]);\\n\\n      // Track last time\\n      lastTime = settings[i].releaseTime;\\n    }\\n  }\\n\\n  function addSetting(Setting memory setting) private {\\n    // Activate setting validator changes, these apply instantly\\n    if(setting.path[0] == SETTING_VALIDATOR) {\\n      (address addr) = abi.decode(setting.value, (address));\\n      require(addr != address(0), \\\"400\\\");\\n      settingValidator = SettingValidatorV1(addr); // SettingValidator ignores the history concept\\n    }\\n\\n    changeHistory.push(setting);\\n    emit SettingConfigured(setting.path[0], hashPath(setting.path), setting.path, setting.releaseTime, setting.value);\\n  }\\n\\n  // -- don't accept raw ether\\n  receive() external payable {\\n    revert('unsupported');\\n  }\\n\\n  // -- reject any other function\\n  fallback() external payable {\\n    revert('unsupported');\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/settings/SettingsV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.14;\\n\\nfunction settingToPath(bytes32 setting) pure returns (bytes32[] memory) {\\n  bytes32[] memory path = new bytes32[](1);\\n  path[0] = setting;\\n  return path;\\n}\\n\\nfunction hashPath(bytes32[] memory path) pure returns (bytes32) {\\n  return keccak256(abi.encode(path));\\n}\\n\\nstruct Setting {\\n  // Setting path identifier, the key. Can also encode array values.\\n  // Eg: [b32str(\\\"hardFork\\\")]\\n  bytes32[] path;\\n\\n  // Pacemaker block time where the change activates in seconds.\\n  // Code activates on the first block.timestamp > releaseTime.\\n  uint64 releaseTime;\\n\\n  // Optional bbi-encoded bytes value. Can contain any structure.\\n  // Value encoding should be supported by the runtime at that future block height.\\n  // Eg: codebase url hints\\n  bytes value;\\n}\"\r\n    },\r\n    \"./contracts/settings/SettingValidatorV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.14;\\n\\ninterface SettingValidatorV1 {\\n  function isValidUnlockedSetting(bytes32[] calldata path, uint64 releaseTime, bytes calldata value) external view returns (bool);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64\",\"name\":\"releaseTime\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"internalType\":\"struct Setting[]\",\"name\":\"genesisSettings\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"path0\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"pathIdx\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64\",\"name\":\"releaseTime\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct Setting\",\"name\":\"setting\",\"type\":\"tuple\"}],\"name\":\"PendingSettingCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"path0\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"pathIdx\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"releaseTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"name\":\"SettingConfigured\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"changeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getChange\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64\",\"name\":\"releaseTime\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"internalType\":\"struct Setting\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64\",\"name\":\"releaseTime\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"internalType\":\"struct Setting[]\",\"name\":\"settings\",\"type\":\"tuple[]\"}],\"name\":\"planChanges\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settingValidator\",\"outputs\":[{\"internalType\":\"contract SettingValidatorV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OracleAuthorityV1", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000003a000000000000000000000000000000000000000000000000000000000000004800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001706163656d616b65720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000016e6574776f726b730000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001a49a040e417932859110b6d8113d8ff2db40a40660ed8fadfb06cf43bd9ba1fd0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000173657474696e6756616c696461746f72000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c28954ea600c4acc8ced71efacd5fc04f42382ce0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001726566657272616c4661726d7356310000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000001c1f04af99fc53dd3b74615ab47d8825eb98b794300000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001636f6e6669726d6174696f6e735631000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000003bde25d3ca9b0b08f183d52448afcf8e3e772bee", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://923cd58c4c3b7b7830a07dcd7f12d80db0c4b5c2dd7ebc6043006b38fa253fd0"}]}