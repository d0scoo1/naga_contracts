{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/LandSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"../interfaces/ERC20Spec.sol\\\";\\r\\nimport \\\"../interfaces/ERC721Spec.sol\\\";\\r\\nimport \\\"../interfaces/ERC721SpecExt.sol\\\";\\r\\nimport \\\"../interfaces/LandERC721Spec.sol\\\";\\r\\nimport \\\"../interfaces/IdentifiableSpec.sol\\\";\\r\\nimport \\\"../interfaces/PriceOracleSpec.sol\\\";\\r\\nimport \\\"../lib/LandLib.sol\\\";\\r\\nimport \\\"../lib/SafeERC20.sol\\\";\\r\\nimport \\\"../utils/UpgradeableAccessControl.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Land Sale\\r\\n *\\r\\n * @notice Enables the Land NFT sale via dutch auction mechanism\\r\\n *\\r\\n * @notice The proposed volume of land is approximately 100,000 plots, split amongst the 7 regions.\\r\\n *      The volume is released over a series of staggered sales with the first sale featuring\\r\\n *      about 20,000 land plots (tokens).\\r\\n *\\r\\n * @notice Land plots are sold in sequences, each sequence groups tokens which are sold in parallel.\\r\\n *      Sequences start selling one by one with the configurable time interval between their start.\\r\\n *      A sequence is available for a sale for a fixed (configurable) amount of time, meaning they\\r\\n *      can overlap (tokens from several sequences are available on sale simultaneously) if this\\r\\n *      amount of time is bigger than interval between sequences start.\\r\\n *\\r\\n * @notice The sale operates in a configurable time interval which should be aligned with the\\r\\n *      total number of sequences, their duration, and start interval.\\r\\n *      Sale smart contract has no idea of the total number of sequences and doesn't validate\\r\\n *      if these timings are correctly aligned.\\r\\n *\\r\\n * @notice Starting prices of the plots are defined by the plot tier in ETH, and are configurable\\r\\n *      within the sale contract per tier ID.\\r\\n *      Token price declines over time exponentially, price halving time is configurable.\\r\\n *      The exponential price decline simulates the price drop requirement which may be formulated\\r\\n *      something like \\\"the price drops by 'x' % every 'y' minutes\\\".\\r\\n *      For example, if x = 2, and y = 1, \\\"the price drops by 2% every minute\\\", the halving\\r\\n *      time is around 34 minutes.\\r\\n *\\r\\n * @notice Sale accepts ETH and sILV as a payment currency, sILV price is supplied by on-chain\\r\\n *      price oracle (sILV price is assumed to be equal to ILV price)\\r\\n *\\r\\n * @notice The data required to mint a plot includes (see `PlotData` struct):\\r\\n *      - token ID, defines a unique ID for the land plot used as ERC721 token ID\\r\\n *      - sequence ID, defines the time frame when the plot is available for sale\\r\\n *      - region ID (1 - 7), determines which tileset to use in game,\\r\\n *      - coordinates (x, y) on the overall world map, indicating which grid position the land sits in,\\r\\n *      - tier ID (1 - 5), the rarity of the land, tier is used to create the list of sites,\\r\\n *      - size (w, h), defines an internal coordinate system within a plot,\\r\\n *\\r\\n * @notice Since minting a plot requires at least 32 bytes of data and due to a significant\\r\\n *      amount of plots to be minted (about 100,000), pre-storing this data on-chain\\r\\n *      is not a viable option (2,000,000,000 of gas only to pay for the storage).\\r\\n *      Instead, we represent the whole land plot data collection on sale as a Merkle tree\\r\\n *      structure and store the root of the Merkle tree on-chain.\\r\\n *      To buy a particular plot, the buyer must know the entire collection and be able to\\r\\n *      generate and present the Merkle proof for this particular plot.\\r\\n *\\r\\n * @notice The input data is a collection of `PlotData` structures; the Merkle tree is built out\\r\\n *      from this collection, and the tree root is stored on the contract by the data manager.\\r\\n *      When buying a plot, the buyer also specifies the Merkle proof for a plot data to mint.\\r\\n *\\r\\n * @notice Layer 2 support (ex. IMX minting)\\r\\n *      Sale contract supports both L1 and L2 sales.\\r\\n *      L1 sale mints the token in layer 1 network (Ethereum mainnet) immediately,\\r\\n *      in the same transaction it is bought.\\r\\n *      L2 sale doesn't mint the token and just emits an event containing token metadata and owner;\\r\\n *      this event is then picked by the off-chain process (daemon) which mints the token in a\\r\\n *      layer 2 network (IMX, https://www.immutable.com/)\\r\\n *\\r\\n * @dev A note on randomness\\r\\n *      Current implementation uses \\\"on-chain randomness\\\" to mint a land plot, which is calculated\\r\\n *      as a keccak256 hash of some available parameters, like token ID, buyer address, and block\\r\\n *      timestamp.\\r\\n *      This can be relatively easy manipulated not only by miners, but even by clients wrapping\\r\\n *      their transactions into the smart contract code when buying (calling a `buy` function).\\r\\n *      It is considered normal and acceptable from the security point of view since the value\\r\\n *      of such manipulation is low compared to the transaction cost.\\r\\n *      This situation can change, however, in the future sales when more information on the game\\r\\n *      is available, and when it becomes more clear how resource types and their positions\\r\\n *      affect the game mechanics, and can be used to benefit players.\\r\\n *\\r\\n * @dev A note on timestamps\\r\\n *      Current implementation uses uint32 to represent unix timestamp, and time intervals,\\r\\n *      it is not designed to be used after February 7, 2106, 06:28:15 GMT (unix time 0xFFFFFFFF)\\r\\n *\\r\\n * @dev Merkle proof verification is based on OpenZeppelin implementation, see\\r\\n *      https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\ncontract LandSale is UpgradeableAccessControl {\\r\\n\\t// using ERC20.transfer wrapper from OpenZeppelin adopted SafeERC20\\r\\n\\tusing SafeERC20 for ERC20;\\r\\n\\t// Use Zeppelin MerkleProof Library to verify Merkle proofs\\r\\n\\tusing MerkleProof for bytes32[];\\r\\n\\t// Use Land Library to pack `PlotStore` struct to uint256\\r\\n\\tusing LandLib for LandLib.PlotStore;\\r\\n\\r\\n\\t/**\\r\\n\\t * @title Plot Data, a.k.a. Sale Data\\r\\n\\t *\\r\\n\\t * @notice Data structure modeling the data entry required to mint a single plot.\\r\\n\\t *      The contract is initialized with the Merkle root of the plots collection Merkle tree.\\r\\n\\t * @dev When buying a plot this data structure must be supplied together with the\\r\\n\\t *      Merkle proof allowing to verify the plot data belongs to the original collection.\\r\\n\\t */\\r\\n\\tstruct PlotData {\\r\\n\\t\\t/// @dev Token ID, defines a unique ID for the land plot used as ERC721 token ID\\r\\n\\t\\tuint32 tokenId;\\r\\n\\t\\t/// @dev Sequence ID, defines the time frame when the plot is available for sale\\r\\n\\t\\tuint32 sequenceId;\\r\\n\\t\\t/// @dev Region ID defines the region on the map in IZ\\r\\n\\t\\tuint8 regionId;\\r\\n\\t\\t/// @dev x-coordinate within the region plot\\r\\n\\t\\tuint16 x;\\r\\n\\t\\t/// @dev y-coordinate within the region plot\\r\\n\\t\\tuint16 y;\\r\\n\\t\\t/// @dev Tier ID defines land rarity and number of sites within the plot\\r\\n\\t\\tuint8 tierId;\\r\\n\\t\\t/// @dev Plot size, limits the (x, y) coordinates for the sites\\r\\n\\t\\tuint16 size;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Deployed LandERC721 token address to mint tokens of\\r\\n\\t *      (when they are bought via the sale)\\r\\n\\t */\\r\\n\\taddress public targetNftContract;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Deployed sILV (Escrowed Illuvium) ERC20 token address,\\r\\n\\t *      accepted as a payment option alongside ETH\\r\\n\\t * @dev Note: sILV ERC20 implementation never returns \\\"false\\\" on transfers,\\r\\n\\t *      it throws instead; we don't use any additional libraries like SafeERC20\\r\\n\\t *      to transfer sILV therefore\\r\\n\\t */\\r\\n\\taddress public sIlvContract;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Land Sale Price Oracle is used to convert the token prices from USD\\r\\n\\t *      to ETH or sILV (ILV)\\r\\n\\t */\\r\\n\\taddress public priceOracle;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Input data root, Merkle tree root for the collection of plot data elements,\\r\\n\\t *      available on sale\\r\\n\\t *\\r\\n\\t * @notice Merkle root effectively \\\"compresses\\\" the (potentially) huge collection of elements\\r\\n\\t *      and allows to store it in a single 256-bits storage slot on-chain\\r\\n\\t */\\r\\n\\tbytes32 public root;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sale start unix timestamp, scheduled sale start, the time when the sale\\r\\n\\t *      is scheduled to start, this is the time when sale activates,\\r\\n\\t *      the time when the first sequence sale starts, that is\\r\\n\\t *      when tokens of the first sequence become available on sale\\r\\n\\t * @dev The sale is active after the start (inclusive)\\r\\n\\t */\\r\\n\\tuint32 public saleStart;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sale end unix timestamp, this is the time when sale deactivates,\\r\\n\\t *      and tokens of the last sequence become unavailable\\r\\n\\t * @dev The sale is active before the end (exclusive)\\r\\n\\t */\\r\\n\\tuint32 public saleEnd;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Price halving time, the time required for a token price to reduce to the\\r\\n\\t *      half of its initial value\\r\\n\\t * @dev Defined in seconds\\r\\n\\t */\\r\\n\\tuint32 public halvingTime;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Time flow quantum, price update interval, used by the price calculation algorithm,\\r\\n\\t *      the time is rounded down to be multiple of quantum when performing price calculations;\\r\\n\\t *      setting this value to one effectively disables its effect;\\r\\n\\t * @dev Defined in seconds\\r\\n\\t */\\r\\n\\tuint32 public timeFlowQuantum;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sequence duration, time limit of how long a token / sequence can be available\\r\\n\\t *      for sale, first sequence stops selling at `saleStart + seqDuration`, second\\r\\n\\t *      sequence stops selling at `saleStart + seqOffset + seqDuration`, and so on\\r\\n\\t * @dev Defined in seconds\\r\\n\\t */\\r\\n\\tuint32 public seqDuration;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sequence start offset, first sequence starts selling at `saleStart`,\\r\\n\\t *      second sequence starts at `saleStart + seqOffset`, third at\\r\\n\\t *      `saleStart + 2 * seqOffset` and so on at `saleStart + n * seqOffset`,\\r\\n\\t *      where `n` is zero-based sequence ID\\r\\n\\t * @dev Defined in seconds\\r\\n\\t */\\r\\n\\tuint32 public seqOffset;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sale paused unix timestamp, the time when sale was paused,\\r\\n\\t *     non-zero value indicates that the sale is currently in a paused state\\r\\n\\t *     and is not operational\\r\\n\\t *\\r\\n\\t * @dev Pausing a sale effectively pauses \\\"own time\\\" of the sale, this is achieved\\r\\n\\t *     by tracking cumulative sale pause duration (see `pauseDuration`) and taking it\\r\\n\\t *     into account when evaluating current sale time, prices, sequences on sale, etc.\\r\\n\\t *\\r\\n\\t * @dev Erased (set to zero) when sale start time is modified (see initialization, `initialize()`)\\r\\n\\t */\\r\\n\\tuint32 public pausedAt;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Cumulative sale pause duration, total amount of time sale stayed in a paused state\\r\\n\\t *      since the last time sale start time was set (see initialization, `initialize()`)\\r\\n\\t *\\r\\n\\t * @dev Is increased only when sale is resumed back from the paused state, is not updated\\r\\n\\t *      when the sale is in a paused state\\r\\n\\t *\\r\\n\\t * @dev Defined in seconds\\r\\n\\t */\\r\\n\\tuint32 public pauseDuration;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Tier start prices, starting token price for each (zero based) Tier ID,\\r\\n\\t *      defined in ETH, can be converted into sILV via Uniswap/Sushiswap price oracle,\\r\\n\\t *      sILV price is defined to be equal to ILV price\\r\\n\\t */\\r\\n\\tuint96[] public startPrices;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sale beneficiary address, if set - used to send funds obtained from the sale;\\r\\n\\t *      If not set - contract accumulates the funds on its own deployed address\\r\\n\\t */\\r\\n\\taddress payable public beneficiary;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev A bitmap of minted tokens, required to support L2 sales:\\r\\n\\t *      when token is not minted in L1 we still need to track it was sold using this bitmap\\r\\n\\t *\\r\\n\\t * @dev Bitmap is stored as an array of uint256 data slots, each slot holding\\r\\n\\t *     256 bits of the entire bitmap.\\r\\n\\t *     An array itself is stored as a mapping with a zero-index integer key.\\r\\n\\t *     Each mapping entry represents the state of 256 tokens (each bit corresponds to a\\r\\n\\t *     single token)\\r\\n\\t *\\r\\n\\t * @dev For a token ID `n`,\\r\\n\\t *      the data slot index `i` is `n / 256`,\\r\\n\\t *      and bit index within a slot `j` is `n % 256`\\r\\n\\t */\\r\\n\\tmapping(uint256 => uint256) public mintedTokens;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables the L1 sale, buying tokens in L1 public function\\r\\n\\t *\\r\\n\\t * @notice Note: sale could be activated/deactivated by either sale manager, or\\r\\n\\t *      data manager, since these roles control sale params, and items on sale;\\r\\n\\t *      However both sale and data managers require some advanced knowledge about\\r\\n\\t *      the use of the functions they trigger, while switching the \\\"sale active\\\"\\r\\n\\t *      flag is very simple and can be done much more easier\\r\\n\\t *\\r\\n\\t * @dev Feature FEATURE_L1_SALE_ACTIVE must be enabled in order for\\r\\n\\t *      `buyL1()` function to be able to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_L1_SALE_ACTIVE = 0x0000_0001;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables the L2 sale, buying tokens in L2 public function\\r\\n\\t *\\r\\n\\t * @notice Note: sale could be activated/deactivated by either sale manager, or\\r\\n\\t *      data manager, since these roles control sale params, and items on sale;\\r\\n\\t *      However both sale and data managers require some advanced knowledge about\\r\\n\\t *      the use of the functions they trigger, while switching the \\\"sale active\\\"\\r\\n\\t *      flag is very simple and can be done much more easier\\r\\n\\t *\\r\\n\\t * @dev Feature FEATURE_L2_SALE_ACTIVE must be enabled in order for\\r\\n\\t *      `buyL2()` function to be able to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_L2_SALE_ACTIVE = 0x0000_0002;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Pause manager is responsible for:\\r\\n\\t *      - sale pausing (pausing/resuming the sale in case of emergency)\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_PAUSE_MANAGER allows sale pausing/resuming via pause() / resume()\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_PAUSE_MANAGER = 0x0001_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Data manager is responsible for supplying the valid input plot data collection\\r\\n\\t *      Merkle root which then can be used to mint tokens, meaning effectively,\\r\\n\\t *      that data manager may act as a minter on the target NFT contract\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_DATA_MANAGER allows setting the Merkle tree root via setInputDataRoot()\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_DATA_MANAGER = 0x0002_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Sale manager is responsible for:\\r\\n\\t *      - sale initialization (setting up sale timing/pricing parameters)\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_SALE_MANAGER allows sale initialization via initialize()\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_SALE_MANAGER = 0x0004_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice People do mistake and may send ERC20 tokens by mistake; since\\r\\n\\t *      NFT smart contract is not designed to accept and hold any ERC20 tokens,\\r\\n\\t *      it allows the rescue manager to \\\"rescue\\\" such lost tokens\\r\\n\\t *\\r\\n\\t * @notice Rescue manager is responsible for \\\"rescuing\\\" ERC20 tokens accidentally\\r\\n\\t *      sent to the smart contract, except the sILV which is a payment token\\r\\n\\t *      and can be withdrawn by the withdrawal manager only\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing any ERC20 tokens stored\\r\\n\\t *      on the smart contract balance\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0008_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Withdrawal manager is responsible for withdrawing funds obtained in sale\\r\\n\\t *      from the sale smart contract via pull/push mechanisms:\\r\\n\\t *      1) Pull: no pre-setup is required, withdrawal manager executes the\\r\\n\\t *         withdraw function periodically to withdraw funds\\r\\n\\t *      2) Push: withdrawal manager sets the `beneficiary` address which is used\\r\\n\\t *         by the smart contract to send funds to when users purchase land NFTs\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_WITHDRAWAL_MANAGER allows to set the `beneficiary` address via\\r\\n\\t *      - setBeneficiary()\\r\\n\\t * @dev Role ROLE_WITHDRAWAL_MANAGER allows pull withdrawals of funds:\\r\\n\\t *      - withdraw()\\r\\n\\t *      - withdrawTo()\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_WITHDRAWAL_MANAGER = 0x0010_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in setInputDataRoot()\\r\\n\\t *\\r\\n\\t * @param _by an address which executed the operation\\r\\n\\t * @param _root new Merkle root value\\r\\n\\t */\\r\\n\\tevent RootChanged(address indexed _by, bytes32 _root);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in initialize()\\r\\n\\t *\\r\\n\\t * @param _by an address which executed the operation\\r\\n\\t * @param _saleStart sale start unix timestamp, and first sequence start time\\r\\n\\t * @param _saleEnd sale end unix timestamp, should match with the last sequence end time\\r\\n\\t * @param _halvingTime price halving time (seconds), the time required for a token price\\r\\n\\t *      to reduce to the half of its initial value\\r\\n\\t * @param _timeFlowQuantum time flow quantum (seconds), price update interval, used by\\r\\n\\t *      the price calculation algorithm to update prices\\r\\n\\t * @param _seqDuration sequence duration (seconds), time limit of how long a token / sequence\\r\\n\\t *      can be available for sale\\r\\n\\t * @param _seqOffset sequence start offset (seconds), each sequence starts `_seqOffset`\\r\\n\\t *      later after the previous one\\r\\n\\t * @param _startPrices tier start prices (wei), starting token price for each (zero based) Tier ID\\r\\n\\t */\\r\\n\\tevent Initialized(\\r\\n\\t\\taddress indexed _by,\\r\\n\\t\\tuint32 _saleStart,\\r\\n\\t\\tuint32 _saleEnd,\\r\\n\\t\\tuint32 _halvingTime,\\r\\n\\t\\tuint32 _timeFlowQuantum,\\r\\n\\t\\tuint32 _seqDuration,\\r\\n\\t\\tuint32 _seqOffset,\\r\\n\\t\\tuint96[] _startPrices\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in pause()\\r\\n\\t *\\r\\n\\t * @param _by an address which executed the operation\\r\\n\\t * @param _pausedAt when the sale was paused (unix timestamp)\\r\\n\\t */\\r\\n\\tevent Paused(address indexed _by, uint32 _pausedAt);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in resume(), optionally in initialize() (only if sale start is changed)\\r\\n\\t *\\r\\n\\t * @param _by an address which executed the operation\\r\\n\\t * @param _pausedAt when the sale was paused (unix timestamp)\\r\\n\\t * @param _resumedAt when the sale was resumed (unix timestamp)\\r\\n\\t * @param _pauseDuration cumulative sale pause duration (seconds)\\r\\n\\t */\\r\\n\\tevent Resumed(address indexed _by, uint32 _pausedAt, uint32 _resumedAt, uint32 _pauseDuration);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in setBeneficiary\\r\\n\\t *\\r\\n\\t * @param _by an address which executed the operation\\r\\n\\t * @param _beneficiary new beneficiary address or zero-address\\r\\n\\t */\\r\\n\\tevent BeneficiaryUpdated(address indexed _by, address indexed _beneficiary);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in withdraw() and withdrawTo()\\r\\n\\t *\\r\\n\\t * @param _by an address which executed the operation\\r\\n\\t * @param _to an address which received the funds withdrawn\\r\\n\\t * @param _eth amount of ETH withdrawn (wei)\\r\\n\\t * @param _sIlv amount of sILV withdrawn (wei)\\r\\n\\t */\\r\\n\\tevent Withdrawn(address indexed _by, address indexed _to, uint256 _eth, uint256 _sIlv);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in buyL1()\\r\\n\\t *\\r\\n\\t * @param _by an address which had bought the plot\\r\\n\\t * @param _tokenId Token ID, part of the off-chain plot metadata supplied externally\\r\\n\\t * @param _sequenceId Sequence ID, part of the off-chain plot metadata supplied externally\\r\\n\\t * @param _plot on-chain plot metadata minted token, contains values copied from off-chain\\r\\n\\t *      plot metadata supplied externally, and generated values such as seed\\r\\n\\t * @param _eth ETH price of the lot (wei, non-zero)\\r\\n\\t * @param _sIlv sILV price of the lot (wei, zero if paid in ETH)\\r\\n\\t */\\r\\n\\tevent PlotBoughtL1(\\r\\n\\t\\taddress indexed _by,\\r\\n\\t\\tuint32 indexed _tokenId,\\r\\n\\t\\tuint32 indexed _sequenceId,\\r\\n\\t\\tLandLib.PlotStore _plot,\\r\\n\\t\\tuint256 _eth,\\r\\n\\t\\tuint256 _sIlv\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in buyL2()\\r\\n\\t *\\r\\n\\t * @param _by an address which had bought the plot\\r\\n\\t * @param _tokenId Token ID, part of the off-chain plot metadata supplied externally\\r\\n\\t * @param _sequenceId Sequence ID, part of the off-chain plot metadata supplied externally\\r\\n\\t * @param _plot on-chain plot metadata minted token, contains values copied from off-chain\\r\\n\\t *      plot metadata supplied externally, and generated values such as seed\\r\\n\\t * @param _eth ETH price of the lot (wei, non-zero)\\r\\n\\t * @param _sIlv sILV price of the lot (wei, zero if paid in ETH)\\r\\n\\t */\\r\\n\\tevent PlotBoughtL2(\\r\\n\\t\\taddress indexed _by,\\r\\n\\t\\tuint32 indexed _tokenId,\\r\\n\\t\\tuint32 indexed _sequenceId,\\r\\n\\t\\tLandLib.PlotStore _plot,\\r\\n\\t\\tuint256 _plotPacked,\\r\\n\\t\\tuint256 _eth,\\r\\n\\t\\tuint256 _sIlv\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev \\\"Constructor replacement\\\" for upgradeable, must be execute immediately after deployment\\r\\n\\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\\r\\n\\t *\\r\\n\\t * @dev Binds the sale smart contract instance to\\r\\n\\t *      1) the target NFT smart contract address to be used to mint tokens (Land ERC721),\\r\\n\\t *      2) sILV (Escrowed Illuvium) contract address to be used as one of the payment options\\r\\n\\t *      3) Price Oracle contract address to be used to determine ETH/sILV price\\r\\n\\t *\\r\\n\\t * @param _nft target NFT smart contract address\\r\\n\\t * @param _sIlv sILV (Escrowed Illuvium) contract address\\r\\n\\t * @param _oracle price oracle contract address\\r\\n\\t */\\r\\n\\tfunction postConstruct(address _nft, address _sIlv, address _oracle) public virtual initializer {\\r\\n\\t\\t// verify the inputs are set\\r\\n\\t\\trequire(_nft != address(0), \\\"target contract is not set\\\");\\r\\n\\t\\trequire(_sIlv != address(0), \\\"sILV contract is not set\\\");\\r\\n\\t\\trequire(_oracle != address(0), \\\"oracle address is not set\\\");\\r\\n\\r\\n\\t\\t// verify the inputs are valid smart contracts of the expected interfaces\\r\\n\\t\\trequire(\\r\\n\\t\\t\\tERC165(_nft).supportsInterface(type(ERC721).interfaceId)\\r\\n\\t\\t\\t&& ERC165(_nft).supportsInterface(type(MintableERC721).interfaceId)\\r\\n\\t\\t\\t&& ERC165(_nft).supportsInterface(type(LandERC721Metadata).interfaceId),\\r\\n\\t\\t\\t// note: ImmutableMintableERC721 is not required by the sale\\r\\n\\t\\t\\t\\\"unexpected target type\\\"\\r\\n\\t\\t);\\r\\n\\t\\trequire(ERC165(_oracle).supportsInterface(type(LandSalePriceOracle).interfaceId), \\\"unexpected oracle type\\\");\\r\\n\\t\\t// for the sILV ERC165 check is unavailable, but we can check some ERC20 functions manually\\r\\n\\t\\trequire(ERC20(_sIlv).balanceOf(address(this)) < type(uint256).max, \\\"sILV.balanceOf failure\\\");\\r\\n\\t\\trequire(ERC20(_sIlv).transfer(address(0x1), 0), \\\"sILV.transfer failure\\\");\\r\\n\\t\\trequire(ERC20(_sIlv).transferFrom(address(this), address(0x1), 0), \\\"sILV.transferFrom failure\\\");\\r\\n\\r\\n\\t\\t// assign the addresses\\r\\n\\t\\ttargetNftContract = _nft;\\r\\n\\t\\tsIlvContract = _sIlv;\\r\\n\\t\\tpriceOracle = _oracle;\\r\\n\\r\\n\\t\\t// execute all parent initializers in cascade\\r\\n\\t\\tUpgradeableAccessControl._postConstruct(msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev `startPrices` getter; the getters solidity creates for arrays\\r\\n\\t *      may be inconvenient to use if we need an entire array to be read\\r\\n\\t *\\r\\n\\t * @return `startPrices` as is - as an array of uint96\\r\\n\\t */\\r\\n\\tfunction getStartPrices() public view virtual returns (uint96[] memory) {\\r\\n\\t\\t// read `startPrices` array into memory and return\\r\\n\\t\\treturn startPrices;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Restricted access function to update input data root (Merkle tree root),\\r\\n\\t *       and to define, effectively, the tokens to be created by this smart contract\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_DATA_MANAGER` permission\\r\\n\\t *\\r\\n\\t * @param _root Merkle tree root for the input plot data collection\\r\\n\\t */\\r\\n\\tfunction setInputDataRoot(bytes32 _root) public virtual {\\r\\n\\t\\t// verify the access permission\\r\\n\\t\\trequire(isSenderInRole(ROLE_DATA_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// update input data Merkle tree root\\r\\n\\t\\troot = _root;\\r\\n\\r\\n\\t\\t// emit an event\\r\\n\\t\\temit RootChanged(msg.sender, _root);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Verifies the validity of a plot supplied (namely, if it's registered for the sale)\\r\\n\\t *      based on the Merkle root of the plot data collection (already defined on the contract),\\r\\n\\t *      and the Merkle proof supplied to validate the particular plot data\\r\\n\\t *\\r\\n\\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\\r\\n\\t *      and `keccak256` npm packages:\\r\\n\\t *      1. Hash the plot data collection elements via `web3.utils.soliditySha3`, making sure\\r\\n\\t *         the packing order and types are exactly as defined in `PlotData` struct\\r\\n\\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed collection, use `keccak256`\\r\\n\\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\\r\\n\\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\\r\\n\\t *      3. For any given plot data element the proof is constructed by hashing it (as in step 1),\\r\\n\\t *         and querying the MerkleTree for a proof, providing the hashed plot data element as a leaf\\r\\n\\t *\\r\\n\\t * @dev See also: https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof\\r\\n\\t *\\r\\n\\t * @param plotData plot data to verify\\r\\n\\t * @param proof Merkle proof for the plot data supplied\\r\\n\\t * @return true if plot is valid (belongs to registered collection), false otherwise\\r\\n\\t */\\r\\n\\tfunction isPlotValid(PlotData memory plotData, bytes32[] memory proof) public view virtual returns (bool) {\\r\\n\\t\\t// construct Merkle tree leaf from the inputs supplied\\r\\n\\t\\tbytes32 leaf = keccak256(abi.encodePacked(\\r\\n\\t\\t\\t\\tplotData.tokenId,\\r\\n\\t\\t\\t\\tplotData.sequenceId,\\r\\n\\t\\t\\t\\tplotData.regionId,\\r\\n\\t\\t\\t\\tplotData.x,\\r\\n\\t\\t\\t\\tplotData.y,\\r\\n\\t\\t\\t\\tplotData.tierId,\\r\\n\\t\\t\\t\\tplotData.size\\r\\n\\t\\t\\t));\\r\\n\\r\\n\\t\\t// verify the proof supplied, and return the verification result\\r\\n\\t\\treturn proof.verify(root, leaf);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Restricted access function to set up sale parameters, all at once,\\r\\n\\t *      or any subset of them\\r\\n\\t *\\r\\n\\t * @dev To skip parameter initialization, set it to `-1`,\\r\\n\\t *      that is a maximum value for unsigned integer of the corresponding type;\\r\\n\\t *      for `_startPrices` use a single array element with the `-1` value to skip\\r\\n\\t *\\r\\n\\t * @dev Example: following initialization will update only `_seqDuration` and `_seqOffset`,\\r\\n\\t *      leaving the rest of the fields unchanged\\r\\n\\t *      initialize(\\r\\n\\t *          0xFFFFFFFF, // `_saleStart` unchanged\\r\\n\\t *          0xFFFFFFFF, // `_saleEnd` unchanged\\r\\n\\t *          0xFFFFFFFF, // `_halvingTime` unchanged\\r\\n\\t *          21600,      // `_seqDuration` updated to 6 hours\\r\\n\\t *          3600,       // `_seqOffset` updated to 1 hour\\r\\n\\t *          [0xFFFFFFFFFFFFFFFFFFFFFFFF] // `_startPrices` unchanged\\r\\n\\t *      )\\r\\n\\t *\\r\\n\\t * @dev Sale start and end times should match with the number of sequences,\\r\\n\\t *      sequence duration and offset, if `n` is number of sequences, then\\r\\n\\t *      the following equation must hold:\\r\\n\\t *         `saleStart + (n - 1) * seqOffset + seqDuration = saleEnd`\\r\\n\\t *      Note: `n` is unknown to the sale contract and there is no way for it\\r\\n\\t *      to accurately validate other parameters of the equation above\\r\\n\\t *\\r\\n\\t * @dev Input params are not validated; to get an idea if these params look valid,\\r\\n\\t *      refer to `isActive() `function, and it's logic\\r\\n\\t *\\r\\n\\t * @dev Requires transaction sender to have `ROLE_SALE_MANAGER` role\\r\\n\\t *\\r\\n\\t * @param _saleStart sale start unix timestamp, and first sequence start time\\r\\n\\t * @param _saleEnd sale end unix timestamp, should match with the last sequence end time\\r\\n\\t * @param _halvingTime price halving time (seconds), the time required for a token price\\r\\n\\t *      to reduce to the half of its initial value\\r\\n\\t * @param _timeFlowQuantum time flow quantum (seconds), price update interval, used by\\r\\n\\t *      the price calculation algorithm to update prices\\r\\n\\t * @param _seqDuration sequence duration (seconds), time limit of how long a token / sequence\\r\\n\\t *      can be available for sale\\r\\n\\t * @param _seqOffset sequence start offset (seconds), each sequence starts `_seqOffset`\\r\\n\\t *      later after the previous one\\r\\n\\t * @param _startPrices tier start prices (wei), starting token price for each (zero based) Tier ID\\r\\n\\t */\\r\\n\\tfunction initialize(\\r\\n\\t\\tuint32 _saleStart,           // <<<--- keep type in sync with the body type(uint32).max !!!\\r\\n\\t\\tuint32 _saleEnd,             // <<<--- keep type in sync with the body type(uint32).max !!!\\r\\n\\t\\tuint32 _halvingTime,         // <<<--- keep type in sync with the body type(uint32).max !!!\\r\\n\\t\\tuint32 _timeFlowQuantum,     // <<<--- keep type in sync with the body type(uint32).max !!!\\r\\n\\t\\tuint32 _seqDuration,         // <<<--- keep type in sync with the body type(uint32).max !!!\\r\\n\\t\\tuint32 _seqOffset,           // <<<--- keep type in sync with the body type(uint32).max !!!\\r\\n\\t\\tuint96[] memory _startPrices // <<<--- keep type in sync with the body type(uint96).max !!!\\r\\n\\t) public virtual {\\r\\n\\t\\t// verify the access permission\\r\\n\\t\\trequire(isSenderInRole(ROLE_SALE_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// Note: no input validation at this stage, initial params state is invalid anyway,\\r\\n\\t\\t//       and we're not limiting sale manager to set these params back to this state\\r\\n\\r\\n\\t\\t// set/update sale parameters (allowing partial update)\\r\\n\\t\\t// 0xFFFFFFFF, 32 bits\\r\\n\\t\\tif(_saleStart != type(uint32).max) {\\r\\n\\t\\t\\t// update the sale start itself, and\\r\\n\\t\\t\\tsaleStart = _saleStart;\\r\\n\\r\\n\\t\\t\\t// if the sale is in paused state (non-zero `pausedAt`)\\r\\n\\t\\t\\tif(pausedAt != 0) {\\r\\n\\t\\t\\t\\t// emit an event first - to log old `pausedAt` value\\r\\n\\t\\t\\t\\temit Resumed(msg.sender, pausedAt, now32(), pauseDuration + now32() - pausedAt);\\r\\n\\r\\n\\t\\t\\t\\t// erase `pausedAt`, effectively resuming the sale\\r\\n\\t\\t\\t\\tpausedAt = 0;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// erase the cumulative pause duration\\r\\n\\t\\t\\tpauseDuration = 0;\\r\\n\\t\\t}\\r\\n\\t\\t// 0xFFFFFFFF, 32 bits\\r\\n\\t\\tif(_saleEnd != type(uint32).max) {\\r\\n\\t\\t\\tsaleEnd = _saleEnd;\\r\\n\\t\\t}\\r\\n\\t\\t// 0xFFFFFFFF, 32 bits\\r\\n\\t\\tif(_halvingTime != type(uint32).max) {\\r\\n\\t\\t\\thalvingTime = _halvingTime;\\r\\n\\t\\t}\\r\\n\\t\\t// 0xFFFFFFFF, 32 bits\\r\\n\\t\\tif(_timeFlowQuantum != type(uint32).max) {\\r\\n\\t\\t\\ttimeFlowQuantum = _timeFlowQuantum;\\r\\n\\t\\t}\\r\\n\\t\\t// 0xFFFFFFFF, 32 bits\\r\\n\\t\\tif(_seqDuration != type(uint32).max) {\\r\\n\\t\\t\\tseqDuration = _seqDuration;\\r\\n\\t\\t}\\r\\n\\t\\t// 0xFFFFFFFF, 32 bits\\r\\n\\t\\tif(_seqOffset != type(uint32).max) {\\r\\n\\t\\t\\tseqOffset = _seqOffset;\\r\\n\\t\\t}\\r\\n\\t\\t// 0xFFFFFFFFFFFFFFFFFFFFFFFF, 96 bits\\r\\n\\t\\tif(_startPrices.length != 1 || _startPrices[0] != type(uint96).max) {\\r\\n\\t\\t\\tstartPrices = _startPrices;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// emit an event\\r\\n\\t\\temit Initialized(msg.sender, saleStart, saleEnd, halvingTime, timeFlowQuantum, seqDuration, seqOffset, startPrices);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Verifies if sale is in the active state, meaning that it is properly\\r\\n\\t *      initialized with the sale start/end times, sequence params, etc., and\\r\\n\\t *      that the current time is within the sale start/end bounds\\r\\n\\t *\\r\\n\\t * @notice Doesn't check if the plot data Merkle root `root` is set or not;\\r\\n\\t *      active sale state doesn't guarantee that an item can be actually bought\\r\\n\\t *\\r\\n\\t * @dev The sale is defined as active if all of the below conditions hold:\\r\\n\\t *      - sale start is now or in the past\\r\\n\\t *      - sale end is in the future\\r\\n\\t *      - halving time is not zero\\r\\n\\t *      - sequence duration is not zero\\r\\n\\t *      - there is at least one starting price set (zero price is valid)\\r\\n\\t *\\r\\n\\t * @return true if sale is active, false otherwise\\r\\n\\t */\\r\\n\\tfunction isActive() public view virtual returns (bool) {\\r\\n\\t\\t// calculate sale state based on the internal sale params state and return\\r\\n\\t\\treturn pausedAt == 0\\r\\n\\t\\t\\t&& saleStart <= ownTime()\\r\\n\\t\\t\\t&& ownTime() < saleEnd\\r\\n\\t\\t\\t&& halvingTime > 0\\r\\n\\t\\t\\t&& timeFlowQuantum > 0\\r\\n\\t\\t\\t&& seqDuration > 0\\r\\n\\t\\t\\t&& startPrices.length > 0;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Restricted access function to pause running sale in case of emergency\\r\\n\\t *\\r\\n\\t * @dev Pausing/resuming doesn't affect sale \\\"own time\\\" and allows to resume the\\r\\n\\t *      sale process without \\\"loosing\\\" any items due to the time passed when paused\\r\\n\\t *\\r\\n\\t * @dev The sale is resumed using `resume()` function\\r\\n\\t *\\r\\n\\t * @dev Requires transaction sender to have `ROLE_PAUSE_MANAGER` role\\r\\n\\t */\\r\\n\\tfunction pause() public virtual {\\r\\n\\t\\t// check the access permission\\r\\n\\t\\trequire(isSenderInRole(ROLE_PAUSE_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// check if sale is not in the paused state already\\r\\n\\t\\trequire(pausedAt == 0, \\\"already paused\\\");\\r\\n\\r\\n\\t\\t// do the pause, save the paused timestamp\\r\\n\\t\\t// note for tests: never set time to zero in tests\\r\\n\\t\\tpausedAt = now32();\\r\\n\\r\\n\\t\\t// emit an event\\r\\n\\t\\temit Paused(msg.sender, now32());\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Restricted access function to resume previously paused sale\\r\\n\\t *\\r\\n\\t * @dev Pausing/resuming doesn't affect sale \\\"own time\\\" and allows to resume the\\r\\n\\t *      sale process without \\\"loosing\\\" any items due to the time passed when paused\\r\\n\\t *\\r\\n\\t * @dev Resuming the sale before it is scheduled to start doesn't have any effect\\r\\n\\t *      on the sale flow, and doesn't delay the sale start\\r\\n\\t *\\r\\n\\t * @dev Resuming the sale which was paused before the scheduled start delays the sale,\\r\\n\\t *      and moves scheduled sale start by the amount of time it was paused after the\\r\\n\\t *      original scheduled start\\r\\n\\t *\\r\\n\\t * @dev The sale is paused using `pause()` function\\r\\n\\t *\\r\\n\\t * @dev Requires transaction sender to have `ROLE_PAUSE_MANAGER` role\\r\\n\\t */\\r\\n\\tfunction resume() public virtual {\\r\\n\\t\\t// check the access permission\\r\\n\\t\\trequire(isSenderInRole(ROLE_PAUSE_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// check if the sale is in a paused state\\r\\n\\t\\trequire(pausedAt != 0, \\\"already running\\\");\\r\\n\\r\\n\\t\\t// if sale has already started\\r\\n\\t\\tif(now32() > saleStart) {\\r\\n\\t\\t\\t// update the cumulative sale pause duration, taking into account that\\r\\n\\t\\t\\t// if sale was paused before its planned start, pause duration counts only from the start\\r\\n\\t\\t\\t// note: we deliberately subtract `pausedAt` from the current time first\\r\\n\\t\\t\\t// to fail fast if `pausedAt` is bigger than current time (this can never happen by design)\\r\\n\\t\\t\\tpauseDuration += now32() - (pausedAt < saleStart? saleStart: pausedAt);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// emit an event first - to log old `pausedAt` value\\r\\n\\t\\temit Resumed(msg.sender, pausedAt, now32(), pauseDuration);\\r\\n\\r\\n\\t\\t// do the resume, erase the paused timestamp\\r\\n\\t\\tpausedAt = 0;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Restricted access function to update the sale beneficiary address, the address\\r\\n\\t *      can be set, updated, or \\\"unset\\\" (deleted, set to zero)\\r\\n\\t *\\r\\n\\t * @dev Setting the address to non-zero value effectively activates funds withdrawal\\r\\n\\t *      mechanism via the push pattern\\r\\n\\t *\\r\\n\\t * @dev Setting the address to zero value effectively deactivates funds withdrawal\\r\\n\\t *      mechanism via the push pattern (pull mechanism can be used instead)\\r\\n\\t */\\r\\n\\tfunction setBeneficiary(address payable _beneficiary) public virtual {\\r\\n\\t\\t// check the access permission\\r\\n\\t\\trequire(isSenderInRole(ROLE_WITHDRAWAL_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// update the beneficiary address\\r\\n\\t\\tbeneficiary = _beneficiary;\\r\\n\\r\\n\\t\\t// emit an event\\r\\n\\t\\temit BeneficiaryUpdated(msg.sender, _beneficiary);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Restricted access function to withdraw funds on the contract balance,\\r\\n\\t *      sends funds back to transaction sender\\r\\n\\t *\\r\\n\\t * @dev Withdraws both ETH and sILV balances if `_ethOnly` is set to false,\\r\\n\\t *      withdraws only ETH is `_ethOnly` is set to true\\r\\n\\t *\\r\\n\\t * @param _ethOnly a flag indicating whether to withdraw sILV or not\\r\\n\\t */\\r\\n\\tfunction withdraw(bool _ethOnly) public virtual {\\r\\n\\t\\t// delegate to `withdrawTo`\\r\\n\\t\\twithdrawTo(payable(msg.sender), _ethOnly);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Restricted access function to withdraw funds on the contract balance,\\r\\n\\t *      sends funds to the address specified\\r\\n\\t *\\r\\n\\t * @dev Withdraws both ETH and sILV balances if `_ethOnly` is set to false,\\r\\n\\t *      withdraws only ETH is `_ethOnly` is set to true\\r\\n\\t *\\r\\n\\t * @param _to an address to send funds to\\r\\n\\t * @param _ethOnly a flag indicating whether to withdraw sILV or not\\r\\n\\t */\\r\\n\\tfunction withdrawTo(address payable _to, bool _ethOnly) public virtual {\\r\\n\\t\\t// check the access permission\\r\\n\\t\\trequire(isSenderInRole(ROLE_WITHDRAWAL_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// verify withdrawal address is set\\r\\n\\t\\trequire(_to != address(0), \\\"recipient not set\\\");\\r\\n\\r\\n\\t\\t// ETH value to send\\r\\n\\t\\tuint256 ethBalance = address(this).balance;\\r\\n\\r\\n\\t\\t// sILV value to send\\r\\n\\t\\tuint256 sIlvBalance = _ethOnly? 0: ERC20(sIlvContract).balanceOf(address(this));\\r\\n\\r\\n\\t\\t// verify there is a balance to send\\r\\n\\t\\trequire(ethBalance > 0 || sIlvBalance > 0, \\\"zero balance\\\");\\r\\n\\r\\n\\t\\t// if there is ETH to send\\r\\n\\t\\tif(ethBalance > 0) {\\r\\n\\t\\t\\t// send the entire balance to the address specified\\r\\n\\t\\t\\t_to.transfer(ethBalance);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// if there is sILV to send\\r\\n\\t\\tif(sIlvBalance > 0) {\\r\\n\\t\\t\\t// send the entire balance to the address specified\\r\\n\\t\\t\\tERC20(sIlvContract).transfer(_to, sIlvBalance);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// emit en event\\r\\n\\t\\temit Withdrawn(msg.sender, _to, ethBalance, sIlvBalance);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Restricted access function to rescue accidentally sent ERC20 tokens,\\r\\n\\t *      the tokens are rescued via `transfer` function call on the\\r\\n\\t *      contract address specified and with the parameters specified:\\r\\n\\t *      `_contract.transfer(_to, _value)`\\r\\n\\t *\\r\\n\\t * @dev Doesn't allow to rescue sILV tokens, use withdraw/withdrawTo instead\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\\r\\n\\t *\\r\\n\\t * @param _contract smart contract address to execute `transfer` function on\\r\\n\\t * @param _to to address in `transfer(_to, _value)`\\r\\n\\t * @param _value value to transfer in `transfer(_to, _value)`\\r\\n\\t */\\r\\n\\tfunction rescueErc20(address _contract, address _to, uint256 _value) public virtual {\\r\\n\\t\\t// verify the access permission\\r\\n\\t\\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// verify rescue manager is not trying to withdraw sILV:\\r\\n\\t\\t// we have a withdrawal manager to help with that\\r\\n\\t\\trequire(_contract != sIlvContract, \\\"sILV access denied\\\");\\r\\n\\r\\n\\t\\t// perform the transfer as requested, without any checks\\r\\n\\t\\tERC20(_contract).safeTransfer(_to, _value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Determines the dutch auction price value for a token in a given\\r\\n\\t *      sequence `sequenceId`, given tier `tierId`, now (block.timestamp)\\r\\n\\t *\\r\\n\\t * @dev Adjusts current time for the sale pause duration `pauseDuration`, using\\r\\n\\t *      own time `ownTime()`\\r\\n\\t *\\r\\n\\t * @dev Throws if `now` is outside the [saleStart, saleEnd + pauseDuration) bounds,\\r\\n\\t *      or if it is outside the sequence bounds (sequence lasts for `seqDuration`),\\r\\n\\t *      or if the tier specified is invalid (no starting price is defined for it)\\r\\n\\t *\\r\\n\\t * @param sequenceId ID of the sequence token is sold in\\r\\n\\t * @param tierId ID of the tier token belongs to (defines token rarity)\\r\\n\\t * @return current price of the token specified\\r\\n\\t */\\r\\n\\tfunction tokenPriceNow(uint32 sequenceId, uint16 tierId) public view virtual returns (uint256) {\\r\\n\\t\\t// delegate to `tokenPriceAt` using adjusted current time as `t`\\r\\n\\t\\treturn tokenPriceAt(sequenceId, tierId, ownTime());\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Determines the dutch auction price value for a token in a given\\r\\n\\t *      sequence `sequenceId`, given tier `tierId`, at a given time `t` (own time)\\r\\n\\t *\\r\\n\\t * @dev Throws if `t` is outside the [saleStart, saleEnd) bounds,\\r\\n\\t *      or if it is outside the sequence bounds (sequence lasts for `seqDuration`),\\r\\n\\t *      or if the tier specified is invalid (no starting price is defined for it)\\r\\n\\t *\\r\\n\\t * @param sequenceId ID of the sequence token is sold in\\r\\n\\t * @param tierId ID of the tier token belongs to (defines token rarity)\\r\\n\\t * @param t unix timestamp of interest, time to evaluate the price at (own time)\\r\\n\\t * @return price of the token specified at some unix timestamp `t` (own time)\\r\\n\\t */\\r\\n\\tfunction tokenPriceAt(uint32 sequenceId, uint16 tierId, uint32 t) public view virtual returns (uint256) {\\r\\n\\t\\t// calculate sequence sale start\\r\\n\\t\\tuint32 seqStart = saleStart + sequenceId * seqOffset;\\r\\n\\t\\t// calculate sequence sale end\\r\\n\\t\\tuint32 seqEnd = seqStart + seqDuration;\\r\\n\\r\\n\\t\\t// verify `t` is in a reasonable bounds [saleStart, saleEnd)\\r\\n\\t\\trequire(saleStart <= t && t < saleEnd, \\\"invalid time\\\");\\r\\n\\r\\n\\t\\t// ensure `t` is in `[seqStart, seqEnd)` bounds; no price exists outside the bounds\\r\\n\\t\\trequire(seqStart <= t && t < seqEnd, \\\"invalid sequence\\\");\\r\\n\\r\\n\\t\\t// verify the initial price is set (initialized) for the tier specified\\r\\n\\t\\trequire(startPrices.length > tierId, \\\"invalid tier\\\");\\r\\n\\r\\n\\t\\t// convert `t` from \\\"absolute\\\" to \\\"relative\\\" (within a sequence)\\r\\n\\t\\tt -= seqStart;\\r\\n\\r\\n\\t\\t// apply the time flow quantum: make `t` multiple of quantum\\r\\n\\t\\tt /= timeFlowQuantum;\\r\\n\\t\\tt *= timeFlowQuantum;\\r\\n\\r\\n\\t\\t// calculate the price based on the derived params - delegate to `price`\\r\\n\\t\\treturn price(startPrices[tierId], halvingTime, t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Calculates dutch auction price after the time of interest has passed since\\r\\n\\t *      the auction has started\\r\\n\\t *\\r\\n\\t * @dev The price is assumed to drop exponentially, according to formula:\\r\\n\\t *      p(t) = p0 * 2^(-t/t0)\\r\\n\\t *      The price halves every t0 seconds passed from the start of the auction\\r\\n\\t *\\r\\n\\t * @dev Calculates with the precision p0 * 2^(-1/256), meaning the price updates\\r\\n\\t *      every t0 / 256 seconds\\r\\n\\t *      For example, if halving time is one hour, the price updates every 14 seconds\\r\\n\\t *\\r\\n\\t * @param p0 initial price (wei)\\r\\n\\t * @param t0 price halving time (seconds)\\r\\n\\t * @param t elapsed time (seconds)\\r\\n\\t * @return price after `t` seconds passed, `p = p0 * 2^(-t/t0)`\\r\\n\\t */\\r\\n\\tfunction price(uint256 p0, uint256 t0, uint256 t) public pure virtual returns (uint256) {\\r\\n\\t\\t// perform very rough price estimation first by halving\\r\\n\\t\\t// the price as many times as many t0 intervals have passed\\r\\n\\t\\tuint256 p = p0 >> t / t0;\\r\\n\\r\\n\\t\\t// if price halves (decreases by 2 times) every t0 seconds passed,\\r\\n\\t\\t// than every t0 / 2 seconds passed it decreases by sqrt(2) times (2 ^ (1/2)),\\r\\n\\t\\t// every t0 / 2 seconds passed it decreases 2 ^ (1/4) times, and so on\\r\\n\\r\\n\\t\\t// we've prepared a small cheat sheet here with the pre-calculated values for\\r\\n\\t\\t// the roots of the degree of two 2 ^ (1 / 2 ^ n)\\r\\n\\t\\t// for the resulting function to be monotonically decreasing, it is required\\r\\n\\t\\t// that (2 ^ (1 / 2 ^ n)) ^ 2 <= 2 ^ (1 / 2 ^ (n - 1))\\r\\n\\t\\t// to emulate floating point values, we present them as nominator/denominator\\r\\n\\t\\t// roots of the degree of two nominators:\\r\\n\\t\\tuint56[8] memory sqrNominator = [\\r\\n\\t\\t\\t1_414213562373095, // 2 ^ (1/2)\\r\\n\\t\\t\\t1_189207115002721, // 2 ^ (1/4)\\r\\n\\t\\t\\t1_090507732665257, // 2 ^ (1/8) *\\r\\n\\t\\t\\t1_044273782427413, // 2 ^ (1/16) *\\r\\n\\t\\t\\t1_021897148654116, // 2 ^ (1/32) *\\r\\n\\t\\t\\t1_010889286051700, // 2 ^ (1/64)\\r\\n\\t\\t\\t1_005429901112802, // 2 ^ (1/128) *\\r\\n\\t\\t\\t1_002711275050202  // 2 ^ (1/256)\\r\\n\\t\\t];\\r\\n\\t\\t// roots of the degree of two denominator:\\r\\n\\t\\tuint56 sqrDenominator =\\r\\n\\t\\t\\t1_000000000000000;\\r\\n\\r\\n\\t\\t// perform up to 8 iterations to increase the precision of the calculation\\r\\n\\t\\t// dividing the halving time `t0` by two on every step\\r\\n\\t\\tfor(uint8 i = 0; i < sqrNominator.length && t > 0 && t0 > 1; i++) {\\r\\n\\t\\t\\t// determine the reminder of `t` which requires the precision increase\\r\\n\\t\\t\\tt %= t0;\\r\\n\\t\\t\\t// halve the `t0` for the next iteration step\\r\\n\\t\\t\\tt0 /= 2;\\r\\n\\t\\t\\t// if elapsed time `t` is big enough and is \\\"visible\\\" with `t0` precision\\r\\n\\t\\t\\tif(t >= t0) {\\r\\n\\t\\t\\t\\t// decrease the price accordingly to the roots of the degree of two table\\r\\n\\t\\t\\t\\tp = p * sqrDenominator / sqrNominator[i];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// if elapsed time `t` is big enough and is \\\"visible\\\" with `2 * t0` precision\\r\\n\\t\\t\\t// (this is possible sometimes due to rounding errors when halving `t0`)\\r\\n\\t\\t\\tif(t >= 2 * t0) {\\r\\n\\t\\t\\t\\t// decrease the price again accordingly to the roots of the degree of two table\\r\\n\\t\\t\\t\\tp = p * sqrDenominator / sqrNominator[i];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// return the result\\r\\n\\t\\treturn p;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Sells a plot of land (Land ERC721 token) from the sale to executor.\\r\\n\\t *      Executor must supply the metadata for the land plot and a Merkle tree proof\\r\\n\\t *      for the metadata supplied.\\r\\n\\t *\\r\\n\\t * @notice Mints the token bought immediately on L1 as part of the buy transaction\\r\\n\\t *\\r\\n\\t * @notice Metadata for all the plots is stored off-chain and is publicly available\\r\\n\\t *      to buy plots and to generate Merkle proofs\\r\\n\\t *\\r\\n\\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\\r\\n\\t *      and `keccak256` npm packages:\\r\\n\\t *      1. Hash the plot data collection elements via `web3.utils.soliditySha3`, making sure\\r\\n\\t *         the packing order and types are exactly as defined in `PlotData` struct\\r\\n\\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed collection, use `keccak256`\\r\\n\\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\\r\\n\\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\\r\\n\\t *      3. For any given plot data element the proof is constructed by hashing it (as in step 1),\\r\\n\\t *         and querying the MerkleTree for a proof, providing the hashed plot data element as a leaf\\r\\n\\t *\\r\\n\\t * @dev Requires FEATURE_L1_SALE_ACTIVE feature to be enabled\\r\\n\\t *\\r\\n\\t * @dev Throws if current time is outside the [saleStart, saleEnd + pauseDuration) bounds,\\r\\n\\t *      or if it is outside the sequence bounds (sequence lasts for `seqDuration`),\\r\\n\\t *      or if the tier specified is invalid (no starting price is defined for it)\\r\\n\\t *\\r\\n\\t * @dev See also: https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof\\r\\n\\t *\\r\\n\\t * @param plotData plot data to buy\\r\\n\\t * @param proof Merkle proof for the plot data supplied\\r\\n\\t */\\r\\n\\tfunction buyL1(PlotData memory plotData, bytes32[] memory proof) public virtual payable {\\r\\n\\t\\t// verify L1 sale is active\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_L1_SALE_ACTIVE), \\\"L1 sale disabled\\\");\\r\\n\\r\\n\\t\\t// execute all the validations, process payment, construct the land plot\\r\\n\\t\\t(LandLib.PlotStore memory plot, uint256 pEth, uint256 pIlv) = _buy(plotData, proof);\\r\\n\\r\\n\\t\\t// mint the token in L1 with metadata - delegate to `mintWithMetadata`\\r\\n\\t\\tLandERC721Metadata(targetNftContract).mintWithMetadata(msg.sender, plotData.tokenId, plot);\\r\\n\\r\\n\\t\\t// emit an event\\r\\n\\t\\temit PlotBoughtL1(msg.sender, plotData.tokenId, plotData.sequenceId, plot, pEth, pIlv);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Sells a plot of land (Land ERC721 token) from the sale to executor.\\r\\n\\t *      Executor must supply the metadata for the land plot and a Merkle tree proof\\r\\n\\t *      for the metadata supplied.\\r\\n\\t *\\r\\n\\t * @notice Doesn't mint the token bought immediately on L1 as part of the buy transaction,\\r\\n\\t *      only `PlotBoughtL2` event is emitted instead, which is picked by off-chain process\\r\\n\\t *      and then minted in L2\\r\\n\\t *\\r\\n\\t * @notice Metadata for all the plots is stored off-chain and is publicly available\\r\\n\\t *      to buy plots and to generate Merkle proofs\\r\\n\\t *\\r\\n\\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\\r\\n\\t *      and `keccak256` npm packages:\\r\\n\\t *      1. Hash the plot data collection elements via `web3.utils.soliditySha3`, making sure\\r\\n\\t *         the packing order and types are exactly as defined in `PlotData` struct\\r\\n\\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed collection, use `keccak256`\\r\\n\\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\\r\\n\\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\\r\\n\\t *      3. For any given plot data element the proof is constructed by hashing it (as in step 1),\\r\\n\\t *         and querying the MerkleTree for a proof, providing the hashed plot data element as a leaf\\r\\n\\t *\\r\\n\\t * @dev Requires FEATURE_L2_SALE_ACTIVE feature to be enabled\\r\\n\\t *\\r\\n\\t * @dev Throws if current time is outside the [saleStart, saleEnd + pauseDuration) bounds,\\r\\n\\t *      or if it is outside the sequence bounds (sequence lasts for `seqDuration`),\\r\\n\\t *      or if the tier specified is invalid (no starting price is defined for it)\\r\\n\\t *\\r\\n\\t * @dev See also: https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof\\r\\n\\t *\\r\\n\\t * @param plotData plot data to buy\\r\\n\\t * @param proof Merkle proof for the plot data supplied\\r\\n\\t */\\r\\n\\tfunction buyL2(PlotData memory plotData, bytes32[] memory proof) public virtual payable {\\r\\n\\t\\t// verify L2 sale is active\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_L2_SALE_ACTIVE), \\\"L2 sale disabled\\\");\\r\\n\\r\\n\\t\\t// buying in L2 requires EOA buyer, otherwise we cannot guarantee L2 mint:\\r\\n\\t\\t// an address which doesn't have private key cannot be registered with IMX\\r\\n\\t\\t// note: should be used with care, see https://github.com/ethereum/solidity/issues/683\\r\\n\\t\\trequire(msg.sender == tx.origin, \\\"L2 sale requires EOA\\\");\\r\\n\\r\\n\\t\\t// execute all the validations, process payment, construct the land plot\\r\\n\\t\\t(LandLib.PlotStore memory plot, uint256 pEth, uint256 pIlv) = _buy(plotData, proof);\\r\\n\\r\\n\\t\\t// note: token is not minted in L1, it will be picked by the off-chain process and minted in L2\\r\\n\\r\\n\\t\\t// emit an event\\r\\n\\t\\temit PlotBoughtL2(msg.sender, plotData.tokenId, plotData.sequenceId, plot, plot.pack(), pEth, pIlv);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary function used in both `buyL1` and `buyL2` functions to\\r\\n\\t *      - execute all the validations required,\\r\\n\\t *      - process payment,\\r\\n\\t *      - generate random seed to derive internal land structure (landmark and sites), and\\r\\n\\t *      - construct the `LandLib.PlotStore` data structure representing land plot bought\\r\\n\\t *\\r\\n\\t * @dev See `buyL1` and `buyL2` functions for more details\\r\\n\\t */\\r\\n\\tfunction _buy(\\r\\n\\t\\tPlotData memory plotData,\\r\\n\\t\\tbytes32[] memory proof\\r\\n\\t) internal virtual returns (\\r\\n\\t\\tLandLib.PlotStore memory plot,\\r\\n\\t\\tuint256 pEth,\\r\\n\\t\\tuint256 pIlv\\r\\n\\t) {\\r\\n\\t\\t// check if sale is active (and initialized)\\r\\n\\t\\trequire(isActive(), \\\"inactive sale\\\");\\r\\n\\r\\n\\t\\t// make sure plot data Merkle root was set (sale has something on sale)\\r\\n\\t\\trequire(root != 0x00, \\\"empty sale\\\");\\r\\n\\r\\n\\t\\t// verify the plot supplied is a valid/registered plot\\r\\n\\t\\trequire(isPlotValid(plotData, proof), \\\"invalid plot\\\");\\r\\n\\r\\n\\t\\t// verify if token is not yet minted and mark it as minted\\r\\n\\t\\t_markAsMinted(plotData.tokenId);\\r\\n\\r\\n\\t\\t// process the payment, save the ETH/sILV lot prices\\r\\n\\t\\t// a note on reentrancy: `_processPayment` may execute a fallback function on the smart contract buyer,\\r\\n\\t\\t// which would be the last execution statement inside `_processPayment`; this execution is reentrancy safe\\r\\n\\t\\t// not only because 2,300 transfer function is used, but primarily because all the \\\"give\\\" logic is executed after\\r\\n\\t\\t// external call, while the \\\"withhold\\\" logic is executed before the external call\\r\\n\\t\\t(pEth, pIlv) = _processPayment(plotData.sequenceId, plotData.tierId);\\r\\n\\r\\n\\t\\t// generate the random seed to derive internal land structure (landmark and sites)\\r\\n\\t\\t// hash the token ID, block timestamp and tx executor address to get a seed\\r\\n\\t\\tuint256 seed = uint256(keccak256(abi.encodePacked(plotData.tokenId, now32(), msg.sender)));\\r\\n\\r\\n\\t\\t// allocate the land plot metadata in memory\\r\\n\\t\\tplot = LandLib.PlotStore({\\r\\n\\t\\t\\tversion: 1,\\r\\n\\t\\t\\tregionId: plotData.regionId,\\r\\n\\t\\t\\tx: plotData.x,\\r\\n\\t\\t\\ty: plotData.y,\\r\\n\\t\\t\\ttierId: plotData.tierId,\\r\\n\\t\\t\\tsize: plotData.size,\\r\\n\\t\\t\\t// use generated seed to derive the Landmark Type ID, seed is considered \\\"used\\\" after that\\r\\n\\t\\t\\tlandmarkTypeId: LandLib.getLandmark(seed, plotData.tierId),\\r\\n\\t\\t\\telementSites: 3 * plotData.tierId,\\r\\n\\t\\t\\tfuelSites: plotData.tierId < 2? plotData.tierId: 3 * (plotData.tierId - 1),\\r\\n\\t\\t\\t// store low 160 bits of the \\\"used\\\" seed in the plot structure\\r\\n\\t\\t\\tseed: uint160(seed)\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\t// return the results as a tuple\\r\\n\\t\\treturn (plot, pEth, pIlv);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Verifies if token is minted and marks it as minted\\r\\n\\t *\\r\\n\\t * @dev Throws if token is already minted\\r\\n\\t *\\r\\n\\t * @param tokenId token ID to check and mark as minted\\r\\n\\t */\\r\\n\\tfunction _markAsMinted(uint256 tokenId) internal virtual {\\r\\n\\t\\t// calculate bit location to set in `mintedTokens`\\r\\n\\t\\t// slot index\\r\\n\\t\\tuint256 i = tokenId / 256;\\r\\n\\t\\t// bit location within the slot\\r\\n\\t\\tuint256 j = tokenId % 256;\\r\\n\\r\\n\\t\\t// verify bit `j` at slot `i` is not set\\r\\n\\t\\trequire(mintedTokens[i] >> j & 0x1 == 0, \\\"already minted\\\");\\r\\n\\t\\t// set bit `j` at slot index `i`\\r\\n\\t\\tmintedTokens[i] |= 0x1 << j;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Verifies if token is minted\\r\\n\\t *\\r\\n\\t * @param tokenId token ID to check if it's minted\\r\\n\\t */\\r\\n\\tfunction exists(uint256 tokenId) public view returns(bool) {\\r\\n\\t\\t// calculate bit location to check in `mintedTokens`\\r\\n\\t\\t// slot index: i = tokenId / 256\\r\\n\\t\\t// bit location within the slot: j = tokenId % 256\\r\\n\\r\\n\\t\\t// verify if bit `j` at slot `i` is set\\r\\n\\t\\treturn mintedTokens[tokenId / 256] >> tokenId % 256 & 0x1 == 1;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Charges tx executor in ETH/sILV, based on if ETH is supplied in the tx or not:\\r\\n\\t *      - if ETH is supplied, charges ETH only (throws if value supplied is not enough)\\r\\n\\t *      - if ETH is not supplied, charges sILV only (throws if sILV transfer fails)\\r\\n\\t *\\r\\n\\t * @dev Sends the change (for ETH payment - if any) back to transaction executor\\r\\n\\t *\\r\\n\\t * @dev Internal use only, throws on any payment failure\\r\\n\\t *\\r\\n\\t * @param sequenceId ID of the sequence token is sold in\\r\\n\\t * @param tierId ID of the tier token belongs to (defines token rarity)\\r\\n\\t */\\r\\n\\tfunction _processPayment(uint32 sequenceId, uint16 tierId) internal virtual returns (uint256 pEth, uint256 pIlv) {\\r\\n\\t\\t// determine current token price\\r\\n\\t\\tpEth = tokenPriceNow(sequenceId, tierId);\\r\\n\\r\\n\\t\\t// current land sale version doesn't support free tiers (ID: 0)\\r\\n\\t\\trequire(pEth != 0, \\\"unsupported tier\\\");\\r\\n\\r\\n\\t\\t// if ETH is not supplied, try to process sILV payment\\r\\n\\t\\tif(msg.value == 0) {\\r\\n\\t\\t\\t// convert price `p` to ILV/sILV\\r\\n\\t\\t\\tpIlv = LandSalePriceOracle(priceOracle).ethToIlv(pEth);\\r\\n\\r\\n\\t\\t\\t// LandSaleOracle implementation guarantees the price to have meaningful value,\\r\\n\\t\\t\\t// we still check \\\"close to zero\\\" price case to be extra safe\\r\\n\\t\\t\\trequire(pIlv > 1_000, \\\"price conversion error\\\");\\r\\n\\r\\n\\t\\t\\t// verify sender sILV balance and allowance to improve error messaging\\r\\n\\t\\t\\t// note: `transferFrom` would fail anyway, but sILV deployed into the mainnet\\r\\n\\t\\t\\t//       would just fail with \\\"arithmetic underflow\\\" without any hint for the cause\\r\\n\\t\\t\\trequire(ERC20(sIlvContract).balanceOf(msg.sender) >= pIlv, \\\"not enough funds available\\\");\\r\\n\\t\\t\\trequire(ERC20(sIlvContract).allowance(msg.sender, address(this)) >= pIlv, \\\"not enough funds supplied\\\");\\r\\n\\r\\n\\t\\t\\t// if beneficiary address is set, transfer the funds directly to the beneficiary\\r\\n\\t\\t\\t// otherwise, transfer the funds to the sale contract for the future pull withdrawal\\r\\n\\t\\t\\t// note: sILV.transferFrom always throws on failure and never returns `false`, however\\r\\n\\t\\t\\t//       to keep this code \\\"copy-paste safe\\\" we do require it to return `true` explicitly\\r\\n\\t\\t\\trequire(\\r\\n\\t\\t\\t\\tERC20(sIlvContract).transferFrom(msg.sender, beneficiary != address(0)? beneficiary: address(this), pIlv),\\r\\n\\t\\t\\t\\t\\\"ERC20 transfer failed\\\"\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t// no need for the change processing here since we're taking the amount ourselves\\r\\n\\r\\n\\t\\t\\t// return ETH price and sILV price actually charged\\r\\n\\t\\t\\treturn (pEth, pIlv);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// process ETH payment otherwise\\r\\n\\r\\n\\t\\t// ensure amount of ETH send\\r\\n\\t\\trequire(msg.value >= pEth, \\\"not enough ETH\\\");\\r\\n\\r\\n\\t\\t// if beneficiary address is set\\r\\n\\t\\tif(beneficiary != address(0)) {\\r\\n\\t\\t\\t// transfer the funds directly to the beneficiary\\r\\n\\t\\t\\t// note: beneficiary cannot be a smart contract with complex fallback function\\r\\n\\t\\t\\t//       by design, therefore we're using the 2,300 gas transfer\\r\\n\\t\\t\\tbeneficiary.transfer(pEth);\\r\\n\\t\\t}\\r\\n\\t\\t// if beneficiary address is not set, funds remain on\\r\\n\\t\\t// the sale contract address for the future pull withdrawal\\r\\n\\r\\n\\t\\t// if there is any change sent in the transaction\\r\\n\\t\\t// (most of the cases there will be a change since this is a dutch auction)\\r\\n\\t\\tif(msg.value > pEth) {\\r\\n\\t\\t\\t// transfer the change back to the transaction executor (buyer)\\r\\n\\t\\t\\t// note: calling the sale contract by other smart contracts with complex fallback functions\\r\\n\\t\\t\\t//       is not supported by design, therefore we're using the 2,300 gas transfer\\r\\n\\t\\t\\tpayable(msg.sender).transfer(msg.value - pEth);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// return the ETH price charged\\r\\n\\t\\treturn (pEth, 0);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Current time adjusted to count for the total duration sale was on pause\\r\\n\\t *\\r\\n\\t * @dev If sale operates in a normal way, without emergency pausing involved, this\\r\\n\\t *      is always equal to the current time;\\r\\n\\t *      if sale is paused for some period of time, this duration is subtracted, the\\r\\n\\t *      sale \\\"slows down\\\", and behaves like if it had a delayed start\\r\\n\\t *\\r\\n\\t * @return sale own time, current time adjusted by `pauseDuration`\\r\\n\\t */\\r\\n\\tfunction ownTime() public view virtual returns (uint32) {\\r\\n\\t\\t// subtract total pause duration from the current time (if any) and return\\r\\n\\t\\treturn now32() - pauseDuration;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Testing time-dependent functionality may be difficult;\\r\\n\\t *      we override time in the helper test smart contract (mock)\\r\\n\\t *\\r\\n\\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\\r\\n\\t */\\r\\n\\tfunction now32() public view virtual returns (uint32) {\\r\\n\\t\\t// return current block timestamp\\r\\n\\t\\treturn uint32(block.timestamp);\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC20Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @title EIP-20: ERC-20 Token Standard\\r\\n *\\r\\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\\r\\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\\r\\n *\\r\\n * @notice It provides functionalities like to transfer tokens from one account to another,\\r\\n *      to get the current token balance of an account and also the total supply of the token available on the network.\\r\\n *      Besides these it also has some other functionalities like to approve that an amount of\\r\\n *      token from an account can be spent by a third party account.\\r\\n *\\r\\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\\r\\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\\r\\n *\\r\\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\\r\\n * @notice See https://eips.ethereum.org/EIPS/eip-20\\r\\n */\\r\\ninterface ERC20 {\\r\\n\\t/**\\r\\n\\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\\r\\n\\t *\\r\\n\\t * @param from an address tokens were consumed from\\r\\n\\t * @param to an address tokens were sent to\\r\\n\\t * @param value number of tokens transferred\\r\\n\\t */\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in approve() to indicate an approval event happened\\r\\n\\t *\\r\\n\\t * @param owner an address which granted a permission to transfer\\r\\n\\t *      tokens on its behalf\\r\\n\\t * @param spender an address which received a permission to transfer\\r\\n\\t *      tokens on behalf of the owner `_owner`\\r\\n\\t * @param value amount of tokens granted to transfer on behalf\\r\\n\\t */\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t * @return name of the token (ex.: USD Coin)\\r\\n\\t */\\r\\n\\t// OPTIONAL - This method can be used to improve usability,\\r\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\r\\n\\t// function name() external view returns (string memory);\\r\\n\\r\\n\\t/**\\r\\n\\t * @return symbol of the token (ex.: USDC)\\r\\n\\t */\\r\\n\\t// OPTIONAL - This method can be used to improve usability,\\r\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\r\\n\\t// function symbol() external view returns (string memory);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the number of decimals used to get its user representation.\\r\\n\\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n\\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n\\t *\\r\\n\\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\\r\\n\\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n\\t *      overridden;\\r\\n\\t *\\r\\n\\t * @dev NOTE: This information is only used for _display_ purposes: it in\\r\\n\\t *      no way affects any of the arithmetic of the contract, including\\r\\n\\t *      {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n\\t *\\r\\n\\t * @return token decimals\\r\\n\\t */\\r\\n\\t// OPTIONAL - This method can be used to improve usability,\\r\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\r\\n\\t// function decimals() external view returns (uint8);\\r\\n\\r\\n\\t/**\\r\\n\\t * @return the amount of tokens in existence\\r\\n\\t */\\r\\n\\tfunction totalSupply() external view returns (uint256);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Gets the balance of a particular address\\r\\n\\t *\\r\\n\\t * @param _owner the address to query the the balance for\\r\\n\\t * @return balance an amount of tokens owned by the address specified\\r\\n\\t */\\r\\n\\tfunction balanceOf(address _owner) external view returns (uint256 balance);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens to an external address or a smart contract\\r\\n\\t *\\r\\n\\t * @dev Called by token owner (an address which has a\\r\\n\\t *      positive token balance tracked by this smart contract)\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * self address or\\r\\n\\t *          * smart contract which doesn't support ERC20\\r\\n\\t *\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be either an external address or a smart contract,\\r\\n\\t *      compliant with the ERC20 standard\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction transfer(address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\r\\n\\t *      to some other address `_to`\\r\\n\\t *\\r\\n\\t * @dev Called by token owner on his own or approved address,\\r\\n\\t *      an address approved earlier by token owner to\\r\\n\\t *      transfer some amount of tokens on its behalf\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * same as `_from` address (self transfer)\\r\\n\\t *          * smart contract which doesn't support ERC20\\r\\n\\t *\\r\\n\\t * @param _from token owner which approved caller (transaction sender)\\r\\n\\t *      to transfer `_value` of tokens on its behalf\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be either an external address or a smart contract,\\r\\n\\t *      compliant with the ERC20 standard\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Approves address called `_spender` to transfer some amount\\r\\n\\t *      of tokens on behalf of the owner (transaction sender)\\r\\n\\t *\\r\\n\\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\\r\\n\\t *\\r\\n\\t * @param _spender an address approved by the caller (token owner)\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\r\\n\\t *      transfer on behalf of the token owner\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction approve(address _spender, uint256 _value) external returns (bool success);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\\r\\n\\t *\\r\\n\\t * @dev A function to check an amount of tokens owner approved\\r\\n\\t *      to transfer on its behalf by some other address called \\\"spender\\\"\\r\\n\\t *\\r\\n\\t * @param _owner an address which approves transferring some tokens on its behalf\\r\\n\\t * @param _spender an address approved to transfer some tokens on behalf\\r\\n\\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\\r\\n\\t *      of token owner `_owner`\\r\\n\\t */\\r\\n\\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC721Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./ERC165Spec.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard\\r\\n *\\r\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\r\\n *\\r\\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\\r\\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\\r\\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\\r\\n *      For example, a payable function in this interface may be implemented as nonpayable\\r\\n *      (no state mutability specified) in implementing contract.\\r\\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\\r\\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\\r\\n *      we have removed all \\\"payable\\\" modifiers.\\r\\n *\\r\\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\\r\\n *\\r\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\r\\n */\\r\\ninterface ERC721 is ERC165 {\\r\\n\\t/// @dev This emits when ownership of any NFT changes by any mechanism.\\r\\n\\t///  This event emits when NFTs are created (`from` == 0) and destroyed\\r\\n\\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\\r\\n\\t///  may be created and assigned without emitting Transfer. At the time of\\r\\n\\t///  any transfer, the approved address for that NFT (if any) is reset to none.\\r\\n\\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\r\\n\\r\\n\\t/// @dev This emits when the approved address for an NFT is changed or\\r\\n\\t///  reaffirmed. The zero address indicates there is no approved address.\\r\\n\\t///  When a Transfer event emits, this also indicates that the approved\\r\\n\\t///  address for that NFT (if any) is reset to none.\\r\\n\\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\r\\n\\r\\n\\t/// @dev This emits when an operator is enabled or disabled for an owner.\\r\\n\\t///  The operator can manage all NFTs of the owner.\\r\\n\\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n\\t/// @notice Count all NFTs assigned to an owner\\r\\n\\t/// @dev NFTs assigned to the zero address are considered invalid, and this\\r\\n\\t///  function throws for queries about the zero address.\\r\\n\\t/// @param _owner An address for whom to query the balance\\r\\n\\t/// @return The number of NFTs owned by `_owner`, possibly zero\\r\\n\\tfunction balanceOf(address _owner) external view returns (uint256);\\r\\n\\r\\n\\t/// @notice Find the owner of an NFT\\r\\n\\t/// @dev NFTs assigned to zero address are considered invalid, and queries\\r\\n\\t///  about them do throw.\\r\\n\\t/// @param _tokenId The identifier for an NFT\\r\\n\\t/// @return The address of the owner of the NFT\\r\\n\\tfunction ownerOf(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\r\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n\\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\r\\n\\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t///  `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t/// @param _from The current owner of the NFT\\r\\n\\t/// @param _to The new owner\\r\\n\\t/// @param _tokenId The NFT to transfer\\r\\n\\t/// @param _data Additional data with no specified format, sent in call to `_to`\\r\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\\r\\n\\r\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\r\\n\\t/// @dev This works identically to the other function with an extra data parameter,\\r\\n\\t///  except this function just sets data to \\\"\\\".\\r\\n\\t/// @param _from The current owner of the NFT\\r\\n\\t/// @param _to The new owner\\r\\n\\t/// @param _tokenId The NFT to transfer\\r\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\r\\n\\r\\n\\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\r\\n\\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\r\\n\\t///  THEY MAY BE PERMANENTLY LOST\\r\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n\\t///  `_tokenId` is not a valid NFT.\\r\\n\\t/// @param _from The current owner of the NFT\\r\\n\\t/// @param _to The new owner\\r\\n\\t/// @param _tokenId The NFT to transfer\\r\\n\\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\r\\n\\r\\n\\t/// @notice Change or reaffirm the approved address for an NFT\\r\\n\\t/// @dev The zero address indicates there is no approved address.\\r\\n\\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\r\\n\\t///  operator of the current owner.\\r\\n\\t/// @param _approved The new approved NFT controller\\r\\n\\t/// @param _tokenId The NFT to approve\\r\\n\\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\\r\\n\\r\\n\\t/// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\r\\n\\t///  all of `msg.sender`'s assets\\r\\n\\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\\r\\n\\t///  multiple operators per owner.\\r\\n\\t/// @param _operator Address to add to the set of authorized operators\\r\\n\\t/// @param _approved True if the operator is approved, false to revoke approval\\r\\n\\tfunction setApprovalForAll(address _operator, bool _approved) external;\\r\\n\\r\\n\\t/// @notice Get the approved address for a single NFT\\r\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT.\\r\\n\\t/// @param _tokenId The NFT to find the approved address for\\r\\n\\t/// @return The approved address for this NFT, or the zero address if there is none\\r\\n\\tfunction getApproved(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n\\t/// @notice Query if an address is an authorized operator for another address\\r\\n\\t/// @param _owner The address that owns the NFTs\\r\\n\\t/// @param _operator The address that acts on behalf of the owner\\r\\n\\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\r\\n\\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\\r\\n}\\r\\n\\r\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\r\\ninterface ERC721TokenReceiver {\\r\\n\\t/// @notice Handle the receipt of an NFT\\r\\n\\t/// @dev The ERC721 smart contract calls this function on the recipient\\r\\n\\t///  after a `transfer`. This function MAY throw to revert and reject the\\r\\n\\t///  transfer. Return of other than the magic value MUST result in the\\r\\n\\t///  transaction being reverted.\\r\\n\\t///  Note: the contract address is always the message sender.\\r\\n\\t/// @param _operator The address which called `safeTransferFrom` function\\r\\n\\t/// @param _from The address which previously owned the token\\r\\n\\t/// @param _tokenId The NFT identifier which is being transferred\\r\\n\\t/// @param _data Additional data with no specified format\\r\\n\\t/// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n\\t///  unless throwing\\r\\n\\tfunction onERC721Received(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _from,\\r\\n\\t\\tuint256 _tokenId,\\r\\n\\t\\tbytes calldata _data\\r\\n\\t) external returns (bytes4);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n *\\r\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\r\\n *\\r\\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\\r\\n *\\r\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\r\\n */\\r\\ninterface ERC721Metadata is ERC721 {\\r\\n\\t/// @notice A descriptive name for a collection of NFTs in this contract\\r\\n\\tfunction name() external view returns (string memory _name);\\r\\n\\r\\n\\t/// @notice An abbreviated name for NFTs in this contract\\r\\n\\tfunction symbol() external view returns (string memory _symbol);\\r\\n\\r\\n\\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\r\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\r\\n\\t///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\r\\n\\t///  Metadata JSON Schema\\\".\\r\\n\\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\r\\n *\\r\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\r\\n *\\r\\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\\r\\n *\\r\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\r\\n */\\r\\ninterface ERC721Enumerable is ERC721 {\\r\\n\\t/// @notice Count NFTs tracked by this contract\\r\\n\\t/// @return A count of valid NFTs tracked by this contract, where each one of\\r\\n\\t///  them has an assigned and queryable owner not equal to the zero address\\r\\n\\tfunction totalSupply() external view returns (uint256);\\r\\n\\r\\n\\t/// @notice Enumerate valid NFTs\\r\\n\\t/// @dev Throws if `_index` >= `totalSupply()`.\\r\\n\\t/// @param _index A counter less than `totalSupply()`\\r\\n\\t/// @return The token identifier for the `_index`th NFT,\\r\\n\\t///  (sort order not specified)\\r\\n\\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\\r\\n\\r\\n\\t/// @notice Enumerate NFTs assigned to an owner\\r\\n\\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\r\\n\\t///  `_owner` is the zero address, representing invalid NFTs.\\r\\n\\t/// @param _owner An address where we are interested in NFTs owned by them\\r\\n\\t/// @param _index A counter less than `balanceOf(_owner)`\\r\\n\\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\r\\n\\t///   (sort order not specified)\\r\\n\\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC721SpecExt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @title Mintable ERC721 Extension\\r\\n *\\r\\n * @notice Defines mint capabilities for ERC721 tokens.\\r\\n *      This interface should be treated as a definition of what mintable means for ERC721\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\ninterface MintableERC721 {\\r\\n\\t/**\\r\\n\\t * @notice Checks if specified token exists\\r\\n\\t *\\r\\n\\t * @dev Returns whether the specified token ID has an ownership\\r\\n\\t *      information associated with it\\r\\n\\t *\\r\\n\\t * @param _tokenId ID of the token to query existence for\\r\\n\\t * @return whether the token exists (true - exists, false - doesn't exist)\\r\\n\\t */\\r\\n\\tfunction exists(uint256 _tokenId) external view returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new token with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for this token\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\r\\n\\t *      Prefer the use of `saveMint` instead of `mint`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t */\\r\\n\\tfunction mint(address _to, uint256 _tokenId) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new token with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for this token\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t */\\r\\n\\tfunction safeMint(address _to, uint256 _tokenId) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new token with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for this token\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\r\\n\\t */\\r\\n\\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Batch Mintable ERC721 Extension\\r\\n *\\r\\n * @notice Defines batch minting capabilities for ERC721 tokens.\\r\\n *      This interface should be treated as a definition of what mintable means for ERC721\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\ninterface BatchMintable {\\r\\n\\t/**\\r\\n\\t * @dev Creates new tokens starting with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for these tokens\\r\\n\\t *\\r\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\r\\n\\t *\\r\\n\\t * @dev n must be greater or equal 2: `n > 1`\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\r\\n\\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint tokens to\\r\\n\\t * @param _tokenId ID of the first token to mint\\r\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\r\\n\\t */\\r\\n\\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new tokens starting with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for these tokens\\r\\n\\t *\\r\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\r\\n\\t *\\r\\n\\t * @dev n must be greater or equal 2: `n > 1`\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\r\\n\\t */\\r\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new tokens starting with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for these tokens\\r\\n\\t *\\r\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\r\\n\\t *\\r\\n\\t * @dev n must be greater or equal 2: `n > 1`\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\r\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\r\\n\\t */\\r\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Burnable ERC721 Extension\\r\\n *\\r\\n * @notice Defines burn capabilities for ERC721 tokens.\\r\\n *      This interface should be treated as a definition of what burnable means for ERC721\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\ninterface BurnableERC721 {\\r\\n\\t/**\\r\\n\\t * @notice Destroys the token with token ID specified\\r\\n\\t *\\r\\n\\t * @dev Should be accessible publicly by token owners.\\r\\n\\t *      May have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _tokenId ID of the token to burn\\r\\n\\t */\\r\\n\\tfunction burn(uint256 _tokenId) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/LandERC721Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"../lib/LandLib.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Land ERC721 Metadata\\r\\n *\\r\\n * @notice Defines metadata-related capabilities for LandERC721 token.\\r\\n *      This interface should be treated as a definition of what metadata is for LandERC721,\\r\\n *      and what operations are defined/allowed for it.\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\ninterface LandERC721Metadata {\\r\\n\\t/**\\r\\n\\t * @notice Presents token metadata in a well readable form,\\r\\n\\t *      with the Internal Land Structure included, as a `PlotView` struct\\r\\n\\t *\\r\\n\\t * @notice Reconstructs the internal land structure of the plot based on the stored\\r\\n\\t *      Tier ID, Plot Size, Generator Version, and Seed\\r\\n\\t *\\r\\n\\t * @param _tokenId token ID to query metadata view for\\r\\n\\t * @return token metadata as a `PlotView` struct\\r\\n\\t */\\r\\n\\tfunction viewMetadata(uint256 _tokenId) external view returns (LandLib.PlotView memory);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Presents token metadata \\\"as is\\\", without the Internal Land Structure included,\\r\\n\\t *      as a `PlotStore` struct;\\r\\n\\t *\\r\\n\\t * @notice Doesn't reconstruct the internal land structure of the plot, allowing to\\r\\n\\t *      access Generator Version, and Seed fields \\\"as is\\\"\\r\\n\\t *\\r\\n\\t * @param _tokenId token ID to query on-chain metadata for\\r\\n\\t * @return token metadata as a `PlotStore` struct\\r\\n\\t */\\r\\n\\tfunction getMetadata(uint256 _tokenId) external view returns (LandLib.PlotStore memory);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Verifies if token has its metadata set on-chain; for the tokens\\r\\n\\t *      in existence metadata is immutable, it can be set once, and not updated\\r\\n\\t *\\r\\n\\t * @dev If `exists(_tokenId) && hasMetadata(_tokenId)` is true, `setMetadata`\\r\\n\\t *      for such a `_tokenId` will always throw\\r\\n\\t *\\r\\n\\t * @param _tokenId token ID to check metadata existence for\\r\\n\\t * @return true if token ID specified has metadata associated with it\\r\\n\\t */\\r\\n\\tfunction hasMetadata(uint256 _tokenId) external view returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sets/updates token metadata on-chain; same metadata struct can be then\\r\\n\\t *      read back using `getMetadata()` function, or it can be converted to\\r\\n\\t *      `PlotView` using `viewMetadata()` function\\r\\n\\t *\\r\\n\\t * @dev The metadata supplied is validated to satisfy (regionId, x, y) uniqueness;\\r\\n\\t *      non-intersection of the sites coordinates within a plot is guaranteed by the\\r\\n\\t *      internal land structure generator algorithm embedded into the `viewMetadata()`\\r\\n\\t *\\r\\n\\t * @dev Metadata for non-existing tokens can be set and updated unlimited\\r\\n\\t *      amount of times without any restrictions (except the constraints above)\\r\\n\\t * @dev Metadata for an existing token can only be set, it cannot be updated\\r\\n\\t *      (`setMetadata` will throw if metadata already exists)\\r\\n\\t *\\r\\n\\t * @param _tokenId token ID to set/updated the metadata for\\r\\n\\t * @param _plot token metadata to be set for the token ID\\r\\n\\t */\\r\\n\\tfunction setMetadata(uint256 _tokenId, LandLib.PlotStore memory _plot) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Removes token metadata\\r\\n\\t *\\r\\n\\t * @param _tokenId token ID to remove metadata for\\r\\n\\t */\\r\\n\\tfunction removeMetadata(uint256 _tokenId) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Mints the token and assigns the metadata supplied\\r\\n\\t *\\r\\n\\t * @dev Creates new token with the token ID specified\\r\\n\\t *      and assigns an ownership `_to` for this token\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\r\\n\\t *      Consider minting with `safeMint` (and setting metadata before),\\r\\n\\t *      for the \\\"safe mint\\\" like behavior\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId token ID to mint and set metadata for\\r\\n\\t * @param _plot token metadata to be set for the token ID\\r\\n\\t */\\r\\n\\tfunction mintWithMetadata(address _to, uint256 _tokenId, LandLib.PlotStore memory _plot) external;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Land Descriptor\\r\\n *\\r\\n * @notice Auxiliary module which is dynamically injected into LandERC721 contract\\r\\n *      to override the default ERC721.tokenURI behaviour\\r\\n *\\r\\n * @notice This can be used, for example, to enable on-chain generation of the SVG\\r\\n *      image representation of the land plot, encoding it into base64 string, and\\r\\n *      using it instead of token URI pointing to some off-chain sotrage location\\r\\n *\\r\\n * @dev Can be dynamically injected into LandERC721 at any time, can be dynamically detached\\r\\n *      from the LandERC721 once attached (injected)\\r\\n *\\r\\n * @author Pedro Bergamini, Basil Gorin\\r\\n */\\r\\ninterface LandDescriptor {\\r\\n\\t/**\\r\\n\\t * @notice Creates SVG image with the land plot metadata painted on it,\\r\\n\\t *      encodes the generated SVG into base64 URI string\\r\\n\\t *\\r\\n\\t * @param _tokenId token ID of the land plot to generate SVG for\\r\\n\\t */\\r\\n\\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IdentifiableSpec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @title Identifiable Token\\r\\n *\\r\\n * @notice Marker interface for the smart contracts having TOKEN_UID public property,\\r\\n *      usually these are ERC20/ERC721/ERC1155 token smart contracts\\r\\n *\\r\\n * @dev TOKEN_UID is used as an enhancement to ERC165 and helps better identifying\\r\\n *      deployed smart contracts\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\ninterface IdentifiableToken {\\r\\n\\t/**\\r\\n\\t * @dev Smart contract unique identifier, a random number\\r\\n\\t *\\r\\n\\t * @dev Should be regenerated each time smart contact source code is changed\\r\\n\\t *      and changes smart contract itself is to be redeployed\\r\\n\\t *\\r\\n\\t * @dev Generated using https://www.random.org/bytes/\\r\\n\\t * @dev Example value: 0x0bcafe95bec2350659433fc61cb9c4fbe18719da00059d525154dfe0d6e8c8fd\\r\\n\\t */\\r\\n\\tfunction TOKEN_UID() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/PriceOracleSpec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @title Pair Price Oracle, a.k.a. Pair Oracle\\r\\n *\\r\\n * @notice Generic interface used to consult on the Uniswap-like token pairs conversion prices;\\r\\n *      one pair oracle is used to consult on the exchange rate within a single token pair\\r\\n *\\r\\n * @notice See also: https://docs.uniswap.org/protocol/V2/guides/smart-contract-integration/building-an-oracle\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\ninterface PairOracle {\\r\\n\\t/**\\r\\n\\t * @notice Updates the oracle with the price values if required, for example\\r\\n\\t *      the cumulative price at the start and end of a period, etc.\\r\\n\\t *\\r\\n\\t * @dev This function is part of the oracle maintenance flow\\r\\n\\t */\\r\\n\\tfunction update() external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice For a pair of tokens A/B (sell/buy), consults on the amount of token B to be\\r\\n\\t *      bought if the specified amount of token A to be sold\\r\\n\\t *\\r\\n\\t * @dev This function is part of the oracle usage flow\\r\\n\\t *\\r\\n\\t * @param token token A (token to sell) address\\r\\n\\t * @param amountIn amount of token A to sell\\r\\n\\t * @return amountOut amount of token B to be bought\\r\\n\\t */\\r\\n\\tfunction consult(address token, uint256 amountIn) external view returns (uint256 amountOut);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Price Oracle Registry\\r\\n *\\r\\n * @notice To make pair oracles more convenient to use, a more generic Oracle Registry\\r\\n *        interface is introduced: it stores the addresses of pair price oracles and allows\\r\\n *        searching/querying for them\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\ninterface PriceOracleRegistry {\\r\\n\\t/**\\r\\n\\t * @notice Searches for the Pair Price Oracle for A/B (sell/buy) token pair\\r\\n\\t *\\r\\n\\t * @param tokenA token A (token to sell) address\\r\\n\\t * @param tokenB token B (token to buy) address\\r\\n\\t * @return pairOracle pair price oracle address for A/B token pair\\r\\n\\t */\\r\\n\\tfunction getPriceOracle(address tokenA, address tokenB) external view returns (address pairOracle);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Land Sale Price Oracle\\r\\n *\\r\\n * @notice Supports the Land Sale with the ETH/ILV conversion required,\\r\\n *       marker interface is required to support ERC165 lookups\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\ninterface LandSalePriceOracle {\\r\\n\\t/**\\r\\n\\t * @notice Powers the ETH/ILV Land token price conversion, used when\\r\\n\\t *      selling the land for sILV to determine how much sILV to accept\\r\\n\\t *      instead of the nominated ETH price\\r\\n\\t *\\r\\n\\t * @notice Note that sILV price is considered to be equal to ILV price\\r\\n\\t *\\r\\n\\t * @dev Implementation must guarantee not to return zero, absurdly small\\r\\n\\t *      or big values, it must guarantee the price is up to date with some\\r\\n\\t *      reasonable update interval threshold\\r\\n\\t *\\r\\n\\t * @param ethOut amount of ETH sale contract is expecting to get\\r\\n\\t * @return ilvIn amount of sILV sale contract should accept instead\\r\\n\\t */\\r\\n\\tfunction ethToIlv(uint256 ethOut) external returns (uint256 ilvIn);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/LandLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @title Land Library\\r\\n *\\r\\n * @notice A library defining data structures related to land plots (used in Land ERC721 token),\\r\\n *      and functions transforming these structures between view and internal (packed) representations,\\r\\n *      in both directions.\\r\\n *\\r\\n * @notice Due to some limitations Solidity has (ex.: allocating array of structures in storage),\\r\\n *      and due to the specific nature of internal land structure\\r\\n *      (landmark and resource sites data is deterministically derived from a pseudo random seed),\\r\\n *      it is convenient to separate data structures used to store metadata on-chain (store),\\r\\n *      and data structures used to present metadata via smart contract ABI (view)\\r\\n *\\r\\n * @notice Introduces helper functions to detect and deal with the resource site collisions\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\nlibrary LandLib {\\r\\n\\t/**\\r\\n\\t * @title Resource Site View\\r\\n\\t *\\r\\n\\t * @notice Resource Site, bound to a coordinates (x, y) within the land plot\\r\\n\\t *\\r\\n\\t * @notice Resources can be of two major types, each type having three subtypes:\\r\\n\\t *      - Element (Carbon, Silicon, Hydrogen), or\\r\\n\\t *      - Fuel (Crypton, Hyperion, Solon)\\r\\n\\t *\\r\\n\\t * @dev View only structure, used in public API/ABI, not used in on-chain storage\\r\\n\\t */\\r\\n\\tstruct Site {\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Site type:\\r\\n\\t\\t *        1) Carbon (element),\\r\\n\\t\\t *        2) Silicon (element),\\r\\n\\t\\t *        3) Hydrogen (element),\\r\\n\\t\\t *        4) Crypton (fuel),\\r\\n\\t\\t *        5) Hyperion (fuel),\\r\\n\\t\\t *        6) Solon (fuel)\\r\\n\\t\\t */\\r\\n\\t\\tuint8 typeId;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev x-coordinate within a plot\\r\\n\\t\\t */\\r\\n\\t\\tuint16 x;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev y-coordinate within a plot\\r\\n\\t\\t */\\r\\n\\t\\tuint16 y;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @title Land Plot View\\r\\n\\t *\\r\\n\\t * @notice Land Plot, bound to a coordinates (x, y) within the region,\\r\\n\\t *      with a rarity defined by the tier ID, sites, and (optionally)\\r\\n\\t *      a landmark, positioned on the internal coordinate grid of the\\r\\n\\t *      specified size within a plot.\\r\\n\\t *\\r\\n\\t * @notice Land plot coordinates and rarity are predefined (stored off-chain).\\r\\n\\t *      Number of sites (and landmarks - 0/1) is defined by the land rarity.\\r\\n\\t *      Positions of sites, types of sites/landmark are randomized and determined\\r\\n\\t *      upon land plot creation.\\r\\n\\t *\\r\\n\\t * @dev View only structure, used in public API/ABI, not used in on-chain storage\\r\\n\\t */\\r\\n\\tstruct PlotView {\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Region ID defines the region on the map in IZ:\\r\\n\\t\\t *        1) Abyssal Basin\\r\\n\\t\\t *        2) Brightland Steppes\\r\\n\\t\\t *        3) Shardbluff Labyrinth\\r\\n\\t\\t *        4) Crimson Waste\\r\\n\\t\\t *        5) Halcyon Sea\\r\\n\\t\\t *        6) Taiga Boreal\\r\\n\\t\\t *        7) Crystal Shores\\r\\n\\t\\t */\\r\\n\\t\\tuint8 regionId;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev x-coordinate within the region\\r\\n\\t\\t */\\r\\n\\t\\tuint16 x;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev y-coordinate within the region\\r\\n\\t\\t */\\r\\n\\t\\tuint16 y;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Tier ID defines land rarity and number of sites within the plot\\r\\n\\t\\t */\\r\\n\\t\\tuint8 tierId;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Plot size, limits the (x, y) coordinates for the sites\\r\\n\\t\\t */\\r\\n\\t\\tuint16 size;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Landmark Type ID:\\r\\n\\t\\t *        0) no Landmark\\r\\n\\t\\t *        1) Carbon Landmark,\\r\\n\\t\\t *        2) Silicon Landmark,\\r\\n\\t\\t *        3) Hydrogen Landmark (Eternal Spring),\\r\\n\\t\\t *        4) Crypton Landmark,\\r\\n\\t\\t *        5) Hyperion Landmark,\\r\\n\\t\\t *        6) Solon Landmark (Fallen Star),\\r\\n\\t\\t *        7) Arena\\r\\n\\t\\t *\\r\\n\\t\\t * @dev Landmark is always positioned in the center of internal grid\\r\\n\\t\\t */\\r\\n\\t\\tuint8 landmarkTypeId;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Number of Element Sites (Carbon, Silicon, or Hydrogen) this plot contains,\\r\\n\\t\\t *      matches the number of element sites in sites[] array\\r\\n\\t\\t */\\r\\n\\t\\tuint8 elementSites;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Number of Fuel Sites (Crypton, Hyperion, or Solon) this plot contains,\\r\\n\\t\\t *      matches the number of fuel sites in sites[] array\\r\\n\\t\\t */\\r\\n\\t\\tuint8 fuelSites;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Element/fuel sites within the plot\\r\\n\\t\\t */\\r\\n\\t\\tSite[] sites;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @title Land Plot Store\\r\\n\\t *\\r\\n\\t * @notice Land Plot data structure as it is stored on-chain\\r\\n\\t *\\r\\n\\t * @notice Contains the data required to generate `PlotView` structure:\\r\\n\\t *      - regionId, x, y, tierId, size, landmarkTypeId, elementSites, and fuelSites are copied as is\\r\\n\\t *      - version and seed are used to derive array of sites (together with elementSites, and fuelSites)\\r\\n\\t *\\r\\n\\t * @dev On-chain optimized structure, has limited usage in public API/ABI\\r\\n\\t */\\r\\n\\tstruct PlotStore {\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Generator Version, reserved for the future use in order to tweak the\\r\\n\\t\\t *      behavior of the internal land structure algorithm\\r\\n\\t\\t */\\r\\n\\t\\tuint8 version;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Region ID defines the region on the map in IZ:\\r\\n\\t\\t *        1) Abyssal Basin\\r\\n\\t\\t *        2) Brightland Steppes\\r\\n\\t\\t *        3) Shardbluff Labyrinth\\r\\n\\t\\t *        4) Crimson Waste\\r\\n\\t\\t *        5) Halcyon Sea\\r\\n\\t\\t *        6) Taiga Boreal\\r\\n\\t\\t *        7) Crystal Shores\\r\\n\\t\\t */\\r\\n\\t\\tuint8 regionId;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev x-coordinate within the region\\r\\n\\t\\t */\\r\\n\\t\\tuint16 x;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev y-coordinate within the region\\r\\n\\t\\t */\\r\\n\\t\\tuint16 y;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Tier ID defines land rarity and number of sites within the plot\\r\\n\\t\\t */\\r\\n\\t\\tuint8 tierId;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Plot Size, limits the (x, y) coordinates for the sites\\r\\n\\t\\t */\\r\\n\\t\\tuint16 size;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Landmark Type ID:\\r\\n\\t\\t *        0) no Landmark\\r\\n\\t\\t *        1) Carbon Landmark,\\r\\n\\t\\t *        2) Silicon Landmark,\\r\\n\\t\\t *        3) Hydrogen Landmark (Eternal Spring),\\r\\n\\t\\t *        4) Crypton Landmark,\\r\\n\\t\\t *        5) Hyperion Landmark,\\r\\n\\t\\t *        6) Solon Landmark (Fallen Star),\\r\\n\\t\\t *        7) Arena\\r\\n\\t\\t *\\r\\n\\t\\t * @dev Landmark is always positioned in the center of internal grid\\r\\n\\t\\t */\\r\\n\\t\\tuint8 landmarkTypeId;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Number of Element Sites (Carbon, Silicon, or Hydrogen) this plot contains\\r\\n\\t\\t */\\r\\n\\t\\tuint8 elementSites;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Number of Fuel Sites (Crypton, Hyperion, or Solon) this plot contains\\r\\n\\t\\t */\\r\\n\\t\\tuint8 fuelSites;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * @dev Pseudo-random Seed to generate Internal Land Structure,\\r\\n\\t\\t *      should be treated as already used to derive Landmark Type ID\\r\\n\\t\\t */\\r\\n\\t\\tuint160 seed;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Tightly packs `PlotStore` data struct into uint256 representation\\r\\n\\t *\\r\\n\\t * @param store `PlotStore` data struct to pack\\r\\n\\t * @return packed `PlotStore` data struct packed into uint256\\r\\n\\t */\\r\\n\\tfunction pack(PlotStore memory store) internal pure returns (uint256 packed) {\\r\\n\\t\\treturn uint256(store.version) << 248\\r\\n\\t\\t\\t| uint248(store.regionId) << 240\\r\\n\\t\\t\\t| uint240(store.x) << 224\\r\\n\\t\\t\\t| uint224(store.y) << 208\\r\\n\\t\\t\\t| uint208(store.tierId) << 200\\r\\n\\t\\t\\t| uint200(store.size) << 184\\r\\n\\t\\t\\t| uint184(store.landmarkTypeId) << 176\\r\\n\\t\\t\\t| uint176(store.elementSites) << 168\\r\\n\\t\\t\\t| uint168(store.fuelSites) << 160\\r\\n\\t\\t\\t| uint160(store.seed);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Unpacks `PlotStore` data struct from uint256 representation\\r\\n\\t *\\r\\n\\t * @param packed uint256 packed `PlotStore` data struct\\r\\n\\t * @return store unpacked `PlotStore` data struct\\r\\n\\t */\\r\\n\\tfunction unpack(uint256 packed) internal pure returns (PlotStore memory store) {\\r\\n\\t\\treturn PlotStore({\\r\\n\\t\\t\\tversion:        uint8(packed >> 248),\\r\\n\\t\\t\\tregionId:       uint8(packed >> 240),\\r\\n\\t\\t\\tx:              uint16(packed >> 224),\\r\\n\\t\\t\\ty:              uint16(packed >> 208),\\r\\n\\t\\t\\ttierId:         uint8(packed >> 200),\\r\\n\\t\\t\\tsize:           uint16(packed >> 184),\\r\\n\\t\\t\\tlandmarkTypeId: uint8(packed >> 176),\\r\\n\\t\\t\\telementSites:   uint8(packed >> 168),\\r\\n\\t\\t\\tfuelSites:      uint8(packed >> 160),\\r\\n\\t\\t\\tseed:           uint160(packed)\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Expands `PlotStore` data struct into a `PlotView` view struct\\r\\n\\t *\\r\\n\\t * @dev Derives internal land structure (resource sites the plot has)\\r\\n\\t *      from Number of Element/Fuel Sites, Plot Size, and Seed;\\r\\n\\t *      Generator Version is not currently used\\r\\n\\t *\\r\\n\\t * @param store on-chain `PlotStore` data structure to expand\\r\\n\\t * @return `PlotView` view struct, expanded from the on-chain data\\r\\n\\t */\\r\\n\\tfunction plotView(PlotStore memory store) internal pure returns (PlotView memory) {\\r\\n\\t\\t// copy most of the fields as is, derive resource sites array inline\\r\\n\\t\\treturn PlotView({\\r\\n\\t\\t\\tregionId:       store.regionId,\\r\\n\\t\\t\\tx:              store.x,\\r\\n\\t\\t\\ty:              store.y,\\r\\n\\t\\t\\ttierId:         store.tierId,\\r\\n\\t\\t\\tsize:           store.size,\\r\\n\\t\\t\\tlandmarkTypeId: store.landmarkTypeId,\\r\\n\\t\\t\\telementSites:   store.elementSites,\\r\\n\\t\\t\\tfuelSites:      store.fuelSites,\\r\\n\\t\\t\\t// derive the resource sites from Number of Element/Fuel Sites, Plot Size, and Seed\\r\\n\\t\\t\\tsites:          getResourceSites(store.seed, store.elementSites, store.fuelSites, store.size, 2)\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Based on the random seed, tier ID, and plot size, determines the\\r\\n\\t *      internal land structure (resource sites the plot has)\\r\\n\\t *\\r\\n\\t * @dev Function works in a deterministic way and derives the same data\\r\\n\\t *      for the same inputs; the term \\\"random\\\" in comments means \\\"pseudo-random\\\"\\r\\n\\t *\\r\\n\\t * @param seed random seed to consume and derive the internal structure\\r\\n\\t * @param elementSites number of element sites plot has\\r\\n\\t * @param fuelSites number of fuel sites plot has\\r\\n\\t * @param gridSize plot size `N` of the land plot to derive internal structure for\\r\\n\\t * @param siteSize implied size `n` of the resource sites\\r\\n\\t * @return sites randomized array of resource sites\\r\\n\\t */\\r\\n\\tfunction getResourceSites(\\r\\n\\t\\tuint256 seed,\\r\\n\\t\\tuint8 elementSites,\\r\\n\\t\\tuint8 fuelSites,\\r\\n\\t\\tuint16 gridSize,\\r\\n\\t\\tuint8 siteSize\\r\\n\\t) internal pure returns (Site[] memory sites) {\\r\\n\\t\\t// derive the total number of sites\\r\\n\\t\\tuint8 totalSites = elementSites + fuelSites;\\r\\n\\r\\n\\t\\t// denote the grid (plot) size `N`\\r\\n\\t\\t// denote the resource site size `n`\\r\\n\\r\\n\\t\\t// transform coordinate system (1): normalization (x, y) => (x / n, y / n)\\r\\n\\t\\t// if `N` is odd this cuts off border coordinates x = N - 1, y = N - 1\\r\\n\\t\\tuint16 normalizedSize = gridSize / siteSize;\\r\\n\\r\\n\\t\\t// after normalization (1) is applied, isomorphic grid becomes effectively larger\\r\\n\\t\\t// due to borders capturing effect, for example if N = 4, and n = 2:\\r\\n\\t\\t//      | .. |                                              |....|\\r\\n\\t\\t// grid |....| becomes |..| normalized which is effectively |....|\\r\\n\\t\\t//      |....|         |..|                                 |....|\\r\\n\\t\\t//      | .. |                                              |....|\\r\\n\\t\\t// transform coordinate system (2): cut the borders, and reduce grid size to be multiple of 2\\r\\n\\t\\t// if `N/2` is odd this cuts off border coordinates x = N/2 - 1, y = N/2 - 1\\r\\n\\t\\tnormalizedSize = (normalizedSize - 2) / 2 * 2;\\r\\n\\r\\n\\t\\t// define coordinate system: an isomorphic grid on a square of size [size, size]\\r\\n\\t\\t// transform coordinate system (3): pack an isomorphic grid on a rectangle of size [size, 1 + size / 2]\\r\\n\\t\\t// transform coordinate system (4): (x, y) -> y * size + x (two-dimensional Cartesian -> one-dimensional segment)\\r\\n\\t\\t// define temporary array to determine sites' coordinates\\r\\n\\t\\tuint16[] memory coords;\\r\\n\\t\\t// generate site coordinates in a transformed coordinate system (on a one-dimensional segment)\\r\\n\\t\\t// cut off four elements in the end of the segment to reserve space in the center for a landmark\\r\\n\\t\\t(seed, coords) = getCoords(seed, totalSites, normalizedSize * (1 + normalizedSize / 2) - 4);\\r\\n\\r\\n\\t\\t// allocate number of sites required\\r\\n\\t\\tsites = new Site[](totalSites);\\r\\n\\r\\n\\t\\t// define the variables used inside the loop outside the loop to help compiler optimizations\\r\\n\\t\\t// site type ID is de facto uint8, we're using uint16 for convenience with `nextRndUint16`\\r\\n\\t\\tuint16 typeId;\\r\\n\\t\\t// site coordinates (x, y)\\r\\n\\t\\tuint16 x;\\r\\n\\t\\tuint16 y;\\r\\n\\r\\n\\t\\t// determine the element and fuel sites one by one\\r\\n\\t\\tfor(uint8 i = 0; i < totalSites; i++) {\\r\\n\\t\\t\\t// determine next random number in the sequence, and random site type from it\\r\\n\\t\\t\\t(seed, typeId) = nextRndUint16(seed, i < elementSites? 1: 4, 3);\\r\\n\\r\\n\\t\\t\\t// determine x and y\\r\\n\\t\\t\\t// reverse transform coordinate system (4): x = size % i, y = size / i\\r\\n\\t\\t\\t// (back from one-dimensional segment to two-dimensional Cartesian)\\r\\n\\t\\t\\tx = coords[i] % normalizedSize;\\r\\n\\t\\t\\ty = coords[i] / normalizedSize;\\r\\n\\r\\n\\t\\t\\t// reverse transform coordinate system (3): unpack isomorphic grid onto a square of size [size, size]\\r\\n\\t\\t\\t// fix the \\\"(0, 0) left-bottom corner\\\" of the isomorphic grid\\r\\n\\t\\t\\tif(2 * (1 + x + y) < normalizedSize) {\\r\\n\\t\\t\\t\\tx += normalizedSize / 2;\\r\\n\\t\\t\\t\\ty += 1 + normalizedSize / 2;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// fix the \\\"(size, 0) right-bottom corner\\\" of the isomorphic grid\\r\\n\\t\\t\\telse if(2 * x > normalizedSize && 2 * x > 2 * y + normalizedSize) {\\r\\n\\t\\t\\t\\tx -= normalizedSize / 2;\\r\\n\\t\\t\\t\\ty += 1 + normalizedSize / 2;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// move the site from the center (four positions near the center) to a free spot\\r\\n\\t\\t\\tif(x >= normalizedSize / 2 - 1 && x <= normalizedSize / 2\\r\\n\\t\\t\\t&& y >= normalizedSize / 2 - 1 && y <= normalizedSize / 2) {\\r\\n\\t\\t\\t\\t// `x` is aligned over the free space in the end of the segment\\r\\n\\t\\t\\t\\t// x += normalizedSize / 2 + 2 * (normalizedSize / 2 - x) + 2 * (normalizedSize / 2 - y) - 4;\\r\\n\\t\\t\\t\\tx += 5 * normalizedSize / 2 - 2 * (x + y) - 4;\\r\\n\\t\\t\\t\\t// `y` is fixed over the free space in the end of the segment\\r\\n\\t\\t\\t\\ty = normalizedSize / 2;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// if `N/2` is odd recover previously cut off border coordinates x = N/2 - 1, y = N/2 - 1\\r\\n\\t\\t\\t// if `N` is odd recover previously cut off border coordinates x = N - 1, y = N - 1\\r\\n\\t\\t\\tuint16 offset = gridSize / siteSize % 2 + gridSize % siteSize;\\r\\n\\r\\n\\t\\t\\t// based on the determined site type and coordinates, allocate the site\\r\\n\\t\\t\\tsites[i] = Site({\\r\\n\\t\\t\\t\\ttypeId: uint8(typeId),\\r\\n\\t\\t\\t\\t// reverse transform coordinate system (2): recover borders (x, y) => (x + 1, y + 1)\\r\\n\\t\\t\\t\\t// if `N/2` is odd recover previously cut off border coordinates x = N/2 - 1, y = N/2 - 1\\r\\n\\t\\t\\t\\t// reverse transform coordinate system (1): (x, y) => (n * x, n * y), where n is site size\\r\\n\\t\\t\\t\\t// if `N` is odd recover previously cut off border coordinates x = N - 1, y = N - 1\\r\\n\\t\\t\\t\\tx: (1 + x) * siteSize + offset,\\r\\n\\t\\t\\t\\ty: (1 + y) * siteSize + offset\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// return the result\\r\\n\\t\\treturn sites;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Based on the random seed and tier ID determines the landmark type of the plot.\\r\\n\\t *      Random seed is consumed for tiers 3 and 4 to randomly determine one of three\\r\\n\\t *      possible landmark types.\\r\\n\\t *      Tier 5 has its landmark type predefined (arena), lower tiers don't have a landmark.\\r\\n\\t *\\r\\n\\t * @dev Function works in a deterministic way and derives the same data\\r\\n\\t *      for the same inputs; the term \\\"random\\\" in comments means \\\"pseudo-random\\\"\\r\\n\\t *\\r\\n\\t * @param seed random seed to consume and derive the landmark type based on\\r\\n\\t * @param tierId tier ID of the land plot\\r\\n\\t * @return landmarkTypeId landmark type defined by its ID\\r\\n\\t */\\r\\n\\tfunction getLandmark(uint256 seed, uint8 tierId) internal pure returns (uint8 landmarkTypeId) {\\r\\n\\t\\t// depending on the tier, land plot can have a landmark\\r\\n\\t\\t// tier 3 has an element landmark (1, 2, 3)\\r\\n\\t\\tif(tierId == 3) {\\r\\n\\t\\t\\t// derive random element landmark\\r\\n\\t\\t\\treturn uint8(1 + seed % 3);\\r\\n\\t\\t}\\r\\n\\t\\t// tier 4 has a fuel landmark (4, 5, 6)\\r\\n\\t\\tif(tierId == 4) {\\r\\n\\t\\t\\t// derive random fuel landmark\\r\\n\\t\\t\\treturn uint8(4 + seed % 3);\\r\\n\\t\\t}\\r\\n\\t\\t// tier 5 has an arena landmark\\r\\n\\t\\tif(tierId == 5) {\\r\\n\\t\\t\\t// 7 - arena landmark\\r\\n\\t\\t\\treturn 7;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// lower tiers (0, 1, 2) don't have any landmark\\r\\n\\t\\t// tiers greater than 5 are not defined\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Derives an array of integers with no duplicates from the random seed;\\r\\n\\t *      each element in the array is within [0, size) bounds and represents\\r\\n\\t *      a two-dimensional Cartesian coordinate point (x, y) presented as one-dimensional\\r\\n\\t *\\r\\n\\t * @dev Function works in a deterministic way and derives the same data\\r\\n\\t *      for the same inputs; the term \\\"random\\\" in comments means \\\"pseudo-random\\\"\\r\\n\\t *\\r\\n\\t * @dev The input seed is considered to be already used to derive some random value\\r\\n\\t *      from it, therefore the function derives a new one by hashing the previous one\\r\\n\\t *      before generating the random value; the output seed is \\\"used\\\" - output random\\r\\n\\t *      value is derived from it\\r\\n\\t *\\r\\n\\t * @param seed random seed to consume and derive coordinates from\\r\\n\\t * @param length number of elements to generate\\r\\n\\t * @param size defines array element bounds [0, size)\\r\\n\\t * @return nextSeed next pseudo-random \\\"used\\\" seed\\r\\n\\t * @return coords the resulting array of length `n` with random non-repeating elements\\r\\n\\t *      in [0, size) range\\r\\n\\t */\\r\\n\\tfunction getCoords(\\r\\n\\t\\tuint256 seed,\\r\\n\\t\\tuint8 length,\\r\\n\\t\\tuint16 size\\r\\n\\t) internal pure returns (uint256 nextSeed, uint16[] memory coords) {\\r\\n\\t\\t// allocate temporary array to store (and determine) sites' coordinates\\r\\n\\t\\tcoords = new uint16[](length);\\r\\n\\r\\n\\t\\t// generate site coordinates one by one\\r\\n\\t\\tfor(uint8 i = 0; i < coords.length; i++) {\\r\\n\\t\\t\\t// get next number and update the seed\\r\\n\\t\\t\\t(seed, coords[i]) = nextRndUint16(seed, 0, size);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// sort the coordinates\\r\\n\\t\\tsort(coords);\\r\\n\\r\\n\\t\\t// find the if there are any duplicates, and while there are any\\r\\n\\t\\tfor(int256 i = findDup(coords); i >= 0; i = findDup(coords)) {\\r\\n\\t\\t\\t// regenerate the element at duplicate position found\\r\\n\\t\\t\\t(seed, coords[uint256(i)]) = nextRndUint16(seed, 0, size);\\r\\n\\t\\t\\t// sort the coordinates again\\r\\n\\t\\t\\t// TODO: check if this doesn't degrade the performance significantly (note the pivot in quick sort)\\r\\n\\t\\t\\tsort(coords);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// shuffle the array to compensate for the sorting made before\\r\\n\\t\\tseed = shuffle(seed, coords);\\r\\n\\r\\n\\t\\t// return the updated used seed, and generated coordinates\\r\\n\\t\\treturn (seed, coords);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Based on the random seed, generates next random seed, and a random value\\r\\n\\t *      not lower than given `offset` value and able to have `options` different\\r\\n\\t *      possible values\\r\\n\\t *\\r\\n\\t * @dev The input seed is considered to be already used to derive some random value\\r\\n\\t *      from it, therefore the function derives a new one by hashing the previous one\\r\\n\\t *      before generating the random value; the output seed is \\\"used\\\" - output random\\r\\n\\t *      value is derived from it\\r\\n\\t *\\r\\n\\t * @param seed random seed to consume and derive next random value from\\r\\n\\t * @param offset the minimum possible output\\r\\n\\t * @param options number of different possible values to output\\r\\n\\t * @return nextSeed next pseudo-random \\\"used\\\" seed\\r\\n\\t * @return rndVal random value in the [offset, offset + options) range\\r\\n\\t */\\r\\n\\tfunction nextRndUint16(\\r\\n\\t\\tuint256 seed,\\r\\n\\t\\tuint16 offset,\\r\\n\\t\\tuint16 options\\r\\n\\t) internal pure returns (\\r\\n\\t\\tuint256 nextSeed,\\r\\n\\t\\tuint16 rndVal\\r\\n\\t) {\\r\\n\\t\\t// generate next random seed first\\r\\n\\t\\tnextSeed = uint256(keccak256(abi.encodePacked(seed)));\\r\\n\\r\\n\\t\\t// derive random value with the desired properties from\\r\\n\\t\\t// the newly generated seed\\r\\n\\t\\trndVal = offset + uint16(nextSeed % options);\\r\\n\\r\\n\\t\\t// return the result as tuple\\r\\n\\t\\treturn (nextSeed, rndVal);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Plot location is a combination of (regionId, x, y), it's effectively\\r\\n\\t *      a 3-dimensional coordinate, unique for each plot\\r\\n\\t *\\r\\n\\t * @dev The function extracts plot location from the plot and represents it\\r\\n\\t *      in a packed form of 3 integers constituting the location: regionId | x | y\\r\\n\\t *\\r\\n\\t * @param plot `PlotView` view structure to extract location from\\r\\n\\t * @return Plot location (regionId, x, y) as a packed integer\\r\\n\\t */\\r\\n/*\\r\\n\\tfunction loc(PlotView memory plot) internal pure returns (uint40) {\\r\\n\\t\\t// tightly pack the location data and return\\r\\n\\t\\treturn uint40(plot.regionId) << 32 | uint32(plot.y) << 16 | plot.x;\\r\\n\\t}\\r\\n*/\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Plot location is a combination of (regionId, x, y), it's effectively\\r\\n\\t *      a 3-dimensional coordinate, unique for each plot\\r\\n\\t *\\r\\n\\t * @dev The function extracts plot location from the plot and represents it\\r\\n\\t *      in a packed form of 3 integers constituting the location: regionId | x | y\\r\\n\\t *\\r\\n\\t * @param plot `PlotStore` data store structure to extract location from\\r\\n\\t * @return Plot location (regionId, x, y) as a packed integer\\r\\n\\t */\\r\\n\\tfunction loc(PlotStore memory plot) internal pure returns (uint40) {\\r\\n\\t\\t// tightly pack the location data and return\\r\\n\\t\\treturn uint40(plot.regionId) << 32 | uint32(plot.y) << 16 | plot.x;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Site location is a combination of (x, y), unique for each site within a plot\\r\\n\\t *\\r\\n\\t * @dev The function extracts site location from the site and represents it\\r\\n\\t *      in a packed form of 2 integers constituting the location: x | y\\r\\n\\t *\\r\\n\\t * @param site `Site` view structure to extract location from\\r\\n\\t * @return Site location (x, y) as a packed integer\\r\\n\\t */\\r\\n/*\\r\\n\\tfunction loc(Site memory site) internal pure returns (uint32) {\\r\\n\\t\\t// tightly pack the location data and return\\r\\n\\t\\treturn uint32(site.y) << 16 | site.x;\\r\\n\\t}\\r\\n*/\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Finds first pair of repeating elements in the array\\r\\n\\t *\\r\\n\\t * @dev Assumes the array is sorted ascending:\\r\\n\\t *      returns `-1` if array is strictly monotonically increasing,\\r\\n\\t *      index of the first duplicate found otherwise\\r\\n\\t *\\r\\n\\t * @param arr an array of elements to check\\r\\n\\t * @return index found duplicate index, or `-1` if there are no repeating elements\\r\\n\\t */\\r\\n\\tfunction findDup(uint16[] memory arr) internal pure returns (int256 index) {\\r\\n\\t\\t// iterate over the array [1, n], leaving the space in the beginning for pair comparison\\r\\n\\t\\tfor(uint256 i = 1; i < arr.length; i++) {\\r\\n\\t\\t\\t// verify if there is a strict monotonically increase violation\\r\\n\\t\\t\\tif(arr[i - 1] >= arr[i]) {\\r\\n\\t\\t\\t\\t// return its index if yes\\r\\n\\t\\t\\t\\treturn int256(i - 1);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// return `-1` if no violation was found - array is strictly monotonically increasing\\r\\n\\t\\treturn -1;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Shuffles an array if integers by making random permutations\\r\\n\\t *      in the amount equal to the array size\\r\\n\\t *\\r\\n\\t * @dev The input seed is considered to be already used to derive some random value\\r\\n\\t *      from it, therefore the function derives a new one by hashing the previous one\\r\\n\\t *      before generating the random value; the output seed is \\\"used\\\" - output random\\r\\n\\t *      value is derived from it\\r\\n\\t *\\r\\n\\t * @param seed random seed to consume and derive next random value from\\r\\n\\t * @param arr an array to shuffle\\r\\n\\t * @return nextSeed next pseudo-random \\\"used\\\" seed\\r\\n\\t */\\r\\n\\tfunction shuffle(uint256 seed, uint16[] memory arr) internal pure returns(uint256 nextSeed) {\\r\\n\\t\\t// define index `j` to permute with loop index `i` outside the loop to help compiler optimizations\\r\\n\\t\\tuint16 j;\\r\\n\\r\\n\\t\\t// iterate over the array one single time\\r\\n\\t\\tfor(uint16 i = 0; i < arr.length; i++) {\\r\\n\\t\\t\\t// determine random index `j` to swap with the loop index `i`\\r\\n\\t\\t\\t(seed, j) = nextRndUint16(seed, 0, uint16(arr.length));\\r\\n\\r\\n\\t\\t\\t// do the swap\\r\\n\\t\\t\\t(arr[i], arr[j]) = (arr[j], arr[i]);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// return the updated used seed\\r\\n\\t\\treturn seed;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sorts an array of integers using quick sort algorithm\\r\\n\\t *\\r\\n\\t * @dev Quick sort recursive implementation\\r\\n\\t *      Source:   https://gist.github.com/subhodi/b3b86cc13ad2636420963e692a4d896f\\r\\n\\t *      See also: https://www.geeksforgeeks.org/quick-sort/\\r\\n\\t *\\r\\n\\t * @param arr an array to sort\\r\\n\\t */\\r\\n\\tfunction sort(uint16[] memory arr) internal pure {\\r\\n\\t\\tquickSort(arr, 0, int256(arr.length) - 1);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Quick sort recursive implementation\\r\\n\\t *      Source:     https://gist.github.com/subhodi/b3b86cc13ad2636420963e692a4d896f\\r\\n\\t *      Discussion: https://blog.cotten.io/thinking-in-solidity-6670c06390a9\\r\\n\\t *      See also:   https://www.geeksforgeeks.org/quick-sort/\\r\\n\\t */\\r\\n\\t// TODO: review the implementation code\\r\\n\\tfunction quickSort(uint16[] memory arr, int256 left, int256 right) private pure {\\r\\n\\t\\tint256 i = left;\\r\\n\\t\\tint256 j = right;\\r\\n\\t\\tif(i >= j) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tuint16 pivot = arr[uint256(left + (right - left) / 2)];\\r\\n\\t\\twhile(i <= j) {\\r\\n\\t\\t\\twhile(arr[uint256(i)] < pivot) {\\r\\n\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\twhile(pivot < arr[uint256(j)]) {\\r\\n\\t\\t\\t\\tj--;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(i <= j) {\\r\\n\\t\\t\\t\\t(arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\\r\\n\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t\\tj--;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tif(left < j) {\\r\\n\\t\\t\\tquickSort(arr, left, j);\\r\\n\\t\\t}\\r\\n\\t\\tif(i < right) {\\r\\n\\t\\t\\tquickSort(arr, i, right);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"../interfaces/ERC20Spec.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20 by OpenZeppelin\\r\\n *\\r\\n * @dev Wrappers around ERC20 operations that throw on failure\\r\\n *      (when the token contract returns false).\\r\\n *      Tokens that return no value (and instead revert or throw on failure)\\r\\n *      are also supported, non-reverting calls are assumed to be successful.\\r\\n * @dev To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n *      which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n *\\r\\n * @author OpenZeppelin\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n\\t// using Address.functionCall for addresses\\r\\n\\tusing Address for address;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev ERC20.transfer wrapper\\r\\n\\t *\\r\\n\\t * @param token ERC20 instance\\r\\n\\t * @param to ERC20.transfer to\\r\\n\\t * @param value ERC20.transfer value\\r\\n\\t */\\r\\n\\tfunction safeTransfer(ERC20 token, address to, uint256 value) internal {\\r\\n\\t\\t// delegate to `_callOptionalReturn`\\r\\n\\t\\t_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n\\t * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n\\t * @param token The token targeted by the call.\\r\\n\\t * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n\\t */\\r\\n\\tfunction _callOptionalReturn(ERC20 token, bytes memory data) private {\\r\\n\\t\\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n\\t\\t// we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n\\t\\t// the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n\\t\\t// execute function call and get the return data\\r\\n\\t\\tbytes memory retData = address(token).functionCall(data, \\\"ERC20 low-level call failed\\\");\\r\\n\\t\\t// return data is optional\\r\\n\\t\\tif(retData.length > 0) {\\r\\n\\t\\t\\trequire(abi.decode(retData, (bool)), \\\"ERC20 transfer failed\\\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/UpgradeableAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Upgradeable Access Control List // ERC1967Proxy\\r\\n *\\r\\n * @notice Access control smart contract provides an API to check\\r\\n *      if a specific operation is permitted globally and/or\\r\\n *      if a particular user has a permission to execute it.\\r\\n *\\r\\n * @notice It deals with two main entities: features and roles.\\r\\n *\\r\\n * @notice Features are designed to be used to enable/disable public functions\\r\\n *      of the smart contract (used by a wide audience).\\r\\n * @notice User roles are designed to control the access to restricted functions\\r\\n *      of the smart contract (used by a limited set of maintainers).\\r\\n *\\r\\n * @notice Terms \\\"role\\\", \\\"permissions\\\" and \\\"set of permissions\\\" have equal meaning\\r\\n *      in the documentation text and may be used interchangeably.\\r\\n * @notice Terms \\\"permission\\\", \\\"single permission\\\" implies only one permission bit set.\\r\\n *\\r\\n * @notice Access manager is a special role which allows to grant/revoke other roles.\\r\\n *      Access managers can only grant/revoke permissions which they have themselves.\\r\\n *      As an example, access manager with no other roles set can only grant/revoke its own\\r\\n *      access manager permission and nothing else.\\r\\n *\\r\\n * @notice Access manager permission should be treated carefully, as a super admin permission:\\r\\n *      Access manager with even no other permission can interfere with another account by\\r\\n *      granting own access manager permission to it and effectively creating more powerful\\r\\n *      permission set than its own.\\r\\n *\\r\\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\\r\\n *      to check/know \\\"who is allowed to do this thing\\\".\\r\\n * @dev Zeppelin implementation is more flexible:\\r\\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\\r\\n *      - it allows setting an admin for each role, while current allows having only one global admin\\r\\n * @dev Current implementation is more lightweight:\\r\\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\\r\\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\\r\\n *        setting only one role in a single transaction\\r\\n *\\r\\n * @dev This smart contract is designed to be inherited by other\\r\\n *      smart contracts which require access control management capabilities.\\r\\n *\\r\\n * @dev Access manager permission has a bit 255 set.\\r\\n *      This bit must not be used by inheriting contracts for any other permissions/features.\\r\\n *\\r\\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\\r\\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\\r\\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\\r\\n *\\r\\n * @author Basil Gorin\\r\\n */\\r\\nabstract contract UpgradeableAccessControl is UUPSUpgradeable {\\r\\n\\t/**\\r\\n\\t * @notice Privileged addresses with defined roles/permissions\\r\\n\\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\\r\\n\\t *      allow minting or burning tokens, transferring on behalf and so on\\r\\n\\t *\\r\\n\\t * @dev Maps user address to the permissions bitmask (role), where each bit\\r\\n\\t *      represents a permission\\r\\n\\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\r\\n\\t *      represents all possible permissions\\r\\n\\t * @dev 'This' address mapping represents global features of the smart contract\\r\\n\\t */\\r\\n\\tmapping(address => uint256) public userRoles;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\\r\\n\\t *      the amount of storage used by a contract always adds up to the 50.\\r\\n\\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n\\t */\\r\\n\\tuint256[49] private __gap;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Access manager is responsible for assigning the roles to users,\\r\\n\\t *      enabling/disabling global features of the smart contract\\r\\n\\t * @notice Access manager can add, remove and update user roles,\\r\\n\\t *      remove and update global features\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\\r\\n\\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\\r\\n\\t */\\r\\n\\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Upgrade manager is responsible for smart contract upgrades,\\r\\n\\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\\r\\n\\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\\r\\n\\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\\r\\n\\t */\\r\\n\\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Bitmask representing all the possible permissions (super admin role)\\r\\n\\t * @dev Has all the bits are enabled (2^256 - 1 value)\\r\\n\\t */\\r\\n\\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in updateRole() and updateFeatures()\\r\\n\\t *\\r\\n\\t * @param _by operator which called the function\\r\\n\\t * @param _to address which was granted/revoked permissions\\r\\n\\t * @param _requested permissions requested\\r\\n\\t * @param _actual permissions effectively set\\r\\n\\t */\\r\\n\\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev UUPS initializer, sets the contract owner to have full privileges\\r\\n\\t *\\r\\n\\t * @param _owner smart contract owner having full privileges\\r\\n\\t */\\r\\n\\tfunction _postConstruct(address _owner) internal virtual initializer {\\r\\n\\t\\t// grant owner full privileges\\r\\n\\t\\tuserRoles[_owner] = FULL_PRIVILEGES_MASK;\\r\\n\\r\\n\\t\\t// fire an event\\r\\n\\t\\temit RoleUpdated(msg.sender, _owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Returns an address of the implementation smart contract,\\r\\n\\t *      see ERC1967Upgrade._getImplementation()\\r\\n\\t *\\r\\n\\t * @return the current implementation address\\r\\n\\t */\\r\\n\\tfunction getImplementation() public view virtual returns (address) {\\r\\n\\t\\t// delegate to `ERC1967Upgrade._getImplementation()`\\r\\n\\t\\treturn _getImplementation();\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Retrieves globally set of features enabled\\r\\n\\t *\\r\\n\\t * @dev Effectively reads userRoles role for the contract itself\\r\\n\\t *\\r\\n\\t * @return 256-bit bitmask of the features enabled\\r\\n\\t */\\r\\n\\tfunction features() public view returns (uint256) {\\r\\n\\t\\t// features are stored in 'this' address  mapping of `userRoles` structure\\r\\n\\t\\treturn userRoles[address(this)];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Updates set of the globally enabled features (`features`),\\r\\n\\t *      taking into account sender's permissions\\r\\n\\t *\\r\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\r\\n\\t * @dev Function is left for backward compatibility with older versions\\r\\n\\t *\\r\\n\\t * @param _mask bitmask representing a set of features to enable/disable\\r\\n\\t */\\r\\n\\tfunction updateFeatures(uint256 _mask) public {\\r\\n\\t\\t// delegate call to `updateRole`\\r\\n\\t\\tupdateRole(address(this), _mask);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Updates set of permissions (role) for a given user,\\r\\n\\t *      taking into account sender's permissions.\\r\\n\\t *\\r\\n\\t * @dev Setting role to zero is equivalent to removing an all permissions\\r\\n\\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\\r\\n\\t *      copying senders' permissions (role) to the user\\r\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\r\\n\\t *\\r\\n\\t * @param operator address of a user to alter permissions for or zero\\r\\n\\t *      to alter global features of the smart contract\\r\\n\\t * @param role bitmask representing a set of permissions to\\r\\n\\t *      enable/disable for a user specified\\r\\n\\t */\\r\\n\\tfunction updateRole(address operator, uint256 role) public {\\r\\n\\t\\t// caller must have a permission to update user roles\\r\\n\\t\\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// evaluate the role and reassign it\\r\\n\\t\\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\\r\\n\\r\\n\\t\\t// fire an event\\r\\n\\t\\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Determines the permission bitmask an operator can set on the\\r\\n\\t *      target permission set\\r\\n\\t * @notice Used to calculate the permission bitmask to be set when requested\\r\\n\\t *     in `updateRole` and `updateFeatures` functions\\r\\n\\t *\\r\\n\\t * @dev Calculated based on:\\r\\n\\t *      1) operator's own permission set read from userRoles[operator]\\r\\n\\t *      2) target permission set - what is already set on the target\\r\\n\\t *      3) desired permission set - what do we want set target to\\r\\n\\t *\\r\\n\\t * @dev Corner cases:\\r\\n\\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\\r\\n\\t *        `desired` bitset is returned regardless of the `target` permission set value\\r\\n\\t *        (what operator sets is what they get)\\r\\n\\t *      2) Operator with no permissions (zero bitset):\\r\\n\\t *        `target` bitset is returned regardless of the `desired` value\\r\\n\\t *        (operator has no authority and cannot modify anything)\\r\\n\\t *\\r\\n\\t * @dev Example:\\r\\n\\t *      Consider an operator with the permissions bitmask     00001111\\r\\n\\t *      is about to modify the target permission set          01010101\\r\\n\\t *      Operator wants to set that permission set to          00110011\\r\\n\\t *      Based on their role, an operator has the permissions\\r\\n\\t *      to update only lowest 4 bits on the target, meaning that\\r\\n\\t *      high 4 bits of the target set in this example is left\\r\\n\\t *      unchanged and low 4 bits get changed as desired:      01010011\\r\\n\\t *\\r\\n\\t * @param operator address of the contract operator which is about to set the permissions\\r\\n\\t * @param target input set of permissions to operator is going to modify\\r\\n\\t * @param desired desired set of permissions operator would like to set\\r\\n\\t * @return resulting set of permissions given operator will set\\r\\n\\t */\\r\\n\\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns (uint256) {\\r\\n\\t\\t// read operator's permissions\\r\\n\\t\\tuint256 p = userRoles[operator];\\r\\n\\r\\n\\t\\t// taking into account operator's permissions,\\r\\n\\t\\t// 1) enable the permissions desired on the `target`\\r\\n\\t\\ttarget |= p & desired;\\r\\n\\t\\t// 2) disable the permissions desired on the `target`\\r\\n\\t\\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\\r\\n\\r\\n\\t\\t// return calculated result\\r\\n\\t\\treturn target;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Checks if requested set of features is enabled globally on the contract\\r\\n\\t *\\r\\n\\t * @param required set of features to check against\\r\\n\\t * @return true if all the features requested are enabled, false otherwise\\r\\n\\t */\\r\\n\\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\\r\\n\\t\\t// delegate call to `__hasRole`, passing `features` property\\r\\n\\t\\treturn __hasRole(features(), required);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\\r\\n\\t *\\r\\n\\t * @param required set of permissions (role) to check against\\r\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\r\\n\\t */\\r\\n\\tfunction isSenderInRole(uint256 required) public view returns (bool) {\\r\\n\\t\\t// delegate call to `isOperatorInRole`, passing transaction sender\\r\\n\\t\\treturn isOperatorInRole(msg.sender, required);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Checks if operator has all the permissions (role) required\\r\\n\\t *\\r\\n\\t * @param operator address of the user to check role for\\r\\n\\t * @param required set of permissions (role) to check\\r\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\r\\n\\t */\\r\\n\\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\\r\\n\\t\\t// delegate call to `__hasRole`, passing operator's permissions (role)\\r\\n\\t\\treturn __hasRole(userRoles[operator], required);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Checks if role `actual` contains all the permissions required `required`\\r\\n\\t *\\r\\n\\t * @param actual existent role\\r\\n\\t * @param required required role\\r\\n\\t * @return true if actual has required role (all permissions), false otherwise\\r\\n\\t */\\r\\n\\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns (bool) {\\r\\n\\t\\t// check the bitmask for the role required and return the result\\r\\n\\t\\treturn actual & required == required;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc UUPSUpgradeable\\r\\n\\t */\\r\\n\\tfunction _authorizeUpgrade(address) internal virtual override {\\r\\n\\t\\t// caller must have a permission to upgrade the contract\\r\\n\\t\\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \\\"access denied\\\");\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n        return computedHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC165Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @title ERC-165 Standard Interface Detection\\r\\n *\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * @dev Implementers can declare support of contract interfaces,\\r\\n *      which can then be queried by others.\\r\\n *\\r\\n * @author Christian Reitwie\u00dfner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\\r\\n */\\r\\ninterface ERC165 {\\r\\n\\t/**\\r\\n\\t * @notice Query if a contract implements an interface\\r\\n\\t *\\r\\n\\t * @dev Interface identification is specified in ERC-165.\\r\\n\\t *      This function uses less than 30,000 gas.\\r\\n\\t *\\r\\n\\t * @param interfaceID The interface identifier, as specified in ERC-165\\r\\n\\t * @return `true` if the contract implements `interfaceID` and\\r\\n\\t *      `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n\\t */\\r\\n\\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n        __ERC1967Upgrade_init_unchained();\\n        __UUPSUpgradeable_init_unchained();\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n        __ERC1967Upgrade_init_unchained();\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallSecure(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        address oldImplementation = _getImplementation();\\n\\n        // Initial upgrade and setup call\\n        _setImplementation(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n\\n        // Perform rollback test if not already in progress\\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\\n        if (!rollbackTesting.value) {\\n            // Trigger rollback using upgradeTo from the new implementation\\n            rollbackTesting.value = true;\\n            _functionDelegateCall(\\n                newImplementation,\\n                abi.encodeWithSignature(\\\"upgradeTo(address)\\\", oldImplementation)\\n            );\\n            rollbackTesting.value = false;\\n            // Check rollback was effective\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\n            // Finally reset to the new implementation and log the upgrade\\n            _upgradeTo(newImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_saleStart\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_saleEnd\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_halvingTime\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_timeFlowQuantum\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_seqDuration\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_seqOffset\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint96[]\",\"name\":\"_startPrices\",\"type\":\"uint96[]\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_pausedAt\",\"type\":\"uint32\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"_sequenceId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"regionId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"x\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"y\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"tierId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"landmarkTypeId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"elementSites\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fuelSites\",\"type\":\"uint8\"},{\"internalType\":\"uint160\",\"name\":\"seed\",\"type\":\"uint160\"}],\"indexed\":false,\"internalType\":\"struct LandLib.PlotStore\",\"name\":\"_plot\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_sIlv\",\"type\":\"uint256\"}],\"name\":\"PlotBoughtL1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"_sequenceId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"regionId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"x\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"y\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"tierId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"landmarkTypeId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"elementSites\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fuelSites\",\"type\":\"uint8\"},{\"internalType\":\"uint160\",\"name\":\"seed\",\"type\":\"uint160\"}],\"indexed\":false,\"internalType\":\"struct LandLib.PlotStore\",\"name\":\"_plot\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_plotPacked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_sIlv\",\"type\":\"uint256\"}],\"name\":\"PlotBoughtL2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_pausedAt\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_resumedAt\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_pauseDuration\",\"type\":\"uint32\"}],\"name\":\"Resumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_actual\",\"type\":\"uint256\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"RootChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_sIlv\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEATURE_L1_SALE_ACTIVE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEATURE_L2_SALE_ACTIVE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_ACCESS_MANAGER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_DATA_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_PAUSE_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_RESCUE_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_SALE_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_UPGRADE_MANAGER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_WITHDRAWAL_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"sequenceId\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"regionId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"x\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"y\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"tierId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"}],\"internalType\":\"struct LandSale.PlotData\",\"name\":\"plotData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"buyL1\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"sequenceId\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"regionId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"x\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"y\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"tierId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"}],\"internalType\":\"struct LandSale.PlotData\",\"name\":\"plotData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"buyL2\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"desired\",\"type\":\"uint256\"}],\"name\":\"evaluateBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"features\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStartPrices\",\"outputs\":[{\"internalType\":\"uint96[]\",\"name\":\"\",\"type\":\"uint96[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halvingTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_saleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_saleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_halvingTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_timeFlowQuantum\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_seqDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_seqOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint96[]\",\"name\":\"_startPrices\",\"type\":\"uint96[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isFeatureEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isOperatorInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"sequenceId\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"regionId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"x\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"y\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"tierId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"}],\"internalType\":\"struct LandSale.PlotData\",\"name\":\"plotData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"isPlotValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isSenderInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"now32\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausedAt\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sIlv\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"postConstruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"p0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"rescueErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sIlvContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleEnd\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleStart\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seqDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seqOffset\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"setInputDataRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"startPrices\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetNftContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeFlowQuantum\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"sequenceId\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"tierId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"t\",\"type\":\"uint32\"}],\"name\":\"tokenPriceAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"sequenceId\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"tierId\",\"type\":\"uint16\"}],\"name\":\"tokenPriceNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mask\",\"type\":\"uint256\"}],\"name\":\"updateFeatures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"updateRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRoles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_ethOnly\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_ethOnly\",\"type\":\"bool\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LandSale", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}