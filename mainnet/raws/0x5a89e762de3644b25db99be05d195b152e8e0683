{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"IUniswapV2Pair.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c \\u003c a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b \\u003e a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"UniswapTwapPriceOracleV2Ceiling.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.12;\\n\\nimport \\\"SafeMath.sol\\\";\\n\\nimport \\\"IUniswapV2Pair.sol\\\";\\n\\n/**\\n * @title UniswapTwapPriceOracleV2Ceiling\\n * @dev based on UniswapTwapPriceOracleRoot by David Lucid \\u003cdavid@rari.capital\\u003e (https://github.com/davidlucid)\\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\\n */\\ncontract UniswapTwapPriceOracleV2Ceiling {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Current price ceiling for the oracle\\n     */\\n    uint public priceCeiling;\\n\\n    /**\\n     * @dev maximum amount ceilining can be set above current price, in basis points, above. 1 = 0.01%\\n     */\\n    uint public maxBPCeiling;\\n\\n    /**\\n     * @dev minimum amount ceiling can be set above current price in, basis points, above current price. 1 = 0.01%\\n     */\\n    uint public minBPCeiling;\\n\\n    /**\\n     * @dev WETH token contract address.\\n     */\\n    address constant public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /**\\n     * @dev underlying token contract address.\\n     */\\n    address constant public underlying = 0x41D5D79431A913C4aE7d69a668ecdfE5fF9DFB68;\\n\\n    /**\\n     * @dev uniswapV2 pair between underlying and WETH\\n     */\\n    IUniswapV2Pair constant public pair = IUniswapV2Pair(0x328dFd0139e26cB0FEF7B0742B49b0fe4325F821);\\n\\n    /**\\n     * @dev Governance address, can set maxBPCeiling and minBPCeiling\\n     */\\n    address public governance;\\n\\n    /**\\n     * @dev Guardian address, can raise or lower price ceiling\\n     */\\n    address public guardian;\\n\\n    /**\\n     * @dev Minimum TWAP interval.\\n     */\\n    uint256 immutable public MIN_TWAP_TIME;\\n\\n    /**\\n     * @dev Internal baseUnit used as mantissa, set from decimals of underlying.\\n     */\\n    uint immutable private baseUnit;\\n\\n    constructor(uint MIN_TWAP_TIME_, uint maxBPCeiling_, uint minBPCeiling_, uint underlyingDecimals, address governance_, address guardian_) public {\\n        MIN_TWAP_TIME = MIN_TWAP_TIME_;\\n        maxBPCeiling = maxBPCeiling_;\\n        minBPCeiling = minBPCeiling_;\\n        governance = governance_;\\n        guardian = guardian_;\\n        baseUnit = 10 ** underlyingDecimals;\\n        priceCeiling = type(uint).max;\\n        //Update oracle at deployment, to avoid having to check against 0 observations for the rest of the oracle\\u0027s lifetime\\n        _update();\\n    }\\n\\n    /**\\n     * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\\n     */\\n    function priceTWAP() internal view returns (uint) {\\n        uint length = observationCount;\\n        Observation memory lastObservation = observations[(length - 1) % OBSERVATION_BUFFER];\\n        if (lastObservation.timestamp \\u003e now - MIN_TWAP_TIME) {\\n            require(length \\u003e 1, \\u0027No length-2 TWAP observation.\\u0027);//TODO: A lot of checking to do for something that\\u0027s only relevant when only 1 observation have been made\\n            lastObservation = observations[(length - 2) % OBSERVATION_BUFFER];\\n        }\\n        uint elapsedTime = now - lastObservation.timestamp;\\n        require(elapsedTime \\u003e= MIN_TWAP_TIME, \\u0027Bad TWAP time.\\u0027);\\n        return (currentPxCumu() - lastObservation.priceCumulative) / elapsedTime; // overflow is desired\\n    }\\n    /**\\n     * @dev Return the current price cumulative value on Uniswap.\\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\\n     */\\n    function currentPxCumu() internal view returns (uint pxCumu) {\\n        uint32 currTime = uint32(now);\\n        pxCumu = pair.price0CumulativeLast();\\n        (uint reserve0, uint reserve1, uint32 lastTime) = pair.getReserves();\\n        if (lastTime != now) {\\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\\n            pxCumu += uint((reserve1 \\u003c\\u003c 112) / reserve0) * timeElapsed; // overflow is desired\\n        }\\n    }\\n    /**\\n     * @dev Returns the price of `underlying` in terms of `baseToken` given `factory`.\\n     */\\n    function price() public view returns (uint) {\\n        // Return ERC20/ETH TWAP\\n        uint twapPrice = priceTWAP().div(2 ** 56).mul(baseUnit).div(2 ** 56);\\n        return twapPrice \\u003c priceCeiling ? twapPrice : priceCeiling;\\n    }\\n\\n    /**\\n     * @dev Struct for cumulative price observations.\\n     */\\n    struct Observation {\\n        uint32 timestamp;\\n        uint256 priceCumulative;\\n    }\\n\\n    /**\\n     * @dev Length after which observations roll over to index 0.\\n     */\\n    uint8 public constant OBSERVATION_BUFFER = 4;\\n\\n    /**\\n     * @dev Total observation count for each pair.\\n     */\\n    uint256 public observationCount;\\n\\n    /**\\n     * @dev Array of cumulative price observations for each pair.\\n     */\\n    Observation[OBSERVATION_BUFFER] public observations;\\n\\n    /// @dev Internal function to check if oracle is workable (updateable AND reserves have changed AND deviation threshold is satisfied).\\n    function workable(uint256 minPeriod, uint256 deviationThreshold) external view returns (bool) {\\n        // Workable if:\\n        // The elapsed time since the last observation is \\u003e minPeriod AND reserves have changed AND deviation threshold is satisfied \\n        // Note that we loop observationCount around OBSERVATION_BUFFER so we don\\u0027t waste gas on new storage slots\\n        (, , uint32 lastTime) = pair.getReserves();\\n        return (block.timestamp - observations[(observationCount - 1) % OBSERVATION_BUFFER].timestamp) \\u003e (minPeriod \\u003e= MIN_TWAP_TIME ? minPeriod : MIN_TWAP_TIME) \\u0026\\u0026\\n            lastTime != observations[(observationCount - 1) % OBSERVATION_BUFFER].timestamp \\u0026\\u0026\\n            _deviation() \\u003e= deviationThreshold;\\n    }\\n\\n    /// @dev Internal function to return oracle deviation from its TWAP price as a ratio scaled by 1e18\\n    function _deviation() internal view returns (uint256) {\\n        // Get TWAP price\\n        uint256 twapPrice = priceTWAP().div(2 ** 56).mul(baseUnit).div(2 ** 56); // Scaled by 1e18, not 2 ** 112\\n    \\n        // Get spot price\\n        (uint reserve0, uint reserve1, ) = pair.getReserves();\\n        uint256 spotPrice = reserve1.mul(baseUnit).div(reserve0);\\n\\n        // Get ratio and return deviation\\n        uint256 ratio = spotPrice.mul(1e18).div(twapPrice);\\n        return ratio \\u003e= 1e18 ? ratio - 1e18 : 1e18 - ratio;\\n    }\\n    \\n    /// @dev Internal function to check if oracle is updatable at all.\\n    function _updateable() internal view returns (bool) {\\n        // Updateable if:\\n        // 1) The elapsed time since the last observation is \\u003e MIN_TWAP_TIME\\n        // 2) The observation price (current price) is below priceCeiling\\n        // Note that we loop observationCount around OBSERVATION_BUFFER so we don\\u0027t waste gas on new storage slots\\n        return(block.timestamp - observations[(observationCount - 1) % OBSERVATION_BUFFER].timestamp) \\u003e MIN_TWAP_TIME;\\n    }\\n    \\n    function timeSinceLastUpdate() public view returns (uint) {\\n        return block.timestamp - observations[(observationCount - 1) % OBSERVATION_BUFFER].timestamp;\\n    }\\n\\n    /// @notice Update the oracle\\n    function update() external returns(bool) {\\n        if(!_updateable()){\\n            return false;\\n        }\\n        _update();\\n        return true;\\n    }\\n\\n\\n    /// @dev Internal function to update\\n    function _update() internal{\\n        // Get cumulative price\\n        uint256 priceCumulative = pair.price0CumulativeLast();\\n        \\n        // Loop observationCount around OBSERVATION_BUFFER so we don\\u0027t waste gas on new storage slots\\n        (, , uint32 lastTime) = pair.getReserves();\\n        observations[observationCount % OBSERVATION_BUFFER] = Observation(lastTime, priceCumulative);\\n        observationCount++;\\n    }\\n    // **************************\\n    // **  GUARDIAN FUNCTIONS  **\\n    // **************************\\n\\n    /**\\n     * @dev Function for setting newPriceCeiling, only callable by guardian\\n     * @param newPriceCeiling_ The new price ceiling, must be within max and min parameters\\n     */\\n    function setPriceCeiling(uint newPriceCeiling_) external {\\n        require(msg.sender == guardian);\\n        uint currentPrice = price();\\n        require(newPriceCeiling_ \\u003c= currentPrice + currentPrice*maxBPCeiling/10_000);\\n        require(newPriceCeiling_ \\u003e= currentPrice + currentPrice*minBPCeiling/10_000);\\n        priceCeiling = newPriceCeiling_;\\n        emit newPriceCeiling(newPriceCeiling_);\\n    }\\n\\n    // **************************\\n    // ** GOVERNANCE FUNCTIONS **\\n    // **************************\\n\\n    /**\\n     * @dev Function for setting new governance, only callable by governance\\n     * @param newGovernance_ address of the new guardian\\n     */\\n    function setGovernance(address newGovernance_) external {\\n        require(msg.sender == governance);\\n        governance = newGovernance_;\\n        emit newGovernance(newGovernance_);\\n    }\\n\\n    /**\\n     * @dev Function for setting new guardian, only callable by governance\\n     * @param newGuardian_ address of the new guardian\\n     */\\n    function setGuardian(address newGuardian_) external {\\n        require(msg.sender == governance);\\n        guardian = newGuardian_;\\n        emit newGuardian(newGuardian_);\\n    }\\n\\n    /**\\n     * @dev Function for setting new max height of price ceiling in basis points. 1 = 0.01%\\n     * @param newMaxBPCeiling_ New maximum amount a ceiling can go above current price\\n     */\\n    function setMaxBPCeiling(uint newMaxBPCeiling_) external {\\n        require(msg.sender == governance);\\n        require(newMaxBPCeiling_ \\u003e= minBPCeiling);\\n        maxBPCeiling = newMaxBPCeiling_;\\n        emit newMaxBPCeiling(newMaxBPCeiling_);\\n    }\\n\\n    /**\\n     * @dev Function for setting new min height of price ceiling in basis points. 1 = 0.01%\\n     * @param newMinBPCeiling_ New minimum amount a ceiling must be above current price\\n     */\\n    function setMinBPCeiling(uint newMinBPCeiling_) external {\\n        require(msg.sender == governance);\\n        require(maxBPCeiling \\u003e= newMinBPCeiling_);\\n        minBPCeiling = newMinBPCeiling_;\\n        emit newMinBPCeiling(newMinBPCeiling_);\\n    }\\n\\n    // ************\\n    // ** EVENTS **\\n    // ************\\n    event newPriceCeiling(uint newPriceCeiling);\\n    event newGuardian(address newGuardian);\\n    event newGovernance(address newGovernance);\\n    event newMaxBPCeiling(uint newMaxBPCeiling);\\n    event newMinBPCeiling(uint newMinBPCeiling);\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"MIN_TWAP_TIME_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBPCeiling_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBPCeiling_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"newGovernance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"newGuardian\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxBPCeiling\",\"type\":\"uint256\"}],\"name\":\"newMaxBPCeiling\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinBPCeiling\",\"type\":\"uint256\"}],\"name\":\"newMinBPCeiling\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriceCeiling\",\"type\":\"uint256\"}],\"name\":\"newPriceCeiling\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_TWAP_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OBSERVATION_BUFFER\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBPCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBPCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"observationCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"observations\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"priceCumulative\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance_\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGuardian_\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxBPCeiling_\",\"type\":\"uint256\"}],\"name\":\"setMaxBPCeiling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinBPCeiling_\",\"type\":\"uint256\"}],\"name\":\"setMinBPCeiling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPriceCeiling_\",\"type\":\"uint256\"}],\"name\":\"setPriceCeiling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeSinceLastUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deviationThreshold\",\"type\":\"uint256\"}],\"name\":\"workable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniswapTwapPriceOracleV2Ceiling", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000708000000000000000000000000000000000000000000000000000000000000753000000000000000000000000000000000000000000000000000000000000013880000000000000000000000000000000000000000000000000000000000000012000000000000000000000000beccb6bb0aa4ab551966a7e4b97cec74bb359bf60000000000000000000000009f3614afb3df9f899cadbffaa05c6c908059f726", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ede3727970d9be06e640b739abd18799881d88c319b466afd6d2eaca16ccf284"}]}