{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/utils/ERC721.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\r\n/// @author Solmate (https://github.com/distractedm1nd/solmate/blob/main/src/tokens/ERC721.sol)\r\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\r\nabstract contract ERC721 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                          METADATA STORAGE/LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    function tokenURI(uint256 id) public view virtual returns (string memory);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC721 STORAGE                        \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(uint256 => address) public ownerOf;\r\n\r\n    mapping(uint256 => address) public getApproved;\r\n\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC721 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 id) public virtual {\r\n        address owner = ownerOf[id];\r\n\r\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\r\n\r\n        getApproved[id] = spender;\r\n\r\n        emit Approval(owner, spender, id);\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public virtual {\r\n        require(from == ownerOf[id], \"WRONG_FROM\");\r\n\r\n        require(to != address(0), \"INVALID_RECIPIENT\");\r\n\r\n        require(\r\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\r\n            \"NOT_AUTHORIZED\"\r\n        );\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        unchecked {\r\n            balanceOf[from]--;\r\n\r\n            balanceOf[to]++;\r\n        }\r\n\r\n        ownerOf[id] = to;\r\n\r\n        delete getApproved[id];\r\n\r\n        emit Transfer(from, to, id);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        bytes memory data\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC165 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\r\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\r\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                       INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 id) internal virtual {\r\n        require(to != address(0), \"INVALID_RECIPIENT\");\r\n\r\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\r\n\r\n        // Counter overflow is incredibly unrealistic.\r\n        unchecked {\r\n            totalSupply++;\r\n\r\n            balanceOf[to]++;\r\n        }\r\n\r\n        ownerOf[id] = to;\r\n\r\n        emit Transfer(address(0), to, id);\r\n    }\r\n\r\n    function _burn(uint256 id) internal virtual {\r\n        address owner = ownerOf[id];\r\n\r\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\r\n\r\n        // Ownership check above ensures no underflow.\r\n        unchecked {\r\n            totalSupply--;\r\n\r\n            balanceOf[owner]--;\r\n        }\r\n\r\n        delete ownerOf[id];\r\n\r\n        delete getApproved[id];\r\n\r\n        emit Transfer(owner, address(0), id);\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                       INTERNAL SAFE MINT LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _safeMint(address to, uint256 id) internal virtual {\r\n        _mint(to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 id,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _mint(to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n}\r\n\r\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File contracts/ApeX.sol\r\n\r\npragma solidity ^0.8.11;\r\n\r\n\r\n\r\nerror NoTokensLeft();\r\nerror SoldOut();\r\nerror TooManyMintAtOnce();\r\nerror TooManyMintForTier();\r\nerror NotEnoughETH();\r\nerror NotOnWhitelist();\r\nerror DoesNotExist();\r\nerror OnlyTokenOwnerCanSwap();\r\nerror WhitelistMintNotStarted();\r\nerror MintNotStarted();\r\nerror EmptyBalance();\r\nerror SwapNotOn();\r\nerror FreeMintNotStarted();\r\nerror NotOnFreeMintlist();\r\nerror CantMintMoreThanOnce();\r\nerror AlreadyMintedWhitelist();\r\n\r\n\r\n/*\r\n          :::    ::::::::: ::::::::::            :::    ::: \r\n       :+: :+:  :+:    :+::+:                   :+:    :+:  \r\n     +:+   +:+ +:+    +:++:+                    +:+  +:+    \r\n   +#++:++#++:+#++:++#+ +#++:++#   +#++:++#+    +#++:+      \r\n  +#+     +#++#+       +#+                    +#+  +#+      \r\n #+#     #+##+#       #+#                   #+#    #+#      \r\n###     ######       ##########            ###    ###    \r\n\r\n*/\r\n\r\n\r\n/// @title  ApeX contract \r\n/// @author @CrossChainLabs (https://canthedevsdosomething.com) \r\ncontract Apex is ERC721, Ownable {\r\n    using Strings for uint256;\r\n    \r\n     /*///////////////////////////////////////////////////////////////\r\n                                   AUTH\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    address constant gnosisSafeAddress = 0xBC3eD63c8DB00B47471CfBD747632E24be5Cb5cd;\r\n    address constant devWallet = 0x26a9c1618eF16Ab862D1eE54C6AAf851711e39bF;\r\n    address[15] private _freeMintWallets;\r\n    \r\n    /// Merkle roots\r\n    bytes32 private mainMerkleRoot;\r\n\r\n    /// Payout wallets \r\n    address[14] private _contributorWallets;\r\n\r\n    /// Contributor share split\r\n    mapping(address => uint256) private _contributorShares;\r\n\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                               MINT INFO\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 constant public maxSupply = 4400 + 44;\r\n    uint256 constant public mintPrice = 0.1 ether;\r\n    bool public whitelistMintStarted = false;\r\n    bool public freeMintStarted = false;\r\n    bool public mintStarted = false;\r\n    string public twoDimensionalBaseURI;\r\n    string public threeDimensionalBaseURI;\r\n    bool public swapOn = false;\r\n\r\n    /// @notice Maps tokenId to 2D (true) or 3D (false)\r\n    mapping(uint256 => bool) public tokenIdToUpgraded;\r\n\r\n    /// @notice Maps address to bool if they have minted or not\r\n    mapping(address => bool) private hasMinted;\r\n    mapping(address => bool) private hasWhitelistMinted;\r\n\r\n    uint256[5] private _tierAllocations;\r\n    mapping(address => uint256) private _freeMintersToAmount;\r\n    mapping(address => uint256) private numMintedPerFreeMinter;\r\n\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                               MODIFIERS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n     modifier onlyOwnerOrDev {\r\n        require(msg.sender == gnosisSafeAddress || msg.sender == devWallet || msg.sender == owner());\r\n        _;\r\n    }\r\n\r\n     modifier onlyTokenOwner(uint256 _tokenId) {\r\n        require(msg.sender == ownerOf[_tokenId], \"Only token owner can swap\");\r\n        _;\r\n    }\r\n\r\n    modifier amountLessThanTotalSupply (uint16 _amount) {\r\n        if(totalSupply + _amount > maxSupply) revert NoTokensLeft();\r\n        _;\r\n    }\r\n\r\n    modifier hasMintStarted {\r\n        if(!mintStarted) revert MintNotStarted();\r\n        _;\r\n    }\r\n\r\n    modifier isEnoughETH(uint16 amount) {\r\n        if (msg.value < amount * mintPrice) revert NotEnoughETH();\r\n        _;\r\n    }\r\n\r\n    modifier hasWalletMintedBefore() {\r\n        if (hasMinted[msg.sender] == true) revert CantMintMoreThanOnce();\r\n        _;\r\n    }\r\n\r\n    modifier hasWhitelistWalletMintedBefore() {\r\n        if (hasWhitelistMinted[msg.sender] == true) revert AlreadyMintedWhitelist();\r\n        _;\r\n    }\r\n\r\n    modifier isMintingLessThanMaxMint(uint16 _amount) {\r\n        require(_amount < 4, \"Max mints per mint is 3\");\r\n        _;\r\n    }\r\n\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                                INIT\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Mints 44 to the DAO Gnosis multisig wallet, sets the wallets, shares, and merkle roots for tiered mintlists\r\n    constructor (\r\n        string memory _baseURI, \r\n        uint256[14] memory shares, \r\n        address[14] memory wallets,\r\n        uint256[5] memory tierAllocations\r\n        ) \r\n        ERC721(\"ApeX\", \"APEX\") {\r\n        \r\n        twoDimensionalBaseURI = _baseURI;\r\n        _contributorWallets = wallets;\r\n        _tierAllocations = tierAllocations;\r\n\r\n        unchecked {\r\n            balanceOf[gnosisSafeAddress] += 44;\r\n            totalSupply += 44;\r\n            for (uint256 i = 1; i <= 44; i++) {\r\n                ownerOf[i] = gnosisSafeAddress;\r\n            }\r\n        }\r\n\r\n        /// @notice Initializes the contributor wallets\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            _contributorShares[_contributorWallets[i]] = shares[i];\r\n        }\r\n    }\r\n\r\n    /// @notice Initializes the freemint wallets and their mint amount\r\n    function setFreeMintAddresses(address[15] memory freeMintAddresses, uint256[15] memory freeMintAmounts) external onlyOwnerOrDev {\r\n        for (uint256 i = 0; i < freeMintAddresses.length; i++) {\r\n            _freeMintersToAmount[freeMintAddresses[i]] = freeMintAmounts[i];\r\n        }\r\n    }\r\n\r\n    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwnerOrDev {\r\n        mainMerkleRoot = _merkleRoot;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                          MERKLE VALIDATION\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev    Add a hashed address to the merkle tree as a leaf\r\n    /// @param  account Leaf address for MerkleTree\r\n    /// @return bytes32 hashed version of the merkle leaf address\r\n    function _leaf(address account) private pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(account));\r\n    }\r\n\r\n    /// @dev    Verify the whitelist using the merkle tree\r\n    /// @param  leaf Hashed address leaf from _leaf() to search for\r\n    /// @param  proof Submitted root proof from MerkleTree\r\n    /// @return bool True if address is allowed to mint\r\n    function verifyMerkle(bytes32 leaf, bytes32[] memory proof, bytes32 merkleRoot) private pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash < proofElement) {\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(computedHash, proofElement)\r\n                );\r\n            } else {\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(proofElement, computedHash)\r\n                );\r\n            }\r\n        }\r\n\r\n        return computedHash == merkleRoot;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            MINTING LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev   Whitelist mint\r\n    /// @param amount Number of requested mints\r\n    /// @param tier Whitelist tier of minter\r\n    /// @param _proof Submitted root proof from MerkleTree for whitelist\r\n    function whitelistMint(address account, uint16 amount, uint256 tier, bytes32[] memory _proof) external payable \r\n        amountLessThanTotalSupply(amount) \r\n        isEnoughETH(amount) \r\n        hasWhitelistWalletMintedBefore\r\n    {\r\n        if (amount > _tierAllocations[tier]) revert TooManyMintForTier();\r\n        if (!whitelistMintStarted) revert WhitelistMintNotStarted();\r\n        if (verifyMerkle(_leaf(account), _proof, mainMerkleRoot) == false) revert NotOnWhitelist();\r\n        hasWhitelistMinted[msg.sender] = true;\r\n\r\n        unchecked {\r\n            for (uint16 i = 0; i < amount; i++) {\r\n                _mint(msg.sender, totalSupply + 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    function generalMint(uint16 amount) external payable \r\n        isMintingLessThanMaxMint(amount)\r\n        amountLessThanTotalSupply(amount) \r\n        isEnoughETH(amount) \r\n        hasMintStarted \r\n        hasWalletMintedBefore\r\n    {\r\n        hasMinted[msg.sender] = true;\r\n\r\n        unchecked {\r\n            for (uint16 index = 0; index < amount; index++) {\r\n                _mint(msg.sender, totalSupply + 1);\r\n            }   \r\n        }\r\n    }\r\n\r\n    /// @notice Mints a free token for a given address\r\n    function freeMint(address account, uint16 amount, bytes32[] memory _proof) external payable \r\n        amountLessThanTotalSupply(amount)  \r\n    {\r\n        require(amount + numMintedPerFreeMinter[msg.sender] < _freeMintersToAmount[msg.sender] + 1, \"Trying to mint more than your free mint allocation\"); \r\n        require(_freeMintersToAmount[msg.sender] > 0, \"Not on freemint list\");\r\n\r\n        if (!freeMintStarted) revert FreeMintNotStarted();\r\n        if (verifyMerkle(_leaf(account), _proof, mainMerkleRoot) == false) revert NotOnFreeMintlist();\r\n        numMintedPerFreeMinter[msg.sender] += amount;\r\n\r\n        unchecked {\r\n            for (uint16 i = 0; i < amount; i++) {\r\n                _mint(msg.sender, totalSupply + 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    function toggleWhitelistMint() public onlyOwnerOrDev {\r\n        whitelistMintStarted = !whitelistMintStarted;\r\n    }\r\n\r\n    function toggleFreeMint() public onlyOwnerOrDev {\r\n        freeMintStarted = !freeMintStarted;\r\n    }\r\n\r\n    function toggleGeneralMint() public onlyOwnerOrDev {\r\n        mintStarted = !mintStarted;\r\n    }\r\n\r\n    /// @notice Withdraw to Gnosis multisig and associated wallets\r\n    function withdraw() external onlyOwnerOrDev {\r\n        if (address(this).balance == 0) revert EmptyBalance();\r\n        uint256 currentBalance = address(this).balance;\r\n        for (uint256 i=0; i < _contributorWallets.length; i++) {\r\n            (bool success, ) = _contributorWallets[i].call{value: (currentBalance * _contributorShares[_contributorWallets[i]] / 10000)}(\"\");\r\n            require(success);\r\n        }\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                        METADATA SWAPPING LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Set the metadata URI for IPFS\r\n    /// @param _baseURI The URI to set\r\n    function setTwoDimensionalBaseURI(string memory _baseURI) public {\r\n        twoDimensionalBaseURI = _baseURI;\r\n    }\r\n\r\n    function setThreeDimensionalBaseURI(string memory _threeDimensionalBaseURI) public onlyOwnerOrDev {\r\n        threeDimensionalBaseURI = _threeDimensionalBaseURI;\r\n    }\r\n\r\n\r\n    /// @notice Base assumption is that the mapping tokenId is false\r\n    function swap(uint256 tokenId) external onlyTokenOwner(tokenId) {\r\n        if (swapOn == false) revert SwapNotOn();\r\n        /// if it is 3D\r\n        if (tokenIdToUpgraded[tokenId] == true) {\r\n            /// change tokenId URI to 2D\r\n            tokenIdToUpgraded[tokenId] = !tokenIdToUpgraded[tokenId];\r\n        } else {\r\n            /// change tokenId URI to 3D\r\n            tokenIdToUpgraded[tokenId] = true;\r\n        }\r\n    }\r\n\r\n\r\n    function toggleSwap() public onlyOwner {\r\n        swapOn = !swapOn;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        if (ownerOf[tokenId] == address(0)) revert DoesNotExist();\r\n\r\n        if (tokenIdToUpgraded[tokenId] == true) {\r\n            return string(abi.encodePacked(threeDimensionalBaseURI, tokenId.toString()));\r\n        } else {\r\n            return string(abi.encodePacked(twoDimensionalBaseURI, tokenId.toString()));\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"},{\"internalType\":\"uint256[14]\",\"name\":\"shares\",\"type\":\"uint256[14]\"},{\"internalType\":\"address[14]\",\"name\":\"wallets\",\"type\":\"address[14]\"},{\"internalType\":\"uint256[5]\",\"name\":\"tierAllocations\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyMintedWhitelist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantMintMoreThanOnce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FreeMintNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokensLeft\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOnFreeMintlist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOnWhitelist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapNotOn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyMintForTier\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WhitelistMintNotStarted\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"freeMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeMintStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"}],\"name\":\"generalMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[15]\",\"name\":\"freeMintAddresses\",\"type\":\"address[15]\"},{\"internalType\":\"uint256[15]\",\"name\":\"freeMintAmounts\",\"type\":\"uint256[15]\"}],\"name\":\"setFreeMintAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_threeDimensionalBaseURI\",\"type\":\"string\"}],\"name\":\"setThreeDimensionalBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setTwoDimensionalBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threeDimensionalBaseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleFreeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleGeneralMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleWhitelistMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToUpgraded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twoDimensionalBaseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"tier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMintStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Apex", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000044000000000000000000000000000000000000000000000000000000000000009c400000000000000000000000000000000000000000000000000000000000006fc0000000000000000000000000000000000000000000000000000000000000651000000000000000000000000000000000000000000000000000000000000040f00000000000000000000000000000000000000000000000000000000000002a3000000000000000000000000000000000000000000000000000000000000023f000000000000000000000000000000000000000000000000000000000000023f00000000000000000000000000000000000000000000000000000000000001a9000000000000000000000000000000000000000000000000000000000000012c00000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000000096000000000000000000000000000000000000000000000000000000000000004b00000000000000000000000000000000000000000000000000000000000000380000000000000000000000000000000000000000000000000000000000000019000000000000000000000000bc3ed63c8db00b47471cfbd747632e24be5cb5cd0000000000000000000000000085aa7890a594de17fcb17ae4b8592af28792ae0000000000000000000000001176006b50cc7478c09955b473b480de6eb26eb60000000000000000000000001ba41eea43d89dcf4a164d99163d1dff585e314600000000000000000000000026a9c1618ef16ab862d1ee54c6aaf851711e39bf000000000000000000000000d2ad305480954330a7f57a533a4a697700bf532900000000000000000000000085b6cd0b45d450639daae4d0ae0241ad17c6cadf000000000000000000000000d113c24746dc9e80faec0f1a80b012dd7707e26b0000000000000000000000002d28f2687944dab17b2d5ea3ffac7e4646ce1ba90000000000000000000000004e325690b7e0e9d2961fb611a119e2c67f00963b000000000000000000000000cabfccb1167dd2bf0d6698341384f07e7f442862000000000000000000000000361805c2314104c2e2d48b52dfcd46662f9428fe00000000000000000000000052d6b9e72a6280311fb6f438e24e6582e3e6fff700000000000000000000000009ff88685141c185b139dfaacedb67520727de6500000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004468747470733a2f2f697066732e696f2f697066732f516d66324a6a34357774614e73384e6a6e6f7264354e4c6537364a75316b53705959777a4231367a6741326f434d2f00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c885adb4ec72400f3f45d870094de69cac191062e885493d7df72dc882866c0d"}]}