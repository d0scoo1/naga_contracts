{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\",\r\n          \"stackAllocation\": true\r\n        }\r\n      },\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"./interfaces/ITPirates.sol\\\";\\r\\nimport \\\"./interfaces/IPirates.sol\\\";\\r\\n\\r\\ncontract TPirates is ITPirates {\\r\\n    using Strings for uint256;\\r\\n\\r\\n    // struct to store each trait's data for metadata and rendering\\r\\n    struct Trait {\\r\\n        string name;\\r\\n        string png;\\r\\n    }\\r\\n\\r\\n    // mapping from trait type index to its name\\r\\n    string[9] _traitTypes = [\\r\\n        \\\"Sky\\\",\\r\\n        \\\"Cockpit\\\",\\r\\n        \\\"Base\\\",\\r\\n        \\\"Engine\\\",\\r\\n        \\\"Nose\\\",\\r\\n        \\\"Wing\\\",\\r\\n        \\\"Weapon1\\\",\\r\\n        \\\"Weapon2\\\",\\r\\n        \\\"Rank\\\"\\r\\n    ];\\r\\n\\r\\n    address public auth;\\r\\n\\r\\n    // storage of each traits name and base64 PNG data\\r\\n    mapping(uint8 => mapping(uint8 => Trait)) public traitData;\\r\\n\\r\\n\\r\\n    IPirates public piNFT;\\r\\n\\r\\n    constructor() {\\r\\n    auth = msg.sender;\\r\\n    }\\r\\n    /** ADMIN */\\r\\n\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == auth);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setPirates(address _piNFT) external onlyOwner {\\r\\n        piNFT = IPirates(_piNFT);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * administrative to upload the names and images associated with each trait\\r\\n     * @param traitType the trait type to upload the traits for (see traitTypes for a mapping)\\r\\n     * @param traits the names and base64 encoded PNGs for each trait\\r\\n     */\\r\\n    function uploadTraits(\\r\\n        uint8 traitType,\\r\\n        uint8[] calldata traitIds,\\r\\n        Trait[] calldata traits\\r\\n    ) external onlyOwner {\\r\\n        require(traitIds.length == traits.length, \\\"Mismatched inputs\\\");\\r\\n        for (uint256 i = 0; i < traits.length; i++) {\\r\\n            traitData[traitType][traitIds[i]] = Trait(\\r\\n                traits[i].name,\\r\\n                traits[i].png\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** RENDER */\\r\\n\\r\\n    /**\\r\\n     * generates an <image> element using base64 encoded PNGs\\r\\n     * @param trait the trait storing the PNG data\\r\\n     * @return the <image> element\\r\\n     */\\r\\n    function drawTrait(Trait memory trait)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory)\\r\\n    {\\r\\n        return\\r\\n            string(\\r\\n                abi.encodePacked(\\r\\n                    '<image x=\\\"0\\\" y=\\\"0\\\" width=\\\"64\\\" height=\\\"64\\\" image-rendering=\\\"pixelated\\\" preserveAspectRatio=\\\"xMidYMid\\\" xlink:href=\\\"data:image/png;base64,',\\r\\n                    trait.png,\\r\\n                    '\\\"/>'\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * generates an entire SVG by composing multiple <image> elements of PNGs\\r\\n     * @param tokenId the ID of the token to generate an SVG for\\r\\n     * @return a valid SVG of the Pirate\\r\\n     */\\r\\n    function drawSVG(uint256 tokenId) public view returns (string memory) {\\r\\n        IPirates.Pirate memory q = piNFT.getTokenTraitsPirate(tokenId);\\r\\n        string memory svgString = string(\\r\\n            abi.encodePacked(\\r\\n                drawTrait(traitData[0][q.sky]),\\r\\n                drawTrait(traitData[1][q.cockpit]),\\r\\n                drawTrait(traitData[2][q.base]),\\r\\n                drawTrait(traitData[3][q.engine]),\\r\\n                drawTrait(traitData[4][q.nose]),\\r\\n                drawTrait(traitData[5][q.wing]),\\r\\n                drawTrait(traitData[6][q.weapon1]),\\r\\n                drawTrait(traitData[7][q.weapon2]),\\r\\n                drawTrait(traitData[8][q.rank])\\r\\n            )\\r\\n        );\\r\\n\\r\\n        return\\r\\n            string(\\r\\n                abi.encodePacked(\\r\\n                    '<svg id=\\\"galaxyGame\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 64 64\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">',\\r\\n                    svgString,\\r\\n                    \\\"</svg>\\\"\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * generates an attribute for the attributes array in the ERC721 metadata standard\\r\\n     * @param traitType the trait type to reference as the metadata key\\r\\n     * @param value the token's trait associated with the key\\r\\n     * @return a JSON dictionary for the single attribute\\r\\n     */\\r\\n    function attributeForTypeAndValue(\\r\\n        string memory traitType,\\r\\n        string memory value\\r\\n    ) internal pure returns (string memory) {\\r\\n        return\\r\\n            string(\\r\\n                abi.encodePacked(\\r\\n                    '{\\\"trait_type\\\":\\\"',\\r\\n                    traitType,\\r\\n                    '\\\",\\\"value\\\":\\\"',\\r\\n                    value,\\r\\n                    '\\\"}'\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * generates an array composed of all the individual traits and values\\r\\n     * @param tokenId the ID of the token to compose the metadata for\\r\\n     * @return a JSON array of all of the attributes for given token ID\\r\\n     */\\r\\n    function compileAttributes(uint256 tokenId)\\r\\n        public\\r\\n        view\\r\\n        returns (string memory)\\r\\n    {\\r\\n        IPirates.Pirate memory q = piNFT.getTokenTraitsPirate(tokenId);\\r\\n        string memory traits;\\r\\n        traits = string(\\r\\n            abi.encodePacked(\\r\\n                attributeForTypeAndValue(\\r\\n                    _traitTypes[0],\\r\\n                    traitData[0][q.sky].name\\r\\n                ),\\r\\n                \\\",\\\",\\r\\n                attributeForTypeAndValue(\\r\\n                    _traitTypes[1],\\r\\n                    traitData[1][q.cockpit].name\\r\\n                ),\\r\\n                \\\",\\\",\\r\\n                attributeForTypeAndValue(\\r\\n                    _traitTypes[2],\\r\\n                    traitData[2][q.base].name\\r\\n                ),\\r\\n                \\\",\\\",\\r\\n                attributeForTypeAndValue(\\r\\n                    _traitTypes[3],\\r\\n                    traitData[3][q.engine].name\\r\\n                ),\\r\\n                \\\",\\\",\\r\\n                attributeForTypeAndValue(\\r\\n                    _traitTypes[4],\\r\\n                    traitData[4][q.nose].name\\r\\n                ),\\r\\n                \\\",\\\",\\r\\n                attributeForTypeAndValue(\\r\\n                    _traitTypes[5],\\r\\n                    traitData[5][q.wing].name\\r\\n                ),\\r\\n                \\\",\\\",\\r\\n                attributeForTypeAndValue(\\r\\n                    _traitTypes[6],\\r\\n                    traitData[6][q.weapon1].name\\r\\n                ),\\r\\n                \\\",\\\",\\r\\n                attributeForTypeAndValue(\\r\\n                    _traitTypes[7],\\r\\n                    traitData[7][q.weapon2].name\\r\\n                ),\\r\\n                \\\",\\\",\\r\\n                attributeForTypeAndValue(\\r\\n                    _traitTypes[8], \\r\\n                    traitData[8][q.rank].name\\r\\n                ),\\r\\n                \\\",\\\"\\r\\n            )\\r\\n        );\\r\\n        return\\r\\n            string(\\r\\n                abi.encodePacked(\\r\\n                    \\\"[\\\",\\r\\n                    traits,\\r\\n                    '{\\\"trait_type\\\":\\\"Generation\\\",\\\"value\\\":',\\r\\n                    tokenId <= 888 ? '\\\"Gen 0\\\"' : '\\\"Gen 1\\\"',\\r\\n                    '},{\\\"trait_type\\\":\\\"Type\\\",\\\"value\\\": \\\"Pirate\\\"',\\r\\n                    \\\"}]\\\"\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * generates a base64 encoded metadata response without referencing off-chain content\\r\\n     * @param tokenId the ID of the token to generate the metadata for\\r\\n     * @return a base64 encoded JSON dictionary of the token's metadata and SVG\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (string memory)\\r\\n    {\\r\\n        require(msg.sender == address(piNFT));\\r\\n        string memory tokenName = piNFT.tokenNameByIndex(tokenId);\\r\\n        bool hasName = piNFT.hasBeenNamed(tokenId);\\r\\n\\r\\n        string memory metadata = string(\\r\\n            abi.encodePacked(\\r\\n                '{\\\"name\\\": \\\"',\\r\\n                \\\"Pirate  \\\",\\r\\n                hasName ? tokenName : tokenId.toString(),\\r\\n                '\\\", \\\"description\\\": \\\"Ai-Lax Pirates are known for their lethal tactics and an unrelenting dismissal of all Imperial Guild edicts. They will do anything and everything to get their hands on newly mined EON. This includes orbital blockades to strong arm Miners for a piece of their hard work and even kidnapping new ones that enter the Pytheas system. Tread cautiously as you traverse the darkness, you could be their next target. All the metadata and images are generated and stored 100% on-chain. No IPFS. NO API. Just the Ethereum blockchain.\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,',\\r\\n                base64(bytes(drawSVG(tokenId))),\\r\\n                '\\\", \\\"attributes\\\":',\\r\\n                compileAttributes(tokenId),\\r\\n                \\\"}\\\"\\r\\n            )\\r\\n        );\\r\\n        return\\r\\n            string(\\r\\n                abi.encodePacked(\\r\\n                    \\\"data:application/json;base64,\\\",\\r\\n                    base64(bytes(metadata))\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /** BASE 64 - Written by Brech Devos */\\r\\n    string internal constant TABLE =\\r\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\r\\n\\r\\n    function base64(bytes memory data) internal pure returns (string memory) {\\r\\n        if (data.length == 0) return \\\"\\\";\\r\\n\\r\\n        // load the table into memory\\r\\n        string memory table = TABLE;\\r\\n\\r\\n        // multiply by 4/3 rounded up\\r\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\r\\n\\r\\n        // add some extra buffer at the end required for the writing\\r\\n        string memory result = new string(encodedLen + 32);\\r\\n\\r\\n        assembly {\\r\\n            // set the actual output length\\r\\n            mstore(result, encodedLen)\\r\\n\\r\\n            // prepare the lookup table\\r\\n            let tablePtr := add(table, 1)\\r\\n\\r\\n            // input ptr\\r\\n            let dataPtr := data\\r\\n            let endPtr := add(dataPtr, mload(data))\\r\\n\\r\\n            // result ptr, jump over length\\r\\n            let resultPtr := add(result, 32)\\r\\n\\r\\n            // run over the input, 3 bytes at a time\\r\\n            for {\\r\\n\\r\\n            } lt(dataPtr, endPtr) {\\r\\n\\r\\n            } {\\r\\n                dataPtr := add(dataPtr, 3)\\r\\n\\r\\n                // read 3 bytes\\r\\n                let input := mload(dataPtr)\\r\\n\\r\\n                // write 4 characters\\r\\n                mstore(\\r\\n                    resultPtr,\\r\\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\r\\n                )\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n                mstore(\\r\\n                    resultPtr,\\r\\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\r\\n                )\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n                mstore(\\r\\n                    resultPtr,\\r\\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\r\\n                )\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n                mstore(\\r\\n                    resultPtr,\\r\\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\\r\\n                )\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n            }\\r\\n\\r\\n            // padding with '='\\r\\n            switch mod(mload(data), 3)\\r\\n            case 1 {\\r\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\r\\n            }\\r\\n            case 2 {\\r\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPirates {\\r\\n    // struct to store each Colonist's traits\\r\\n    struct Pirate {\\r\\n        bool isPirate;\\r\\n        uint8 sky;\\r\\n        uint8 cockpit;\\r\\n        uint8 base;\\r\\n        uint8 engine;\\r\\n        uint8 nose;\\r\\n        uint8 wing;\\r\\n        uint8 weapon1;\\r\\n        uint8 weapon2;\\r\\n        uint8 rank;\\r\\n    }\\r\\n\\r\\n    struct HPirates {\\r\\n        uint8 Legendary;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n\\r\\n    function piratesMinted() external returns (uint16);\\r\\n\\r\\n    function isOwner(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function _mintPirate(address recipient, uint256 seed) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function getTokenTraitsPirate(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (Pirate memory);\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (HPirates memory);\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n    \\r\\n    function isHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function namePirate(uint256 tokenId, string memory newName) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ITPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ITPirates {\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"compileAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"drawSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piNFT\",\"outputs\":[{\"internalType\":\"contract IPirates\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_piNFT\",\"type\":\"address\"}],\"name\":\"setPirates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"png\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"traitType\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"traitIds\",\"type\":\"uint8[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"png\",\"type\":\"string\"}],\"internalType\":\"struct TPirates.Trait[]\",\"name\":\"traits\",\"type\":\"tuple[]\"}],\"name\":\"uploadTraits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TPirates", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}