{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/token/ERC721/GardenCenter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\n \\r\\n/**\\r\\n* This is a Garden Center from Rarity.Garden that allows gas efficient trading for a specific collection.\\r\\n* Please read the \\\"collection\\\" property for which collection this instance has been created.\\r\\n*\\r\\n* Site:    https://rarity.garden/\\r\\n* Discord: https://discord.gg/Ur8XGaurSd\\r\\n* Twitter: https://t.me/raritygarden\\r\\n*/\\r\\ncontract GardenCenter\\r\\n{\\r\\n\\r\\n    using Strings for uint256;\\r\\n\\r\\n    struct Listing{\\r\\n        uint32 price;\\r\\n        address owner;\\r\\n    }\\r\\n\\r\\n    bool public initialized;\\r\\n    bool public isCollectionOwner;\\r\\n    uint16 public rate;\\r\\n    address public creator;\\r\\n    address public collection;\\r\\n    address public factory;\\r\\n    mapping(uint256 => Listing) public listings;\\r\\n\\r\\n    event Sale(address indexed _seller, address indexed _buyer, uint256 indexed _tokenId, uint256 _price);\\r\\n    event Offer(address indexed _seller, uint256 indexed _tokenId, uint256 _price);\\r\\n    event Removed(address indexed _owner, uint256 indexed _tokenId);\\r\\n\\r\\n    constructor(address _collection)  {\\r\\n\\r\\n        require(!initialized, \\\"already initialized.\\\");\\r\\n\\r\\n        collection = _collection;\\r\\n        creator = msg.sender;\\r\\n        initialized = true;\\r\\n        rate = 50;\\r\\n        isCollectionOwner = true;\\r\\n    }\\r\\n\\r\\n    function construct(address _collection, address _sender, bool _isCollectionOwner) external {\\r\\n\\r\\n        require(!initialized, \\\"init: already initialized.\\\");\\r\\n\\r\\n        collection = _collection;\\r\\n        creator = _sender;\\r\\n        initialized = true;\\r\\n        rate = 50;\\r\\n        factory = msg.sender;\\r\\n        isCollectionOwner = _isCollectionOwner;\\r\\n    }\\r\\n\\r\\n    function updateCreator(address _creator) external{\\r\\n\\r\\n        require(IERC721(0x13fD344E39C30187D627e68075d6E9201163DF33).balanceOf(msg.sender) != 0, \\\"updateCreator: not an RG unicorn holder.\\\");\\r\\n        require(msg.sender == creator, \\\"updateCreator: not the current creator.\\\");\\r\\n\\r\\n        creator = _creator;\\r\\n    }\\r\\n\\r\\n    function updateRate(uint16 _rate) external{\\r\\n\\r\\n        require(IERC721(0x13fD344E39C30187D627e68075d6E9201163DF33).balanceOf(msg.sender) != 0, \\\"updateRate: not an RG unicorn holder.\\\");\\r\\n        require(msg.sender == creator, \\\"updateRate: not the current creator.\\\");\\r\\n        require(_rate <= 2500, \\\"updateRate: max. 25% fee allowed.\\\");\\r\\n        require(isCollectionOwner, \\\"updateRate: not created by collection owner, default rate is .5% fixed.\\\");\\r\\n\\r\\n        rate = _rate;\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n\\r\\n        string memory _string = msg.value.toString();\\r\\n        _string = fillZeros( _string );\\r\\n        string memory _input = reverse( _string );\\r\\n        string memory _flag = getSlice( _input, 14, 1 );\\r\\n\\r\\n         if( strCmp( _flag, \\\"0\\\" ) ){\\r\\n\\r\\n            string memory _slice = getSlice( _input, 1, 14 );\\r\\n            string memory _inputOffer = reverse( _slice );\\r\\n\\r\\n            string memory _tokenIdStr = getSlice( _inputOffer, 2, 5 );\\r\\n            uint256 tokenId = toUint( _tokenIdStr );\\r\\n\\r\\n            require(msg.sender == IERC721(collection).ownerOf(tokenId), \\\"receive: not the owner.\\\");\\r\\n\\r\\n            _inputOffer = getSlice( _inputOffer, 7, 8 );\\r\\n            uint256 price = toUint( _inputOffer );\\r\\n\\r\\n            require(price != 0, \\\"receive: price must be larger than zero.\\\");\\r\\n\\r\\n            listings[tokenId] = Listing( uint32(price), msg.sender );\\r\\n\\r\\n            emit Offer(msg.sender, tokenId, price * 10**14);\\r\\n        }\\r\\n        else if( strCmp( _flag, \\\"1\\\" ) ){\\r\\n\\r\\n            uint16 _rate = rate;\\r\\n            string memory _slice = getSlice( _input, 9, 5 );\\r\\n            _slice = reverse( _slice );\\r\\n            uint256 tokenId = toUint( _slice );\\r\\n            address _ownerOf = IERC721(collection).ownerOf(tokenId);\\r\\n            Listing memory listing = listings[tokenId];\\r\\n\\r\\n            require(listing.owner != address(0) && listing.owner == _ownerOf, \\\"receive: invalid listing.\\\");\\r\\n\\r\\n            uint256 _price = listing.price;\\r\\n\\r\\n            require(_price != 0, \\\"receive: token not for sale.\\\");\\r\\n\\r\\n            _price *= 10**14;\\r\\n            _slice = getSlice( _input, 15, bytes(_input).length - 14 );\\r\\n            _slice = reverse( _slice );\\r\\n\\r\\n            uint256 _value = toUint( _slice );\\r\\n            _value *= 10**14;\\r\\n            \\r\\n            require(_value == _price, \\\"receive: please send the exact value.\\\");\\r\\n\\r\\n            delete listings[tokenId];\\r\\n\\r\\n            emit Sale(_ownerOf, msg.sender, tokenId, _price);\\r\\n\\r\\n            uint256 _fee = _value;\\r\\n            _fee *= 10**18;\\r\\n            _fee /= 100;\\r\\n            _fee *= _rate;\\r\\n            _fee /= 10**20;\\r\\n\\r\\n            (bool success,) = payable(_ownerOf).call{value:_value - _fee}(\\\"\\\");\\r\\n            require(success, \\\"receive: eth transfer failed.\\\");\\r\\n\\r\\n            (success,) = payable(creator).call{value:_fee}(\\\"\\\");\\r\\n            require(success, \\\"receive: creator fee transfer failed.\\\");\\r\\n\\r\\n            IERC721(collection).safeTransferFrom(_ownerOf, msg.sender, tokenId);\\r\\n\\r\\n        } \\r\\n        else if( strCmp( _flag, \\\"2\\\" ) ){\\r\\n\\r\\n            string memory _slice = getSlice( _input, 9, 5 );\\r\\n            string memory _tokenIdStr = reverse( _slice );\\r\\n            uint256 tokenId = toUint( _tokenIdStr );\\r\\n\\r\\n            require(msg.sender == IERC721(collection).ownerOf(tokenId), \\\"receive: not the owner.\\\");\\r\\n\\r\\n            delete listings[tokenId];\\r\\n\\r\\n            emit Removed(msg.sender, tokenId);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            revert();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getSlice(string memory source, uint startPos, uint numChars) internal pure returns (string memory) {\\r\\n       uint ustartPos = uint(startPos -1);\\r\\n       uint _numChars = uint(numChars);\\r\\n\\r\\n        bytes memory sourcebytes = bytes(source);\\r\\n       if (_numChars==0) {\\r\\n           _numChars = ((sourcebytes.length - ustartPos) + 1);\\r\\n       }\\r\\n      \\r\\n      bytes memory result = new bytes(_numChars);     \\r\\n\\r\\n      for (uint i = 0; i<_numChars; i++) {\\r\\n          result[i] = sourcebytes[i + ustartPos];\\r\\n      }\\r\\n      return string(result); \\r\\n    }\\r\\n\\r\\n    function strCmp(string memory s1, string memory s2) internal pure returns (bool)\\r\\n    {\\r\\n        return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));\\r\\n    }\\r\\n\\r\\n    function fillZeros(string memory _str) internal pure returns(string memory) {\\r\\n\\r\\n        bytes memory str = bytes(_str);\\r\\n\\r\\n        if(str.length >= 18){\\r\\n\\r\\n            return _str;\\r\\n        }\\r\\n\\r\\n        uint256 size = 18 - str.length;\\r\\n        string memory tmp = new string(str.length + size);\\r\\n        bytes memory _new = bytes(tmp);\\r\\n\\r\\n        for(uint i = 0; i < size; i++) {\\r\\n\\r\\n            _new[i] = \\\"0\\\";\\r\\n        }\\r\\n\\r\\n        for(uint i = 0; i < str.length; i++) {\\r\\n\\r\\n            _new[i + size] = str[i];\\r\\n        }\\r\\n\\r\\n        return string(_new);\\r\\n    }\\r\\n\\r\\n    function reverse(string memory _str) internal pure returns(string memory) {\\r\\n        bytes memory str = bytes(_str);\\r\\n        string memory tmp = new string(str.length);\\r\\n        bytes memory _reverse = bytes(tmp);\\r\\n\\r\\n        for(uint i = 0; i < str.length; i++) {\\r\\n            _reverse[str.length - i - 1] = str[i];\\r\\n        }\\r\\n        return string(_reverse);\\r\\n    }\\r\\n\\r\\n    function toUint(string memory numString) internal pure returns(uint) {\\r\\n        uint val = 0;\\r\\n        bytes   memory stringBytes = bytes(numString);\\r\\n        bool leading = true;\\r\\n        for (uint  i =  0; i<stringBytes.length; i++) {\\r\\n            uint exp = stringBytes.length - i;\\r\\n            bytes1 ival = stringBytes[i];\\r\\n            uint8 uval = uint8(ival);\\r\\n            uint jval = uval - uint(0x30);\\r\\n            uint _val =  (uint(jval) * (10**(exp-1))); \\r\\n            if(_val == 0 && leading){\\r\\n                continue;\\r\\n            } else if( _val != 0 && leading ){\\r\\n                leading = false;\\r\\n            }\\r\\n            val += _val;\\r\\n        }\\r\\n      return val;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Offer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Removed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Sale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"collection\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isCollectionOwner\",\"type\":\"bool\"}],\"name\":\"construct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCollectionOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listings\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"price\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"updateCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_rate\",\"type\":\"uint16\"}],\"name\":\"updateRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GardenCenter", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000013fd344e39c30187d627e68075d6e9201163df33", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}