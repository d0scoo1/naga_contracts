{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@theappstudio/solidity/contracts/utils/Randomization.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./RandomizationErrors.sol\\\";\\n\\n/// @title Randomization library\\n/// @dev Lightweight library used for basic randomization capabilities for ERC-721 tokens when an Oracle is not available\\nlibrary Randomization {\\n\\n\\t/// Returns a value based on the spread of a random uint8 seed and provided percentages\\n\\t/// @dev The last percentage is assumed if the sum of all elements do not add up to 100, in which case the length of the array is returned\\n\\t/// @param random A uint8 random value\\n\\t/// @param percentages An array of percentages\\n\\t/// @return The index in which the random seed falls, which can be the length of the input array if the values do not add up to 100\\n\\tfunction randomIndex(uint8 random, uint8[] memory percentages) internal pure returns (uint256) {\\n\\t\\tuint256 spread = (3921 * uint256(random) / 10000) % 100; // 0-255 needs to be balanced to evenly spread with % 100\\n\\t\\tuint256 remainingPercent = 100;\\n\\t\\tfor (uint256 i = 0; i < percentages.length; i++) {\\n\\t\\t\\tuint256 nextPercentage = percentages[i];\\n\\t\\t\\tif (remainingPercent < nextPercentage) revert PercentagesGreaterThan100();\\n\\t\\t\\tremainingPercent -= nextPercentage;\\n\\t\\t\\tif (spread >= remainingPercent) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn percentages.length;\\n\\t}\\n\\n\\t/// Returns a random seed suitable for ERC-721 attribute generation when an Oracle such as Chainlink VRF is not available to a contract\\n\\t/// @dev Not suitable for mission-critical code. Always be sure to perform an analysis of your randomization before deploying to production\\n\\t/// @param initialSeed A uint256 that seeds the randomization function\\n\\t/// @return A seed that can be used for attribute generation, which may also be used as the `initialSeed` for a future call\\n\\tfunction randomSeed(uint256 initialSeed) internal view returns (uint256) {\\n\\t\\t// Unit tests should confirm that this provides a more-or-less even spread of randomness\\n\\t\\treturn uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), msg.sender, initialSeed >> 1)));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@theappstudio/solidity/contracts/utils/RandomizationErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @dev When the percentages array sum up to more than 100\\nerror PercentagesGreaterThan100();\\n\"\r\n    },\r\n    \"contracts/interfaces/IGameLogicProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"../utils/GameUtils.sol\\\";\\n\\n/// @title Provides support for the TicTacDao game\\ninterface IGameLogicProvider is IERC165 {\\n\\n\\t/// @dev When the game tokenId does not exist\\n\\terror NonexistentGame();\\n\\n\\t/// @dev When total game quantity has been reached (see you on secondary markets)\\n\\terror SoldOut();\\n\\n\\t/// Creates the specified number of newly initialized games\\n\\t/// @dev May throw SoldOut if the quantity results in too many games\\n\\t/// @param quantity The number of games to create\\n\\t/// @return startingGameId The starting gameId of the set\\n\\tfunction createGames(uint256 quantity) external returns (uint256 startingGameId);\\n\\n\\t/// Processes the player's move and updates the state\\n\\t/// @dev May throw NonexistentGame, or InvalidMove if the position is invalid given the state\\n\\t/// @param gameId The token id of the game\\n\\t/// @param position The position of the player's next move\\n\\t/// @return resultingState The resulting state of the game\\n\\tfunction processMove(uint256 gameId, uint256 position) external returns (ITicTacToe.GameState resultingState);\\n\\n\\t/// Restarts a game\\n\\t/// @param gameId The token id of the game to restart\\n\\tfunction restartGame(uint256 gameId) external;\\n\\n\\t/// Returns the `ITicTacToe.Game` info for the specified `tokenId`\\n\\t/// @param gameId The token id of the game\\n\\tfunction ticTacToeGame(uint256 gameId) external view returns (ITicTacToe.Game memory);\\n\\n\\t/// Returns the total number of games currently stored by the contract\\n\\tfunction totalGames() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITicTacToe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ITicTacToe interface\\ninterface ITicTacToe {\\n\\n\\t/// Represents the state of a Game\\n\\tenum GameState {\\n\\t\\tInPlay, OwnerWon, ContractWon, Tie\\n\\t}\\n\\n\\t/// Contains aggregated information about game results\\n\\tstruct GameHistory {\\n\\t\\tuint32 wins;\\n\\t\\tuint32 losses;\\n\\t\\tuint32 ties;\\n\\t\\tuint32 restarts;\\n\\t}\\n\\n\\t/// Contains information about a TicTacToe game\\n\\tstruct Game {\\n\\t\\tuint8[] moves;\\n\\t\\tGameState state;\\n\\t\\tGameHistory history;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/GameConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title GameConnector\\nabstract contract GameConnector is Ownable, IERC165 {\\n\\n\\t/// @dev Wen the caller is not allowed\\n\\terror CallerNotAllowed();\\n\\n\\t/// @dev The address to the game;\\n\\tmapping(address => bool) private _allowedCallers;\\n\\n\\t/// Assigns the address to the mapping of allowed callers\\n\\t/// @dev If assigning allowed to address(0), anyone may call the `onlyAllowedCallers` functions\\n\\t/// @param caller The address of the caller with which to assign allowed\\n\\t/// @param allowed Whether the `caller` will be allowed to call `onlyAllowedCallers` functions\\n\\tfunction assignAllowedCaller(address caller, bool allowed) external onlyOwner {\\n\\t\\tif (allowed) {\\n\\t\\t\\t_allowedCallers[caller] = allowed;\\n\\t\\t} else {\\n\\t\\t\\tdelete _allowedCallers[caller];\\n\\t\\t}\\n\\t}\\n\\n\\t/// Prevents a function from executing if not called by an allowed caller\\n\\tmodifier onlyAllowedCallers() {\\n\\t\\tif (!_allowedCallers[_msgSender()] && !_allowedCallers[address(0)]) revert CallerNotAllowed();\\n\\t\\t_;\\n\\t}\\n\\n\\t/// @inheritdoc IERC165\\n\\tfunction supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n\\t\\treturn interfaceId == type(IERC165).interfaceId;\\n\\t}\\n\\n\\t/// @inheritdoc Ownable\\n\\tfunction transferOwnership(address newOwner) public virtual override {\\n\\t\\tif (newOwner != owner()) {\\n\\t\\t\\tdelete _allowedCallers[owner()];\\n\\t\\t}\\n\\t\\tsuper.transferOwnership(newOwner);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/GameLogicV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"@theappstudio/solidity/contracts/utils/Randomization.sol\\\";\\nimport \\\"../interfaces/IGameLogicProvider.sol\\\";\\nimport \\\"./GameConnector.sol\\\";\\n\\n/// @title GameLogicV1\\ncontract GameLogicV1 is GameConnector, VRFConsumerBaseV2, IGameLogicProvider {\\n\\n\\t/// @dev Event emitted when a random number request happens to fail (probably misconfiguration)\\n\\tevent RandomRequestFailed(uint64 indexed subscriptionId);\\n\\n\\t/// @dev Event emitted when the VRF subscription is updated\\n\\tevent VRFSubscriptionUpdated(uint64 indexed subscriptionId, bytes32 keyHash, uint32 callbackGasLimit);\\n\\n\\t/// @dev Maximum games that will exist on the blockchain\\n\\tuint256 public constant MAX_GAMES = 999;\\n\\n\\t/// @dev Seed for randomness\\n\\tuint256 private _seed;\\n\\n\\t/// @dev Array of GameIds to GameInfo structs\\n\\tGameUtils.GameInfo[] private _gameIdsToGameInfo;\\n\\n\\t/// @dev The interface to the VRFCoordinator so that requests can be made\\n\\tVRFCoordinatorV2Interface private immutable _coordinator;\\n\\n\\t/// @dev Stores outstanding VRF requests\\n\\tmapping(uint256 => bool) private _outstandingRequests;\\n\\n\\t/// @dev The gaslimit needed to fulfill the Chainlink VRF callback\\n\\tuint32 private _callbackGasLimit;\\n\\n\\t/// @dev The number of confirmations before VRF requests are fulfilled (default minimum is 3)\\n\\tuint16 private _requestConfirmations;\\n\\n\\t/// @dev The keyHash of the \\\"gas lane\\\" used by Chainlink\\n\\tbytes32 private _keyHash;\\n\\n\\t/// @dev The configured VRF subscription id\\n\\tuint64 private _subscriptionId;\\n\\n\\t/// @dev Can devs do something?\\n\\tconstructor(uint256 seed, address vrfCoordinator) VRFConsumerBaseV2(vrfCoordinator) {\\n\\t\\t_seed = seed;\\n\\t\\t_coordinator = VRFCoordinatorV2Interface(vrfCoordinator);\\n\\t}\\n\\n\\t/// Configures a chainlink VRF2 subscription for random number generation\\n\\t/// @dev Only the contract owner may call this\\n\\t/// @param keyHash The keyHash of the \\\"gas lane\\\" used by Chainlink\\n\\t/// @param subscriptionId The subscription id\\n\\t/// @param requestConfirmations The number of confirmations before requests are fulfilled (default minimum is 3)\\n\\t/// @param callbackGasLimit The gaslimit needed to fulfill the callback\\n\\tfunction configureVrfSubscription(bytes32 keyHash, uint64 subscriptionId, uint16 requestConfirmations, uint32 callbackGasLimit) external onlyOwner {\\n\\t\\t_keyHash = keyHash;\\n\\t\\t_subscriptionId = subscriptionId;\\n\\t\\t_requestConfirmations = requestConfirmations;\\n\\t\\t_callbackGasLimit = callbackGasLimit;\\n\\t\\temit VRFSubscriptionUpdated(subscriptionId, keyHash, callbackGasLimit);\\n\\t}\\n\\n\\t/// @inheritdoc IGameLogicProvider\\n\\tfunction createGames(uint256 quantity) external onlyAllowedCallers returns (uint256 startingGameId) {\\n\\t\\tstartingGameId = _gameIdsToGameInfo.length;\\n\\t\\tif (startingGameId + quantity > MAX_GAMES) revert SoldOut();\\n\\t\\tITicTacToe.GameHistory memory history = ITicTacToe.GameHistory(0, 0, 0, 0);\\n\\t\\tuint256 seed = Randomization.randomSeed(_seed);\\n\\t\\tfor (uint i = 0; i < quantity; i++) {\\n\\t\\t\\t_gameIdsToGameInfo.push(GameUtils.initializeGame(history, seed >> i, 0));\\n\\t\\t}\\n\\t\\t_seed = seed;\\n\\t}\\n\\n\\t/// @inheritdoc VRFConsumerBaseV2\\n\\tfunction fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n\\t\\tif (!_outstandingRequests[requestId]) return;\\n\\t\\tdelete _outstandingRequests[requestId];\\n\\t\\tif (randomWords.length == 0 || randomWords[0] == 0) return;\\n\\t\\t_seed = randomWords[0];\\n\\t}\\n\\n\\t/// Provides the internal GameUtils.GameInfo memory struct to an allowed caller\\n\\tfunction gameInfoStruct(uint256 gameId) external view onlyAllowedCallers onlyWhenExists(gameId) returns (GameUtils.GameInfo memory) {\\n\\t\\treturn _gameIdsToGameInfo[gameId];\\n\\t}\\n\\n\\t/// Ensures the function only continues if the token exists\\n\\tmodifier onlyWhenExists(uint256 gameId) {\\n\\t\\tif (gameId >= _gameIdsToGameInfo.length) revert NonexistentGame();\\n\\t\\t_;\\n\\t}\\n\\n\\t/// @inheritdoc IGameLogicProvider\\n\\tfunction processMove(uint256 gameId, uint256 position) external onlyAllowedCallers onlyWhenExists(gameId) returns (ITicTacToe.GameState resultingState) {\\n\\t\\tuint256 seed = Randomization.randomSeed(_seed);\\n\\t\\tGameUtils.GameInfo memory gameInfo = GameUtils.processMove(_gameIdsToGameInfo[gameId], position, seed);\\n\\t\\t_gameIdsToGameInfo[gameId] = gameInfo;\\n\\t\\t_seed = seed;\\n\\t\\tresultingState = gameInfo.state;\\n\\t\\tif (resultingState == ITicTacToe.GameState.OwnerWon && _subscriptionId != 0 && gameInfo.history.wins % 5 == 0) {\\n\\t\\t\\t// If configured, we should occasionally re-seed randomness when somebody wins\\n\\t\\t\\ttry _coordinator.requestRandomWords(_keyHash, _subscriptionId, _requestConfirmations, _callbackGasLimit, 1) returns (uint256 requestId) {\\n\\t\\t\\t\\t_outstandingRequests[requestId] = true;\\n\\t\\t\\t} catch {\\n\\t\\t\\t\\temit RandomRequestFailed(_subscriptionId);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @inheritdoc IGameLogicProvider\\n\\tfunction restartGame(uint256 gameId) external onlyAllowedCallers onlyWhenExists(gameId) {\\n\\t\\tGameUtils.GameInfo memory gameInfo = _gameIdsToGameInfo[gameId];\\n\\t\\tif (gameInfo.state == ITicTacToe.GameState.InPlay) {\\n\\t\\t\\tgameInfo.history.restarts += 1;\\n\\t\\t}\\n\\t\\tuint256 seed = Randomization.randomSeed(_seed);\\n\\t\\t_gameIdsToGameInfo[gameId] = GameUtils.initializeGame(gameInfo.history, seed, block.number);\\n\\t\\t_seed = seed;\\n\\t}\\n\\n\\t/// @inheritdoc IERC165\\n\\tfunction supportsInterface(bytes4 interfaceId) public pure override(GameConnector, IERC165) returns (bool) {\\n\\t\\treturn interfaceId == type(IGameLogicProvider).interfaceId || super.supportsInterface(interfaceId);\\n\\t}\\n\\n\\t/// @inheritdoc IGameLogicProvider\\n\\tfunction ticTacToeGame(uint256 gameId) external view onlyAllowedCallers onlyWhenExists(gameId) returns (ITicTacToe.Game memory) {\\n\\t\\treturn GameUtils.gameFromGameInfo(_gameIdsToGameInfo[gameId]);\\n\\t}\\n\\n\\t/// @inheritdoc IGameLogicProvider\\n\\tfunction totalGames() external view returns (uint256) {\\n\\t\\treturn _gameIdsToGameInfo.length;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/GameUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/ITicTacToe.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\n/// @title GameUtils\\nlibrary GameUtils {\\n\\n\\t/// @dev When the player attempts a change that is not valid for the current GameState\\n\\terror InvalidGameState();\\n\\n\\t/// @dev When the player attempts to make an invalid move\\n\\terror InvalidMove();\\n\\n\\t/// @dev When a player attempts to make multiple moves within the same block for the same game\\n\\terror NoMagic();\\n\\n\\t/// Represents one of the game players\\n\\tenum GamePlayer {\\n\\t\\tContract, Owner\\n\\t}\\n\\n\\t/// Represents the storage of a game, suitable for the contract to make choices\\n\\tstruct GameInfo {\\n\\t\\tITicTacToe.GameState state;\\n\\t\\tuint8 moves;\\n\\t\\tuint8[9] board;\\n\\t\\tuint40 blockNumber; // The block number of the last move. To save gas, not updated on a win/lose/tie\\n\\t\\tITicTacToe.GameHistory history;\\n\\t}\\n\\n\\t/// @dev Constant for reporting an invalid index\\n\\tuint256 internal constant INVALID_MOVE_INDEX = 0xFF;\\n\\n\\t/// Returns whether the bits under test match the bits being tested for\\n\\t/// @param bits The bits to test\\n\\t/// @param matchBits The bits being tested for\\n\\t/// @return Whether the bits under test match the bits being tested for\\n\\tfunction bitsMatch(uint256 bits, uint256 matchBits) internal pure returns (bool) {\\n\\t\\treturn (bits & matchBits) == matchBits;\\n\\t}\\n\\n\\t/// Returns an ITicTacToe.Game from the supplied GameInfo\\n\\t/// @param gameInfo The GameInfo structure to convert\\n\\t/// @return game The converted Game structure\\n\\tfunction gameFromGameInfo(GameInfo memory gameInfo) internal pure returns (ITicTacToe.Game memory game) {\\n\\t\\tgame.state = gameInfo.state;\\n\\t\\tgame.history = gameInfo.history;\\n\\t\\tgame.moves = new uint8[](gameInfo.moves);\\n\\t\\tfor (uint256 move = 0; move < gameInfo.moves; move++) {\\n\\t\\t\\tgame.moves[move] = gameInfo.board[move];\\n\\t\\t}\\n\\t}\\n\\n\\t/// Returns an GameInfo from the supplied ITicTacToe.Game\\n\\t/// @param game The ITicTacToe.Game structure to convert\\n\\t/// @return gameInfo The converted GameInfo structure\\n\\tfunction gameInfoFromGame(ITicTacToe.Game memory game) internal pure returns (GameInfo memory gameInfo) {\\n\\t\\tgameInfo.state = game.state;\\n\\t\\tgameInfo.history = game.history;\\n\\t\\tgameInfo.moves = uint8(game.moves.length);\\n\\t\\tfor (uint256 move = 0; move < game.moves.length; move++) {\\n\\t\\t\\tgameInfo.board[move] = game.moves[move];\\n\\t\\t}\\n\\t}\\n\\n\\t/// Returns the index of the desired position in the GameInfo's board array\\n\\t/// @param gameInfo The GameInfo to examine\\n\\t/// @param position The position to search\\n\\t/// @return The index within the board array of the result, or `INVALID_MOVE_INDEX` if not found\\n\\tfunction indexOfPosition(GameInfo memory gameInfo, uint256 position) internal pure returns (uint256) {\\n\\t\\tfor (uint256 index = gameInfo.moves; index < gameInfo.board.length; index++) {\\n\\t\\t\\tif (position == gameInfo.board[index]) {\\n\\t\\t\\t\\treturn index;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn INVALID_MOVE_INDEX;\\n\\t}\\n\\n\\t/// Returns a new initialized GameUtils.GameInfo struct using the existing GameHistory\\n\\t/// @param history The history of games to attach to the new instance\\n\\t/// @param seed An initial seed for the contract's first move\\n\\t/// @param blockNumber A optional value to use as the initial block number, which will be collapsed to uint40\\n\\t/// @return A new intitialzed GameUtils.GameInfo struct\\n\\tfunction initializeGame(ITicTacToe.GameHistory memory history, uint256 seed, uint256 blockNumber) internal pure returns (GameUtils.GameInfo memory) {\\n\\t\\tuint8 firstMove = uint8(seed % 9);\\n\\t\\tuint8[9] memory board;\\n\\t\\tboard[0] = firstMove;\\n\\t\\tfor (uint256 i = 1; i < 9; i++) {\\n\\t\\t\\tboard[i] = i <= firstMove ? uint8(i-1) : uint8(i);\\n\\t\\t}\\n\\t\\treturn GameUtils.GameInfo(ITicTacToe.GameState.InPlay, 1, board, uint40(blockNumber), history);\\n\\t}\\n\\n\\t/// Returns the bits representing the player's moves\\n\\t/// @param gameInfo The GameInfo structure\\n\\t/// @param gamePlayer The GamePlayer for which to generate the map\\n\\t/// @return map A single integer value representing a bitmap of the player's moves\\n\\tfunction mapForPlayer(GameInfo memory gameInfo, GamePlayer gamePlayer) internal pure returns (uint256 map) {\\n\\t\\t// These are the bits for each board position\\n\\t\\tuint16[9] memory positionsToBits = [256, 128, 64, 32, 16, 8, 4, 2, 1];\\n\\t\\tfor (uint256 index = uint256(gamePlayer); index < gameInfo.moves; index += 2) {\\n\\t\\t\\tuint256 position = gameInfo.board[index];\\n\\t\\t\\tmap += positionsToBits[position];\\n\\t\\t}\\n\\t}\\n\\n\\t/// Updates the GameInfo structure based on the positionIndex being moved\\n\\t/// @param gameInfo The GameInfo structure\\n\\t/// @param positionIndex The index within the board array representing the desired move\\n\\tfunction performMove(GameInfo memory gameInfo, uint256 positionIndex) internal pure {\\n\\t\\tuint8 movePosition = gameInfo.moves & 0x0F;\\n\\t\\tuint8 nextPosition = gameInfo.board[positionIndex];\\n\\t\\tgameInfo.board[positionIndex] = gameInfo.board[movePosition];\\n\\t\\tgameInfo.board[movePosition] = nextPosition;\\n\\t\\tgameInfo.moves += 1;\\n\\t}\\n\\n\\t/// Returns whether the player has won based on its playerMap\\n\\t/// @param playerMap The bitmap of the player's moves\\n\\t/// @return Whether the bitmap represents a winning game\\n\\tfunction playerHasWon(uint256 playerMap) internal pure returns (bool) {\\n\\t\\t// These are winning boards when bits are combined\\n\\t\\tuint16[8] memory winningBits = [448, 292, 273, 146, 84, 73, 56, 7];\\n\\t\\tfor (uint256 index = 0; index < winningBits.length; index++) {\\n\\t\\t\\tif (bitsMatch(playerMap, winningBits[index])) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/// Processes a move on an incoming GameInfo structure and returns a resulting GameInfo structure\\n\\t/// @param gameInfo The incoming GameInfo structure\\n\\t/// @param position The player's attempted move\\n\\t/// @param seed A seed used for randomness\\n\\t/// @return A resulting GameInfo structure that may also include the contract's move if the game continues\\n\\tfunction processMove(GameUtils.GameInfo memory gameInfo, uint256 position, uint256 seed) internal view returns (GameUtils.GameInfo memory) {\\n\\t\\tif (gameInfo.state != ITicTacToe.GameState.InPlay) revert InvalidGameState();\\n\\t\\t// console.log(\\\"block number %d vs %d\\\", gameInfo.blockNumber, block.number);\\n\\t\\tif (gameInfo.blockNumber >= block.number) revert NoMagic();\\n\\t\\tuint256 positionIndex = indexOfPosition(gameInfo, position);\\n\\t\\tif (positionIndex == INVALID_MOVE_INDEX) revert InvalidMove();\\n\\t\\t// console.log(\\\"Playing position:\\\", position); //, positionIndex, gameInfo.moves);\\n\\t\\tperformMove(gameInfo, positionIndex);\\n\\n\\t\\tif (gameInfo.moves < 4) { // No chance of winning just yet\\n\\t\\t\\tuint256 openSlot = uint8(seed % (9 - gameInfo.moves));\\n\\t\\t\\t// console.log(\\\" - random move:\\\", gameInfo.board[openSlot + gameInfo.moves]);\\n\\t\\t\\tperformMove(gameInfo, openSlot + gameInfo.moves);\\n\\t\\t\\tgameInfo.blockNumber = uint40(block.number);\\n\\t\\t} else /* if (gameInfo.moves < 9) */ { // Owner or Contract may win\\n\\t\\t\\tuint256 ownerMap = mapForPlayer(gameInfo, GamePlayer.Owner);\\n\\t\\t\\tif (playerHasWon(ownerMap)) {\\n\\t\\t\\t\\tgameInfo.state = ITicTacToe.GameState.OwnerWon;\\n\\t\\t\\t\\tgameInfo.history.wins += 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbool needsMove = true;\\n\\t\\t\\t\\tuint256 contractMap = mapForPlayer(gameInfo, GamePlayer.Contract);\\n\\t\\t\\t\\t// If the Contract has an imminent win, take it.\\n\\t\\t\\t\\tfor (uint256 openSlot = gameInfo.moves; openSlot < 9; openSlot++) {\\n\\t\\t\\t\\t\\tif (winableMove(contractMap, gameInfo.board[openSlot])) {\\n\\t\\t\\t\\t\\t\\t// console.log(\\\" - seizing move:\\\", gameInfo.board[openSlot]); //, gameInfo.moves);\\n\\t\\t\\t\\t\\t\\tperformMove(gameInfo, openSlot);\\n\\t\\t\\t\\t\\t\\tneedsMove = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (needsMove) {\\n\\t\\t\\t\\t\\t// If the Owner has an imminent win, block it.\\n\\t\\t\\t\\t\\tfor (uint256 openSlot = gameInfo.moves; openSlot < 9; openSlot++) {\\n\\t\\t\\t\\t\\t\\tif (winableMove(ownerMap, gameInfo.board[openSlot])) {\\n\\t\\t\\t\\t\\t\\t\\t// console.log(\\\" - blocking move:\\\", gameInfo.board[openSlot]); //, gameInfo.moves);\\n\\t\\t\\t\\t\\t\\t\\tperformMove(gameInfo, openSlot);\\n\\t\\t\\t\\t\\t\\t\\tneedsMove = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (needsMove) {\\n\\t\\t\\t\\t\\tuint256 openSlot = uint8(seed % (9 - gameInfo.moves));\\n\\t\\t\\t\\t\\t// console.log(\\\" - random move:\\\", gameInfo.board[openSlot + gameInfo.moves]);\\n\\t\\t\\t\\t\\tperformMove(gameInfo, openSlot + gameInfo.moves);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (playerHasWon(mapForPlayer(gameInfo, GamePlayer.Contract))) {\\n\\t\\t\\t\\t\\tgameInfo.state = ITicTacToe.GameState.ContractWon;\\n\\t\\t\\t\\t\\tgameInfo.history.losses += 1;\\n\\t\\t\\t\\t} else if (gameInfo.moves > 8) {\\n\\t\\t\\t\\t\\tgameInfo.state = ITicTacToe.GameState.Tie;\\n\\t\\t\\t\\t\\tgameInfo.history.ties += 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgameInfo.blockNumber = uint40(block.number);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn gameInfo;\\n\\t}\\n\\n\\t/// Returns whether the next position would result in a winning board if applied\\n\\t/// @param playerMap The bitmap representing the player's current moves\\n\\t/// @param nextPosition The next move being considered\\n\\t/// @return Whether the next position would result in a winning board\\n\\tfunction winableMove(uint256 playerMap, uint256 nextPosition) internal pure returns (bool) {\\n\\t\\tif (nextPosition == 0) {\\n\\t\\t\\treturn bitsMatch(playerMap, 192) || bitsMatch(playerMap, 36) || bitsMatch(playerMap, 17);\\n\\t\\t} else if (nextPosition == 1) {\\n\\t\\t\\treturn bitsMatch(playerMap, 320) || bitsMatch(playerMap, 18);\\n\\t\\t} else if (nextPosition == 2) {\\n\\t\\t\\treturn bitsMatch(playerMap, 384) || bitsMatch(playerMap, 20) || bitsMatch(playerMap, 9);\\n\\t\\t} else if (nextPosition == 3) {\\n\\t\\t\\treturn bitsMatch(playerMap, 260) || bitsMatch(playerMap, 24);\\n\\t\\t} else if (nextPosition == 4) {\\n\\t\\t\\treturn bitsMatch(playerMap, 257) || bitsMatch(playerMap, 130) || bitsMatch(playerMap, 68) || bitsMatch(playerMap, 40);\\n\\t\\t} else if (nextPosition == 5) {\\n\\t\\t\\treturn bitsMatch(playerMap, 65) || bitsMatch(playerMap, 48);\\n\\t\\t} else if (nextPosition == 6) {\\n\\t\\t\\treturn bitsMatch(playerMap, 288) || bitsMatch(playerMap, 80) || bitsMatch(playerMap, 3);\\n\\t\\t} else if (nextPosition == 7) {\\n\\t\\t\\treturn bitsMatch(playerMap, 144) || bitsMatch(playerMap, 5);\\n\\t\\t} else /* if (nextPosition == 8) */ {\\n\\t\\t\\treturn bitsMatch(playerMap, 272) || bitsMatch(playerMap, 72) || bitsMatch(playerMap, 6);\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vrfCoordinator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CallerNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidGameState\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMove\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoMagic\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonexistentGame\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SoldOut\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"name\":\"RandomRequestFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"}],\"name\":\"VRFSubscriptionUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GAMES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"assignAllowedCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"}],\"name\":\"configureVrfSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"createGames\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startingGameId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"gameInfoStruct\",\"outputs\":[{\"components\":[{\"internalType\":\"enum ITicTacToe.GameState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"moves\",\"type\":\"uint8\"},{\"internalType\":\"uint8[9]\",\"name\":\"board\",\"type\":\"uint8[9]\"},{\"internalType\":\"uint40\",\"name\":\"blockNumber\",\"type\":\"uint40\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"wins\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"losses\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ties\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"restarts\",\"type\":\"uint32\"}],\"internalType\":\"struct ITicTacToe.GameHistory\",\"name\":\"history\",\"type\":\"tuple\"}],\"internalType\":\"struct GameUtils.GameInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"processMove\",\"outputs\":[{\"internalType\":\"enum ITicTacToe.GameState\",\"name\":\"resultingState\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"restartGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"ticTacToeGame\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"moves\",\"type\":\"uint8[]\"},{\"internalType\":\"enum ITicTacToe.GameState\",\"name\":\"state\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"wins\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"losses\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ties\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"restarts\",\"type\":\"uint32\"}],\"internalType\":\"struct ITicTacToe.GameHistory\",\"name\":\"history\",\"type\":\"tuple\"}],\"internalType\":\"struct ITicTacToe.Game\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGames\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GameLogicV1", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "90f7318687f8430ddb012b8591feeefd6bb309fd2a77f65af6bed06d15d139ae000000000000000000000000271682deb8c4e0901d1a1550ad2e64d568e69909", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}