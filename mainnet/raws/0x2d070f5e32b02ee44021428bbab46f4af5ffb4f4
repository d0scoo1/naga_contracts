{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.20;\r\n\r\ninterface SvEns {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\n\r\n/**\r\n * A registrar that allocates subdomains to the first admin to claim them\r\n */\r\ncontract SvEnsCompatibleRegistrar {\r\n    SvEns public ens;\r\n    bytes32 public rootNode;\r\n    mapping (bytes32 => bool) knownNodes;\r\n    mapping (address => bool) admins;\r\n    address public owner;\r\n\r\n\r\n    modifier req(bool c) {\r\n        require(c);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The address of the ENS registry.\r\n     * @param node The node that this registrar administers.\r\n     */\r\n    function SvEnsCompatibleRegistrar(SvEns ensAddr, bytes32 node) public {\r\n        ens = ensAddr;\r\n        rootNode = node;\r\n        admins[msg.sender] = true;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function addAdmin(address newAdmin) req(admins[msg.sender]) external {\r\n        admins[newAdmin] = true;\r\n    }\r\n\r\n    function remAdmin(address oldAdmin) req(admins[msg.sender]) external {\r\n        require(oldAdmin != msg.sender && oldAdmin != owner);\r\n        admins[oldAdmin] = false;\r\n    }\r\n\r\n    function chOwner(address newOwner, bool remPrevOwnerAsAdmin) req(msg.sender == owner) external {\r\n        if (remPrevOwnerAsAdmin) {\r\n            admins[owner] = false;\r\n        }\r\n        owner = newOwner;\r\n        admins[newOwner] = true;\r\n    }\r\n\r\n    /**\r\n     * Register a name that's not currently registered\r\n     * @param subnode The hash of the label to register.\r\n     * @param _owner The address of the new owner.\r\n     */\r\n    function register(bytes32 subnode, address _owner) req(admins[msg.sender]) external {\r\n        _setSubnodeOwner(subnode, _owner);\r\n    }\r\n\r\n    /**\r\n     * Register a name that's not currently registered\r\n     * @param subnodeStr The label to register.\r\n     * @param _owner The address of the new owner.\r\n     */\r\n    function registerName(string subnodeStr, address _owner) req(admins[msg.sender]) external {\r\n        // labelhash\r\n        bytes32 subnode = keccak256(subnodeStr);\r\n        _setSubnodeOwner(subnode, _owner);\r\n    }\r\n\r\n    /**\r\n     * INTERNAL - Register a name that's not currently registered\r\n     * @param subnode The hash of the label to register.\r\n     * @param _owner The address of the new owner.\r\n     */\r\n    function _setSubnodeOwner(bytes32 subnode, address _owner) internal {\r\n        require(!knownNodes[subnode]);\r\n        knownNodes[subnode] = true;\r\n        ens.setSubnodeOwner(rootNode, subnode, _owner);\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"remAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"},{\"name\":\"remPrevOwnerAsAdmin\",\"type\":\"bool\"}],\"name\":\"chOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subnodeStr\",\"type\":\"string\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"registerName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subnode\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ensAddr\",\"type\":\"address\"},{\"name\":\"node\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]", "ContractName": "SvEnsCompatibleRegistrar", "CompilerVersion": "v0.4.21+commit.dfe3193c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000314159265dd8dbb310642f98f50c066173c1259bcd16c2ec55840169474866c8abc7c88edd8a5029c61c519db2dfc186808cb6a5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://4d7846732fec288811ac90a79053e17f56d7e492995ff58a9ad69d06e16b57de"}]}