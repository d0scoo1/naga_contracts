{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier:MIT\r\n// Author: 0xTycoon\r\n// Project: Cigarettes (CEO of CryptoPunks)\r\n// Credits: Thanks to https://github.com/miguelmota/merkletreejs-solidity\r\npragma solidity ^0.8.11;\r\n\r\n/**\r\n\r\n\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n\r\n\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588      \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588\r\n\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\r\n\u2588\u2588   \u2588\u2588 \u2588\u2588           \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588\r\n\u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n\r\n\r\n\u2588\u2588\u2588    \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588    \u2588\u2588\r\n\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588      \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588\r\n\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588\r\n\u2588\u2588  \u2588\u2588  \u2588\u2588 \u2588\u2588      \u2588\u2588      \u2588\u2588 \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\r\n\u2588\u2588      \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\u2588\u2588\r\n\r\nThe last chance to upgrade your CIG \ud83d\udeac\r\n\r\n\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n\r\nThe following contract implements a 1:1 exchange for old-CIG to new-CIG,\r\nusing a merkle tree as a whitelist.\r\nThe contract will start with a limit of CIG to be claimed (the `step` parameter)\r\nThen the limit will increase by the value of `step` every seconds set by `interval` parameter\r\n\r\nMainnet values\r\nstep    : 100k CIG\r\ninterval: 864000 (10 days)\r\nmultisig: 0xd36ddAe4D9B4b3aAC4FDE830ea0c992752719a21\r\ncig     : 0xcb56b52316041a62b6b5d0583dce4a8ae7a3c629\r\nold cig : 0x5a35a6686db167b05e2eb74e1ede9fb5d9cdb3e0\r\n\r\nSo, first 10 days, 100k, after 10 days 200k, and so on.\r\n\r\nImportant: The contract cannot mint new CIG, it needs to be funded with CIG through donations. There might not be\r\nenough CIG for everyone, and exchange will not be possible if the contract runs out of CIG.\r\n\r\nThe contract can be killed after 540 days. Once killed, any remaining CIG will be moved to the multisig address\r\n\r\n\r\nEND\r\n\r\n*/\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\ncontract RescueMission {\r\n    address payable public admin;\r\n    bytes32 immutable public root;\r\n    mapping(address => uint256) public claims;\r\n    uint256 constant step = 100000 ether;\r\n    uint256 private immutable interval;\r\n    uint256 private openedAt;\r\n    IERC20 immutable public cig;\r\n    IERC20 immutable public oldCig;\r\n    address immutable public multisig;\r\n    event Rescue(\r\n        address, // called by\r\n        address, // sent claim to\r\n        uint256  // amount CIG claimed and sent\r\n    );\r\n    modifier onlyAdmin {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Only admin can call this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev constructor\r\n    * @param _root root hash of merkle tree\r\n    * @param _interval seconds between 'step' increase\r\n    * @param _cig address to the Cigarettes contract\r\n    * @param _oldCig address of the old cig contract\r\n    * @param _multisig address of the multisig\r\n    */\r\n    constructor (bytes32 _root, uint256 _interval, address _cig, address _oldCig, address _multisig) {\r\n        root = _root;\r\n        admin = payable(msg.sender);\r\n        interval = _interval;\r\n        cig = IERC20(_cig);\r\n        oldCig = IERC20(_oldCig);\r\n        multisig = _multisig;\r\n    }\r\n\r\n    /**\r\n    * @dev open sets the openedAt timestamp, can only be called once by admin\r\n    */\r\n    function open() external onlyAdmin {\r\n        require (openedAt == 0, \"already opened\");\r\n        openedAt = block.timestamp;\r\n    }\r\n    /**\r\n    * @dev verify verifies a merkle proof\r\n    * @param _to address used as part of a leaf\r\n    * @param _amount used as part of a lead\r\n    * @param _root hash\r\n    * @param _proof the merkle proof\r\n    */\r\n    function verify(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes32 _root,\r\n        bytes32[] memory _proof\r\n    ) public pure returns (bool) {\r\n        bytes32 computedHash = keccak256(abi.encodePacked(_to, _amount)); // leaf\r\n        for (uint256 i = 0; i < _proof.length; i++) {\r\n            bytes32 proofElement = _proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == _root;\r\n    }\r\n\r\n    /**\r\n    * @dev\r\n    * @param _amount amount to pay out\r\n    * @param _to address used as part of a leaf\r\n    * @param _balance max total claimable, used as part of a leaf\r\n    * @param _proof the merkle proof\r\n    */\r\n    function rescue(\r\n        uint256 _amount,\r\n        address _to,\r\n        uint256 _balance,\r\n        bytes32[] memory _proof\r\n    ) external payable {\r\n        require(openedAt > 0, \"not opened\");\r\n        require (verify(_to, _balance, root, _proof), \"invalid proof\");            // verify merkle proof\r\n        uint256 claimed = claims[_to];                                             // read claim amount\r\n        require (claimed < _balance, \"already claimed everything\");\r\n        uint256 max = _calcMax();                                                 // get max value we can claim\r\n        require (claimed < max, \"max amount already claimed\");\r\n        uint256 credit = _balance - claimed;                                       // credit is the amount yet to pay\r\n        if (credit > max) {\r\n            credit = max;                                                         // cap to the max\r\n        }\r\n        require(_amount <= credit, \"_amount exceeds credit\");\r\n        require (oldCig.transferFrom(_to, address(cig), _amount), \"need old CIG\"); // take old CIG\r\n        if (cig.transfer(_to, _amount)) {\r\n            claims[_to] += _amount;                                                // record the claim\r\n        }\r\n        emit Rescue(msg.sender, _to, _amount);\r\n    }\r\n    /**\r\n    * @dev kill self destructs the contract after 54 periods, sends unclaimed CIG to multisig\r\n    */\r\n    function kill() external onlyAdmin {\r\n        require(_calcMax() > 5400000 ether, \"cannot kill yet\");\r\n        cig.transfer(multisig, cig.balanceOf(address(this)));\r\n        selfdestruct(admin);\r\n    }\r\n    /**\r\n    * @dev _calcMax calculates the current max refund value\r\n    */\r\n    function _calcMax() view private returns (uint256) {\r\n        uint256 diff = block.timestamp - openedAt;\r\n        if (diff < interval) {\r\n            return step;\r\n        }\r\n        return  step + step * (diff / interval);\r\n    }\r\n    /**\r\n    * @dev getInfo gets info for the UI\r\n    * @param _to address used as part of a leaf\r\n    * @param _amount used as part of a lead\r\n    * @param _proof the merkle proof\r\n    */\r\n    function getInfo(address _to, uint256 _amount, bytes32[] memory _proof) view public returns(uint256[] memory) {\r\n        uint[] memory ret = new uint[](11);\r\n        if (verify(_to, _amount, root, _proof)) {\r\n            ret[0] = 1;                                // 1 if proof was valid\r\n        }\r\n        ret[1] = cig.balanceOf(address(this));         // balance of CIG in this contract (donated)\r\n        ret[2] = claims[_to];                          // how much CIG already claimed\r\n        ret[3] = _calcMax();                           // max CIG can claim\r\n        ret[4] = openedAt;                             // timestamp of opening\r\n        ret[5] = block.timestamp;                      // current timestamp\r\n        ret[6] = cig.balanceOf(_to);                   // user's new cig balance\r\n        ret[7] = oldCig.balanceOf(_to);                // user's old cig balance\r\n        ret[8] = oldCig.allowance(_to, address(this)); // did user give approval for old cig?\r\n        if (isContract(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2))) {       // are we on mainnet?\r\n            IERC20 lp = IERC20(address(0x7c5BbE30B5b1c1ABaA9e1Ee32e04a81a2B20a052));\r\n            ret[9] = lp.balanceOf(_to);                                              // lp balance (not staked)\r\n            IOldCigtoken old = IOldCigtoken(address(0x5A35A6686db167B05E2Eb74e1ede9fb5D9Cdb3E0));\r\n            (ret[10], ) = old.userInfo(_to);                                         // staking deposit balance\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * credits https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n * 0xTycoon was here\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IOldCigtoken is IERC20 {\r\n    function userInfo(address) external view returns (uint256, uint256);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_cig\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldCig\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_multisig\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Rescue\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cig\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"getInfo\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldCig\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "RescueMission", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "2000000", "ConstructorArguments": "9506673544a9c48a09ece4444a257f62e3b715f7bdfa0d9eecd41e3f1683e95a00000000000000000000000000000000000000000000000000000000000d2f00000000000000000000000000cb56b52316041a62b6b5d0583dce4a8ae7a3c6290000000000000000000000005a35a6686db167b05e2eb74e1ede9fb5d9cdb3e0000000000000000000000000d36ddae4d9b4b3aac4fde830ea0c992752719a21", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2f1ff196b30ebba4686cb883e70805723fbb4046f2ef37a5161a2fae024acb06"}]}