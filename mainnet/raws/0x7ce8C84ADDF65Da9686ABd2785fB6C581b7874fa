{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/single/SingleAssetVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"contracts/OndoRegistryClient.sol\\\";\\nimport \\\"contracts/Multicall.sol\\\";\\nimport \\\"contracts/interfaces/IPairVault.sol\\\";\\nimport \\\"contracts/interfaces/IRollover.sol\\\";\\nimport \\\"contracts/interfaces/ISingleAssetVault.sol\\\";\\nimport \\\"contracts/interfaces/ISAStrategy.sol\\\";\\nimport \\\"contracts/libraries/OndoLibrary.sol\\\";\\n\\ncontract SingleAssetVault is Multicall, ISingleAssetVault {\\n  using SafeERC20 for IERC20;\\n\\n  uint256 public constant MULTIPLIER_DENOMINATOR = 2**100;\\n\\n  IERC20 public immutable override asset;\\n\\n  mapping(address => bool) public isStrategy;\\n\\n  uint256 public totalFundAmount;\\n  uint256 public totalActivePoolAmount;\\n  uint256 public totalPassivePoolAmount;\\n\\n  PoolData[] public pools;\\n  Action[] public actions; // calculate token balance based on this action order\\n\\n  mapping(address => UserDeposit[]) internal userDeposits;\\n  mapping(address => uint256) internal fromDepositIndex; // calculate token balance from this deposit index\\n\\n  bool public withdrawEnabled;\\n\\n  /**\\n   * @dev Setup contract dependencies here\\n   * @param _asset single asset\\n   * @param _registry Pointer to Registry\\n   */\\n  constructor(address _asset, address _registry) OndoRegistryClient(_registry) {\\n    require(_asset != address(0), \\\"Invalid asset\\\");\\n    asset = IERC20(_asset);\\n  }\\n\\n  function setStrategy(address _strategy, bool _flag)\\n    external\\n    isAuthorized(OLib.GUARDIAN_ROLE)\\n    nonReentrant\\n  {\\n    isStrategy[_strategy] = _flag;\\n  }\\n\\n  function setWithdrawEnabled(bool _withdrawEnabled)\\n    external\\n    isAuthorized(OLib.GUARDIAN_ROLE)\\n  {\\n    withdrawEnabled = _withdrawEnabled;\\n  }\\n\\n  function deposit(uint256 _amount) external nonReentrant {\\n    require(_amount > 0, \\\"zero amount\\\");\\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\\n\\n    totalFundAmount += _amount;\\n    userDeposits[msg.sender].push(\\n      UserDeposit({amount: _amount, firstActionId: actions.length})\\n    );\\n\\n    emit Deposit(msg.sender, _amount, pools.length);\\n  }\\n\\n  function withdraw(uint256 _amount, address _to)\\n    external\\n    whenNotPaused\\n    nonReentrant\\n  {\\n    require(_amount > 0, \\\"zero amount\\\");\\n    require(withdrawEnabled, \\\"withdraw disabled\\\");\\n    (\\n      uint256 activeInvestAmount,\\n      uint256 passiveInvestAmount,\\n      uint256 remainAmount\\n    ) = tokenBalances(msg.sender);\\n    require(activeInvestAmount + passiveInvestAmount == 0, \\\"invested!\\\");\\n    require(remainAmount >= _amount, \\\"insufficient balance\\\");\\n\\n    fromDepositIndex[msg.sender] = userDeposits[msg.sender].length;\\n    if (remainAmount > _amount) {\\n      userDeposits[msg.sender].push(\\n        UserDeposit({\\n          amount: remainAmount - _amount,\\n          firstActionId: actions.length\\n        })\\n      );\\n    }\\n\\n    totalFundAmount -= _amount;\\n    asset.safeTransfer(_to, _amount);\\n\\n    emit Withdraw(msg.sender, _amount, _to);\\n  }\\n\\n  function massUpdateUserBalance(address _user) external {\\n    (\\n      uint256 activeInvestAmount,\\n      uint256 passiveInvestAmount,\\n      uint256 remainAmount\\n    ) = tokenBalances(msg.sender);\\n    require(activeInvestAmount + passiveInvestAmount == 0, \\\"invested!\\\");\\n\\n    fromDepositIndex[msg.sender] = userDeposits[msg.sender].length;\\n    if (remainAmount > 0) {\\n      userDeposits[msg.sender].push(\\n        UserDeposit({amount: remainAmount, firstActionId: actions.length})\\n      );\\n    }\\n\\n    emit MassUpdateUserBalance(_user);\\n  }\\n\\n  function invest(\\n    address _strategy,\\n    uint256 _amount,\\n    bool _isPassive,\\n    bytes memory _data\\n  ) external whenNotPaused isAuthorized(OLib.STRATEGIST_ROLE) nonReentrant {\\n    require(isStrategy[_strategy], \\\"invalid strategy\\\");\\n\\n    if (_isPassive) {\\n      pools.push(\\n        PoolData({\\n          isPassive: true,\\n          investAmount: _amount,\\n          strategy: _strategy,\\n          strategist: msg.sender,\\n          depositMultiplier: 0,\\n          redemptionMultiplier: 0,\\n          redeemed: false\\n        })\\n      );\\n      totalPassivePoolAmount += _amount;\\n    } else {\\n      pools.push(\\n        PoolData({\\n          isPassive: false,\\n          investAmount: _amount,\\n          strategy: _strategy,\\n          strategist: msg.sender,\\n          depositMultiplier: OLib.safeMulDiv(\\n            _amount,\\n            MULTIPLIER_DENOMINATOR,\\n            (totalFundAmount + totalPassivePoolAmount)\\n          ),\\n          redemptionMultiplier: MULTIPLIER_DENOMINATOR,\\n          redeemed: false\\n        })\\n      );\\n      actions.push(\\n        Action({actionType: ActionType.Invest, poolId: pools.length - 1})\\n      );\\n      totalActivePoolAmount += _amount;\\n    }\\n\\n    totalFundAmount -= _amount;\\n\\n    uint256 poolId = pools.length - 1;\\n    asset.safeApprove(_strategy, _amount);\\n    ISAStrategy(_strategy).invest(poolId, _amount, _data);\\n\\n    emit Invest(poolId, msg.sender, _strategy, _amount, _data);\\n  }\\n\\n  function redeem(uint256 _poolId, bytes memory _data)\\n    external\\n    whenNotPaused\\n    nonReentrant\\n  {\\n    PoolData storage pool = pools[_poolId];\\n    require(\\n      msg.sender == pool.strategist ||\\n        registry.authorized(OLib.GUARDIAN_ROLE, msg.sender),\\n      \\\"Unauthorized\\\"\\n    );\\n    require(!pool.redeemed, \\\"Already redeemed\\\");\\n\\n    (bool pendingAdditionalWithdraw, uint256 redeemAmount) =\\n      ISAStrategy(pool.strategy).redeem(_poolId, _data);\\n\\n    if (pendingAdditionalWithdraw) {\\n      return;\\n    }\\n\\n    pool.redeemed = true;\\n    pool.redemptionMultiplier = OLib.safeMulDiv(\\n      redeemAmount,\\n      MULTIPLIER_DENOMINATOR,\\n      pool.investAmount\\n    );\\n\\n    if (pool.isPassive) {\\n      pool.depositMultiplier = OLib.safeMulDiv(\\n        pool.investAmount,\\n        MULTIPLIER_DENOMINATOR,\\n        (totalFundAmount + totalPassivePoolAmount)\\n      );\\n\\n      actions.push(Action({actionType: ActionType.Invest, poolId: _poolId}));\\n      totalPassivePoolAmount -= pool.investAmount;\\n    } else {\\n      totalActivePoolAmount -= pool.investAmount;\\n    }\\n\\n    actions.push(Action({actionType: ActionType.Redeem, poolId: _poolId}));\\n    totalFundAmount += redeemAmount;\\n\\n    emit Redeem(_poolId, msg.sender, redeemAmount, _data);\\n  }\\n\\n  function tokenBalance(address _user) external view returns (uint256 amount) {\\n    (\\n      uint256 activeInvestAmount,\\n      uint256 passiveInvestAmount,\\n      uint256 remainAmount\\n    ) = tokenBalances(_user);\\n\\n    return activeInvestAmount + passiveInvestAmount + remainAmount;\\n  }\\n\\n  function tokenBalances(address _user)\\n    public\\n    view\\n    returns (\\n      uint256 activeInvestAmount,\\n      uint256 passiveInvestAmount,\\n      uint256 remainAmount\\n    )\\n  {\\n    uint256 depositLength = userDeposits[_user].length;\\n    uint256 depositIndex = fromDepositIndex[_user];\\n    if (depositLength == depositIndex) {\\n      return (0, 0, 0);\\n    }\\n\\n    UserDeposit[] storage deposits = userDeposits[_user];\\n\\n    uint256 currentActionId = deposits[depositIndex].firstActionId;\\n    uint256[] memory userPoolDeposits = new uint256[](pools.length); // this is to reduce the memory size\\n    while (depositIndex < depositLength || currentActionId < actions.length) {\\n      if (\\n        depositIndex < depositLength &&\\n        currentActionId == deposits[depositIndex].firstActionId\\n      ) {\\n        remainAmount += deposits[depositIndex].amount;\\n        depositIndex++;\\n        continue;\\n      }\\n\\n      // always: currentActionId < deposits[depositIndex].actionId\\n      Action memory action = actions[currentActionId];\\n      PoolData memory pool = pools[action.poolId];\\n      if (action.actionType == ActionType.Invest) {\\n        userPoolDeposits[action.poolId] = OLib.safeMulDiv(\\n          remainAmount,\\n          pool.depositMultiplier,\\n          MULTIPLIER_DENOMINATOR\\n        );\\n        remainAmount -= userPoolDeposits[action.poolId];\\n        activeInvestAmount += userPoolDeposits[action.poolId];\\n      } else if (userPoolDeposits[action.poolId] > 0) {\\n        uint256 redeemAmount =\\n          OLib.safeMulDiv(\\n            userPoolDeposits[action.poolId],\\n            pool.redemptionMultiplier,\\n            MULTIPLIER_DENOMINATOR\\n          );\\n        remainAmount += redeemAmount;\\n        activeInvestAmount -= userPoolDeposits[action.poolId];\\n      }\\n      currentActionId++;\\n    }\\n\\n    if (totalPassivePoolAmount != 0) {\\n      passiveInvestAmount = OLib.safeMulDiv(\\n        remainAmount,\\n        totalPassivePoolAmount,\\n        (totalFundAmount + totalPassivePoolAmount)\\n      );\\n      remainAmount -= passiveInvestAmount;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OndoRegistryClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"contracts/OndoRegistryClientInitializable.sol\\\";\\n\\nabstract contract OndoRegistryClient is OndoRegistryClientInitializable {\\n  constructor(address _registry) {\\n    __OndoRegistryClient__initialize(_registry);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Multicall.sol\": {\r\n      \"content\": \"/**SPDX-License-Identifier: AGPL-3.0\\n\\n          \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584                                                                  \\n       \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584                                                               \\n      \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,         \\n     \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,     \\n    \u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c    \\n    \u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588    \\n    \u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580    \\n     \u2588\u2588 \\\"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`     \\n      \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac         \\n       \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580                                                               \\n          \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310                                                                   \\n\\n */\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./interfaces/IMulticall.sol\\\";\\nimport \\\"./OndoRegistryClient.sol\\\";\\n\\n/// @title Multicall\\n/// @notice Enables calling multiple methods in a single call to the contract\\nabstract contract Multicall is IMulticall, OndoRegistryClient {\\n  using Address for address;\\n\\n  /// @inheritdoc IMulticall\\n  function multiexcall(ExCallData[] calldata exCallData)\\n    external\\n    payable\\n    override\\n    isAuthorized(OLib.GUARDIAN_ROLE)\\n    returns (bytes[] memory results)\\n  {\\n    results = new bytes[](exCallData.length);\\n    for (uint256 i = 0; i < exCallData.length; i++) {\\n      results[i] = exCallData[i].target.functionCallWithValue(\\n        exCallData[i].data,\\n        exCallData[i].value,\\n        \\\"Multicall: multiexcall failed\\\"\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPairVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"contracts/libraries/OndoLibrary.sol\\\";\\nimport \\\"contracts/interfaces/ITrancheToken.sol\\\";\\nimport \\\"contracts/interfaces/IStrategy.sol\\\";\\n\\ninterface IPairVault {\\n  // Container to return Vault info to caller\\n  struct VaultView {\\n    uint256 id;\\n    Asset[] assets;\\n    IStrategy strategy; // Shared contract that interacts with AMMs\\n    address creator; // Account that calls createVault\\n    address strategist; // Has the right to call invest() and redeem(), and harvest() if strategy supports it\\n    address rollover;\\n    uint256 hurdleRate; // Return offered to senior tranche\\n    OLib.State state; // Current state of Vault\\n    uint256 startAt; // Time when the Vault is unpaused to begin accepting deposits\\n    uint256 investAt; // Time when investors can't move funds, strategist can invest\\n    uint256 redeemAt; // Time when strategist can redeem LP tokens, investors can withdraw\\n  }\\n\\n  // Track the asset type and amount in different stages\\n  struct Asset {\\n    IERC20 token;\\n    ITrancheToken trancheToken;\\n    uint256 trancheCap;\\n    uint256 userCap;\\n    uint256 deposited;\\n    uint256 originalInvested;\\n    uint256 totalInvested; // not literal 1:1, originalInvested + proportional lp from mid-term\\n    uint256 received;\\n    uint256 rolloverDeposited;\\n  }\\n\\n  function getState(uint256 _vaultId) external view returns (OLib.State);\\n\\n  function createVault(OLib.VaultParams calldata _params)\\n    external\\n    returns (uint256 vaultId);\\n\\n  function deposit(\\n    uint256 _vaultId,\\n    OLib.Tranche _tranche,\\n    uint256 _amount\\n  ) external;\\n\\n  function depositETH(uint256 _vaultId, OLib.Tranche _tranche) external payable;\\n\\n  function depositLp(uint256 _vaultId, uint256 _amount)\\n    external\\n    returns (uint256 seniorTokensOwed, uint256 juniorTokensOwed);\\n\\n  function invest(\\n    uint256 _vaultId,\\n    uint256 _seniorMinOut,\\n    uint256 _juniorMinOut\\n  ) external returns (uint256, uint256);\\n\\n  function redeem(\\n    uint256 _vaultId,\\n    uint256 _seniorMinOut,\\n    uint256 _juniorMinOut\\n  ) external returns (uint256, uint256);\\n\\n  function withdraw(uint256 _vaultId, OLib.Tranche _tranche)\\n    external\\n    returns (uint256);\\n\\n  function withdrawETH(uint256 _vaultId, OLib.Tranche _tranche)\\n    external\\n    returns (uint256);\\n\\n  function withdrawLp(uint256 _vaultId, uint256 _amount)\\n    external\\n    returns (uint256, uint256);\\n\\n  function claim(uint256 _vaultId, OLib.Tranche _tranche)\\n    external\\n    returns (uint256, uint256);\\n\\n  function claimETH(uint256 _vaultId, OLib.Tranche _tranche)\\n    external\\n    returns (uint256, uint256);\\n\\n  function depositFromRollover(\\n    uint256 _vaultId,\\n    uint256 _rolloverId,\\n    uint256 _seniorAmount,\\n    uint256 _juniorAmount\\n  ) external;\\n\\n  function rolloverClaim(uint256 _vaultId, uint256 _rolloverId)\\n    external\\n    returns (uint256, uint256);\\n\\n  function setRollover(\\n    uint256 _vaultId,\\n    address _rollover,\\n    uint256 _rolloverId\\n  ) external;\\n\\n  function canDeposit(uint256 _vaultId) external view returns (bool);\\n\\n  function getVaultById(uint256 _vaultId)\\n    external\\n    view\\n    returns (VaultView memory);\\n\\n  function vaultInvestor(uint256 _vaultId, OLib.Tranche _tranche)\\n    external\\n    view\\n    returns (\\n      uint256 position,\\n      uint256 claimableBalance,\\n      uint256 withdrawableExcess,\\n      uint256 withdrawableBalance\\n    );\\n\\n  function seniorExpected(uint256 _vaultId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRollover.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"contracts/interfaces/ITrancheToken.sol\\\";\\nimport \\\"contracts/libraries/OndoLibrary.sol\\\";\\n\\ninterface IRollover {\\n  // ========== EVENTS ==========\\n\\n  event CreatedRollover(\\n    uint256 indexed rolloverId,\\n    address indexed creator,\\n    address indexed strategist,\\n    address seniorAsset,\\n    address juniorAsset,\\n    address seniorToken,\\n    address juniorToken\\n  );\\n\\n  event AddedVault(uint256 indexed rolloverId, uint256 indexed vaultId);\\n\\n  event MigratedRollover(\\n    uint256 indexed rolloverId,\\n    uint256 indexed newVault,\\n    uint256 seniorDeposited,\\n    uint256 juniorDeposited\\n  );\\n\\n  event Withdrew(\\n    address indexed user,\\n    uint256 indexed rolloverId,\\n    uint256 indexed trancheId,\\n    uint256 equivalentInvested,\\n    uint256 withdrawnShares,\\n    uint256 totalShares,\\n    uint256 excess\\n  );\\n\\n  event Deposited(\\n    address indexed user,\\n    uint256 indexed rolloverId,\\n    uint256 indexed trancheId,\\n    uint256 depositAmount,\\n    uint256 excess,\\n    uint256 sharesMinted\\n  );\\n\\n  event Claimed(\\n    address indexed user,\\n    uint256 indexed rolloverId,\\n    uint256 indexed trancheId,\\n    uint256 tokens,\\n    uint256 excess\\n  );\\n  event DepositedLP(\\n    address indexed depositor,\\n    uint256 indexed vaultId,\\n    uint256 amount,\\n    uint256 seniorTrancheMintedAmount,\\n    uint256 juniorTrancheMintedAmount\\n  );\\n\\n  event WithdrewLP(\\n    address indexed depositor,\\n    uint256 indexed vaultId,\\n    uint256 amount,\\n    uint256 seniorTrancheBurnedAmount,\\n    uint256 juniorTrancheBurnedAmount\\n  );\\n  // ========== STRUCTS ==========\\n\\n  struct TrancheRoundView {\\n    uint256 deposited;\\n    uint256 invested; // Total, if any, actually invested\\n    uint256 redeemed; // After Vault is done, total tokens redeemed for LP\\n    uint256 shares;\\n    uint256 newDeposited;\\n    uint256 newInvested;\\n  }\\n\\n  struct RoundView {\\n    uint256 vaultId;\\n    TrancheRoundView[] tranches;\\n  }\\n\\n  struct RolloverView {\\n    address creator;\\n    address strategist;\\n    IERC20[] assets;\\n    ITrancheToken[] rolloverTokens;\\n    uint256 thisRound;\\n  }\\n\\n  struct TrancheRound {\\n    uint256 deposited;\\n    uint256 invested; // Total, if any, actually invested\\n    uint256 redeemed; // After Vault is done, total tokens redeemed for LP\\n    uint256 shares;\\n    uint256 newDeposited;\\n    uint256 newInvested;\\n    mapping(address => OLib.Investor) investors;\\n  }\\n\\n  struct Round {\\n    uint256 vaultId;\\n    mapping(OLib.Tranche => TrancheRound) tranches;\\n  }\\n\\n  struct Rollover {\\n    address creator;\\n    address strategist;\\n    mapping(uint256 => Round) rounds;\\n    mapping(OLib.Tranche => IERC20) assets;\\n    mapping(OLib.Tranche => ITrancheToken) rolloverTokens;\\n    mapping(OLib.Tranche => mapping(address => uint256)) investorLastUpdates;\\n    uint256 thisRound;\\n    bool dead;\\n  }\\n\\n  struct SlippageSettings {\\n    uint256 seniorMinInvest;\\n    uint256 seniorMinRedeem;\\n    uint256 juniorMinInvest;\\n    uint256 juniorMinRedeem;\\n  }\\n\\n  // ========== FUNCTIONS ==========\\n\\n  function getRollover(uint256 rolloverId)\\n    external\\n    view\\n    returns (RolloverView memory);\\n\\n  function getRound(uint256 _rolloverId, uint256 _roundIndex)\\n    external\\n    view\\n    returns (RoundView memory);\\n\\n  function getNextVault(uint256 rolloverId) external view returns (uint256);\\n\\n  function deposit(\\n    uint256 _rolloverId,\\n    OLib.Tranche _tranche,\\n    uint256 _amount\\n  ) external;\\n\\n  function withdraw(\\n    uint256 _rolloverId,\\n    OLib.Tranche _tranche,\\n    uint256 shares\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISingleAssetVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../libraries/OndoLibrary.sol\\\";\\nimport \\\"./ITrancheToken.sol\\\";\\n\\ninterface ISingleAssetVault {\\n  // Events\\n  event Deposit(address indexed user, uint256 amount, uint256 investFromIndex);\\n  event Withdraw(\\n    address indexed user,\\n    uint256 amount,\\n    address indexed recipient\\n  );\\n  event MassUpdateUserBalance(address indexed user);\\n  event Invest(\\n    uint256 indexed poolId,\\n    address indexed strategist,\\n    address indexed strategy,\\n    uint256 amount,\\n    bytes data\\n  );\\n  event Redeem(\\n    uint256 indexed poolId,\\n    address indexed redeemer,\\n    uint256 amount,\\n    bytes data\\n  );\\n\\n  // Enums / Structs\\n  enum ActionType {Invest, Redeem}\\n\\n  /**\\n   * redeem rollover will have two steps\\n   * 1. redeem from rollover -> will update vaultId field with withdrawn vault id\\n   * 2. redeem from vault once redeem state\\n   */\\n  struct PoolData {\\n    bool isPassive;\\n    uint256 investAmount;\\n    address strategy;\\n    address strategist;\\n    uint256 depositMultiplier;\\n    uint256 redemptionMultiplier;\\n    bool redeemed;\\n  }\\n  struct Action {\\n    ActionType actionType;\\n    uint256 poolId;\\n  }\\n  struct UserDeposit {\\n    uint256 amount;\\n    uint256 firstActionId;\\n  }\\n\\n  // Functions\\n\\n  function asset() external view returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISAStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\ninterface ISAStrategy {\\n  function invest(\\n    uint256 poolId,\\n    uint256 amount,\\n    bytes memory data\\n  ) external;\\n\\n  function redeem(uint256 poolId, bytes memory data)\\n    external\\n    returns (bool pendingAdditionalWithdraw, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OndoLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/utils/Arrays.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Helper functions\\n */\\nlibrary OLib {\\n  using Arrays for uint256[];\\n\\n  // State transition per Vault. Just linear transitions.\\n  enum State {Inactive, Deposit, Live, Withdraw}\\n\\n  // Only supports 2 tranches for now\\n  enum Tranche {Senior, Junior}\\n\\n  struct VaultParams {\\n    address seniorAsset;\\n    address juniorAsset;\\n    address strategist;\\n    address strategy;\\n    uint256 hurdleRate;\\n    uint256 startTime;\\n    uint256 enrollment;\\n    uint256 duration;\\n    string seniorName;\\n    string seniorSym;\\n    string juniorName;\\n    string juniorSym;\\n    uint256 seniorTrancheCap;\\n    uint256 seniorUserCap;\\n    uint256 juniorTrancheCap;\\n    uint256 juniorUserCap;\\n  }\\n\\n  struct RolloverParams {\\n    address strategist;\\n    string seniorName;\\n    string seniorSym;\\n    string juniorName;\\n    string juniorSym;\\n  }\\n\\n  bytes32 public constant GOVERNANCE_ROLE = keccak256(\\\"GOVERNANCE_ROLE\\\");\\n  bytes32 public constant PANIC_ROLE = keccak256(\\\"PANIC_ROLE\\\");\\n  bytes32 public constant GUARDIAN_ROLE = keccak256(\\\"GUARDIAN_ROLE\\\");\\n  bytes32 public constant DEPLOYER_ROLE = keccak256(\\\"DEPLOYER_ROLE\\\");\\n  bytes32 public constant CREATOR_ROLE = keccak256(\\\"CREATOR_ROLE\\\");\\n  bytes32 public constant STRATEGIST_ROLE = keccak256(\\\"STRATEGIST_ROLE\\\");\\n  bytes32 public constant VAULT_ROLE = keccak256(\\\"VAULT_ROLE\\\");\\n  bytes32 public constant ROLLOVER_ROLE = keccak256(\\\"ROLLOVER_ROLE\\\");\\n  bytes32 public constant STRATEGY_ROLE = keccak256(\\\"STRATEGY_ROLE\\\");\\n\\n  // Both sums are running sums. If a user deposits [$1, $5, $3], then\\n  // userSums would be [$1, $6, $9]. You can figure out the deposit\\n  // amount be subtracting userSums[i]-userSum[i-1].\\n\\n  // prefixSums is the total deposited for all investors + this\\n  // investors deposit at the time this deposit is made. So at\\n  // prefixSum[0], it would be $1 + totalDeposits, where totalDeposits\\n  // could be $1000 because other investors have put in money.\\n  struct Investor {\\n    uint256[] userSums;\\n    uint256[] prefixSums;\\n    bool claimed;\\n    bool withdrawn;\\n  }\\n\\n  /**\\n   * @dev Given the total amount invested by the Vault, we want to find\\n   *   out how many of this investor's deposits were actually\\n   *   used. Use findUpperBound on the prefixSum to find the point\\n   *   where total deposits were accepted. For example, if $2000 was\\n   *   deposited by all investors and $1000 was invested, then some\\n   *   position in the prefixSum splits the array into deposits that\\n   *   got in, and deposits that didn't get in. That same position\\n   *   maps to userSums. This is the user's deposits that got\\n   *   in. Since we are keeping track of the sums, we know at that\\n   *   position the total deposits for a user was $15, even if it was\\n   *   15 $1 deposits. And we know the amount that didn't get in is\\n   *   the last value in userSum - the amount that got it.\\n\\n   * @param investor A specific investor\\n   * @param invested The total amount invested by this Vault\\n   */\\n  function getInvestedAndExcess(Investor storage investor, uint256 invested)\\n    internal\\n    view\\n    returns (uint256 userInvested, uint256 excess)\\n  {\\n    uint256[] storage prefixSums_ = investor.prefixSums;\\n    uint256 length = prefixSums_.length;\\n    if (length == 0) {\\n      // There were no deposits. Return 0, 0.\\n      return (userInvested, excess);\\n    }\\n    uint256 leastUpperBound = prefixSums_.findUpperBound(invested);\\n    if (length == leastUpperBound) {\\n      // All deposits got in, no excess. Return total deposits, 0\\n      userInvested = investor.userSums[length - 1];\\n      return (userInvested, excess);\\n    }\\n    uint256 prefixSum = prefixSums_[leastUpperBound];\\n    if (prefixSum == invested) {\\n      // Not all deposits got in, but there are no partial deposits\\n      userInvested = investor.userSums[leastUpperBound];\\n      excess = investor.userSums[length - 1] - userInvested;\\n    } else {\\n      // Let's say some of my deposits got in. The last deposit,\\n      // however, was $100 and only $30 got in. Need to split that\\n      // deposit so $30 got in, $70 is excess.\\n      userInvested = leastUpperBound > 0\\n        ? investor.userSums[leastUpperBound - 1]\\n        : 0;\\n      uint256 depositAmount = investor.userSums[leastUpperBound] - userInvested;\\n      if (prefixSum - depositAmount < invested) {\\n        userInvested += (depositAmount + invested - prefixSum);\\n        excess = investor.userSums[length - 1] - userInvested;\\n      } else {\\n        excess = investor.userSums[length - 1] - userInvested;\\n      }\\n    }\\n  }\\n\\n  /*\\n   Used to avoid phantom overflow issues that can arise during this calculation:\\n   @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n   @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n   @dec Credit to prb-math for refactoring for solidity ^0.8 https://github.com/paulrberg/prb-math/blob/main/contracts/PRBMath.sol\\n  */\\n  function safeMulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly {\\n      let mm := mulmod(x, y, not(0))\\n      prod0 := mul(x, y)\\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n      unchecked {\\n        result = prod0 / denominator;\\n      }\\n      return result;\\n    }\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    if (prod1 >= denominator) {\\n      revert(\\\"OLib__MulDivOverflow(prod1, denominator)\\\");\\n    }\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly {\\n      // Compute remainder using mulmod.\\n      remainder := mulmod(x, y, denominator)\\n      // Subtract 256 bit number from 512 bit number.\\n      prod1 := sub(prod1, gt(remainder, prod0))\\n      prod0 := sub(prod0, remainder)\\n    }\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n    // See https://cs.stackexchange.com/q/138556/92363.\\n    unchecked {\\n      // Does not overflow because the denominator cannot be zero at this stage in the function.\\n      uint256 lpotdod = denominator & (~denominator + 1);\\n      assembly {\\n        // Divide denominator by lpotdod.\\n        denominator := div(denominator, lpotdod)\\n        // Divide [prod1 prod0] by lpotdod.\\n        prod0 := div(prod0, lpotdod)\\n        // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n        lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n      }\\n      // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * lpotdod;\\n      // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n      // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n      // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n      // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\u2019s lifting lemma, this also works\\n      // in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n      // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n      // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n      // less than 2^256, this is the final result. We don\u2019t need to compute the high bits of the result and prod1\\n      // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n}\\n\\n/**\\n * @title Subset of SafeERC20 from openZeppelin\\n *\\n * @dev Some non-standard ERC20 contracts (e.g. Tether) break\\n * `approve` by forcing it to behave like `safeApprove`. This means\\n * `safeIncreaseAllowance` will fail when it tries to adjust the\\n * allowance. The code below simply adds an extra call to\\n * `approve(spender, 0)`.\\n */\\nlibrary OndoSaferERC20 {\\n  using SafeERC20 for IERC20;\\n\\n  function ondoSafeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    token.safeApprove(spender, 0);\\n    token.safeApprove(spender, newAllowance);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OndoRegistryClientInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"contracts/interfaces/IRegistry.sol\\\";\\nimport \\\"contracts/libraries/OndoLibrary.sol\\\";\\n\\nabstract contract OndoRegistryClientInitializable is\\n  Initializable,\\n  ReentrancyGuard,\\n  Pausable\\n{\\n  using SafeERC20 for IERC20;\\n\\n  IRegistry public registry;\\n  uint256 public denominator;\\n\\n  function __OndoRegistryClient__initialize(address _registry)\\n    internal\\n    initializer\\n  {\\n    require(_registry != address(0), \\\"Invalid registry address\\\");\\n    registry = IRegistry(_registry);\\n    denominator = registry.denominator();\\n  }\\n\\n  /**\\n   * @notice General ACL checker\\n   * @param _role Role as defined in OndoLibrary\\n   */\\n  modifier isAuthorized(bytes32 _role) {\\n    require(registry.authorized(_role, msg.sender), \\\"Unauthorized\\\");\\n    _;\\n  }\\n\\n  /*\\n   * @notice Helper to expose a Pausable interface to tools\\n   */\\n  function paused() public view virtual override returns (bool) {\\n    return registry.paused() || super.paused();\\n  }\\n\\n  function pause() external virtual isAuthorized(OLib.PANIC_ROLE) {\\n    super._pause();\\n  }\\n\\n  function unpause() external virtual isAuthorized(OLib.GUARDIAN_ROLE) {\\n    super._unpause();\\n  }\\n\\n  /**\\n   * @notice Grab tokens and send to caller\\n   * @dev If the _amount[i] is 0, then transfer all the tokens\\n   * @param _tokens List of tokens\\n   * @param _amounts Amount of each token to send\\n   */\\n  function _rescueTokens(address[] calldata _tokens, uint256[] memory _amounts)\\n    internal\\n    virtual\\n  {\\n    for (uint256 i = 0; i < _tokens.length; i++) {\\n      uint256 amount = _amounts[i];\\n      if (amount == 0) {\\n        amount = IERC20(_tokens[i]).balanceOf(address(this));\\n      }\\n      IERC20(_tokens[i]).safeTransfer(msg.sender, amount);\\n    }\\n  }\\n\\n  function rescueTokens(address[] calldata _tokens, uint256[] memory _amounts)\\n    public\\n    whenPaused\\n    isAuthorized(OLib.GUARDIAN_ROLE)\\n  {\\n    require(_tokens.length == _amounts.length, \\\"Invalid array sizes\\\");\\n    _rescueTokens(_tokens, _amounts);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"contracts/interfaces/IWETH.sol\\\";\\n\\n/**\\n * @title Global values used by many contracts\\n * @notice This is mostly used for access control\\n */\\ninterface IRegistry is IAccessControl {\\n  function paused() external view returns (bool);\\n\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function enableFeatureFlag(bytes32 _featureFlag) external;\\n\\n  function disableFeatureFlag(bytes32 _featureFlag) external;\\n\\n  function getFeatureFlag(bytes32 _featureFlag) external view returns (bool);\\n\\n  function denominator() external view returns (uint256);\\n\\n  function weth() external view returns (IWETH);\\n\\n  function authorized(bytes32 _role, address _account)\\n    external\\n    view\\n    returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n    function grantRole(bytes32 role, address account) external;\\n    function revokeRole(bytes32 role, address account) external;\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping (address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override {\\n        require(hasRole(getRoleAdmin(role), _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override {\\n        require(hasRole(getRoleAdmin(role), _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n  function deposit() external payable;\\n\\n  function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Arrays.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n   /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && array[low - 1] == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMulticall.sol\": {\r\n      \"content\": \"/**SPDX-License-Identifier: AGPL-3.0\\n\\n          \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584                                                                  \\n       \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584                                                               \\n      \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,         \\n     \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,     \\n    \u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c    \\n    \u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588    \\n    \u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580    \\n     \u2588\u2588 \\\"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`     \\n      \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac         \\n       \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580                                                               \\n          \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310                                                                   \\n\\n */\\npragma solidity 0.8.3;\\n\\n/// @title Multicall interface\\n/// @notice Enables calling multiple methods in a single call to the contract\\ninterface IMulticall {\\n  /// @notice External call data structure\\n  struct ExCallData {\\n    address target; // The target contract called from the current contract\\n    bytes data; // The encoded function data\\n    uint256 value; // The ether to be transfered to the target contract\\n  }\\n\\n  /// @notice Call multiple functions in the target contract and return the data from all of them if they all succeed\\n  /// @dev The `msg.sender` is always the current contract in any method callable from multicall.\\n  /// @param exdata The external call data for each of the calls to make to this contract\\n  /// @return results The results from each of the calls passed in via data\\n  function multiexcall(ExCallData[] calldata exdata)\\n    external\\n    payable\\n    returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITrancheToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\ninterface ITrancheToken is IERC20Upgradeable {\\n  function mint(address _account, uint256 _amount) external;\\n\\n  function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"contracts/libraries/OndoLibrary.sol\\\";\\nimport \\\"contracts/interfaces/IPairVault.sol\\\";\\n\\ninterface IStrategy {\\n  // Additional info stored for each Vault\\n  struct Vault {\\n    IPairVault origin; // who created this Vault\\n    IERC20 pool; // the DEX pool\\n    IERC20 senior; // senior asset in pool\\n    IERC20 junior; // junior asset in pool\\n    uint256 shares; // number of shares for ETF-style mid-duration entry/exit\\n    uint256 seniorExcess; // unused senior deposits\\n    uint256 juniorExcess; // unused junior deposits\\n  }\\n\\n  function vaults(uint256 vaultId)\\n    external\\n    view\\n    returns (\\n      IPairVault origin,\\n      IERC20 pool,\\n      IERC20 senior,\\n      IERC20 junior,\\n      uint256 shares,\\n      uint256 seniorExcess,\\n      uint256 juniorExcess\\n    );\\n\\n  function addVault(\\n    uint256 _vaultId,\\n    IERC20 _senior,\\n    IERC20 _junior\\n  ) external;\\n\\n  function addLp(uint256 _vaultId, uint256 _lpTokens) external;\\n\\n  function removeLp(\\n    uint256 _vaultId,\\n    uint256 _shares,\\n    address to\\n  ) external;\\n\\n  function getVaultInfo(uint256 _vaultId)\\n    external\\n    view\\n    returns (IERC20, uint256);\\n\\n  function invest(\\n    uint256 _vaultId,\\n    uint256 _totalSenior,\\n    uint256 _totalJunior,\\n    uint256 _extraSenior,\\n    uint256 _extraJunior,\\n    uint256 _seniorMinOut,\\n    uint256 _juniorMinOut\\n  ) external returns (uint256 seniorInvested, uint256 juniorInvested);\\n\\n  function sharesFromLp(uint256 vaultId, uint256 lpTokens)\\n    external\\n    view\\n    returns (\\n      uint256 shares,\\n      uint256 vaultShares,\\n      IERC20 pool\\n    );\\n\\n  function lpFromShares(uint256 vaultId, uint256 shares)\\n    external\\n    view\\n    returns (uint256 lpTokens, uint256 vaultShares);\\n\\n  function redeem(\\n    uint256 _vaultId,\\n    uint256 _seniorExpected,\\n    uint256 _seniorMinOut,\\n    uint256 _juniorMinOut\\n  ) external returns (uint256, uint256);\\n\\n  function withdrawExcess(\\n    uint256 _vaultId,\\n    OLib.Tranche tranche,\\n    address to,\\n    uint256 amount\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investFromIndex\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"MassUpdateUserBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MULTIPLIER_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"actions\",\"outputs\":[{\"internalType\":\"enum ISingleAssetVault.ActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isPassive\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isStrategy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"massUpdateUserBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IMulticall.ExCallData[]\",\"name\":\"exCallData\",\"type\":\"tuple[]\"}],\"name\":\"multiexcall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPassive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"investAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redemptionMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"redeemed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_withdrawEnabled\",\"type\":\"bool\"}],\"name\":\"setWithdrawEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"activeInvestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"passiveInvestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalActivePoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFundAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPassivePoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SingleAssetVault", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f00000000000000000000000032ef5c9b4be1462b9e459a64f0a52f6e42f70f42", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}