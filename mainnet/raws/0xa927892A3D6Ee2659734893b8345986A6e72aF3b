{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Sale/Sale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\nimport \\\"../Interface/ISpaceCows.sol\\\";\\r\\n\\r\\nimport \\\"./Modules/Whitelisted.sol\\\";\\r\\nimport \\\"./Modules/Random.sol\\\";\\r\\n\\r\\ncontract Sale is Ownable, Whitelisted {\\r\\n    using Random for Random.Manifest;\\r\\n    Random.Manifest internal _manifest;\\r\\n\\r\\n    uint256 public whitelistSalePrice;\\r\\n    uint256 public publicSalePrice;\\r\\n    uint256 public maxMintsPerTxn;\\r\\n    uint256 public maxPresaleMintsPerWallet;\\r\\n    uint256 public maxTokenSupply;\\r\\n    uint256 public pendingRefereeAwards;\\r\\n    \\r\\n    enum SaleState {\\r\\n        CLOSED,\\r\\n        PRESALE,\\r\\n        OPEN\\r\\n    }\\r\\n    SaleState public saleState;\\r\\n\\r\\n    ISpaceCows public spaceCows;\\r\\n\\r\\n    struct Referee {\\r\\n        uint128 referredCount;\\r\\n        uint128 reward;\\r\\n    }\\r\\n    mapping(address => Referee) private _refereeAccounts;\\r\\n\\r\\n    constructor(\\r\\n        uint256 _whitelistSalePrice,\\r\\n        uint256 _publicSalePrice,\\r\\n        uint256 _maxSupply,\\r\\n        uint256 _maxMintsPerTxn,\\r\\n        uint256 _maxPresaleMintsPerWallet\\r\\n    ) {\\r\\n        whitelistSalePrice = _whitelistSalePrice;\\r\\n        publicSalePrice = _publicSalePrice;\\r\\n        maxTokenSupply = _maxSupply;\\r\\n        maxMintsPerTxn = _maxMintsPerTxn;\\r\\n        maxPresaleMintsPerWallet = _maxPresaleMintsPerWallet;\\r\\n        _manifest.setup(_maxSupply);\\r\\n\\r\\n        saleState = SaleState(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    =========================================\\r\\n    Owner Functions\\r\\n    @dev these functions can only be called \\r\\n        by the owner of contract. some functions\\r\\n        here are meant only for backup cases.\\r\\n        separate maxpertxn and maxperwallet for\\r\\n        max flexibility\\r\\n    =========================================\\r\\n    */\\r\\n    function setWhitelistPrice(uint256 _newPrice) external onlyOwner {\\r\\n        whitelistSalePrice = _newPrice;\\r\\n    }\\r\\n\\r\\n    function setPublicPrice(uint256 _newPrice) external onlyOwner {\\r\\n        publicSalePrice = _newPrice;\\r\\n    }\\r\\n\\r\\n    function setMaxTokenSupply(uint256 _newMaxSupply) external onlyOwner {\\r\\n        maxTokenSupply = _newMaxSupply;\\r\\n    }\\r\\n\\r\\n    function setMaxMintsPerTxn(uint256 _newMaxMintsPerTxn) external onlyOwner {\\r\\n        maxMintsPerTxn = _newMaxMintsPerTxn;\\r\\n    }\\r\\n\\r\\n    function setMaxPresaleMintsPerWallet(uint256 _newLimit) external onlyOwner {\\r\\n        maxPresaleMintsPerWallet = _newLimit;\\r\\n    }\\r\\n\\r\\n    function setSpaceCowsAddress(address _newNftContract) external onlyOwner {\\r\\n        spaceCows = ISpaceCows(_newNftContract);\\r\\n    }\\r\\n\\r\\n    function setSaleState(uint256 _state) external onlyOwner {\\r\\n        saleState = SaleState(_state);\\r\\n    }\\r\\n\\r\\n    function setWhitelistRoot(bytes32 _newWhitelistRoot) external onlyOwner {\\r\\n        _setWhitelistRoot(_newWhitelistRoot);\\r\\n    }\\r\\n\\r\\n    function givewayReserved(address _user, uint256 _amount) external onlyOwner {\\r\\n        uint256 totalSupply = spaceCows.totalSupply();\\r\\n        require(totalSupply + _amount < maxTokenSupply + 1, \\\"Not enough tokens!\\\");\\r\\n        \\r\\n        uint256 index = 0;\\r\\n        uint256[] memory tmpTokenIds = new uint256[](_amount);\\r\\n        while (index < _amount) {\\r\\n            uint256 tokenId = _manifest.draw();\\r\\n            bool doExists = spaceCows.exists(tokenId);\\r\\n\\r\\n            if (!doExists) {\\r\\n                tmpTokenIds[index] = tokenId;\\r\\n                index++;\\r\\n            } else {\\r\\n                continue;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        spaceCows.cowMint(_user, tmpTokenIds);\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner {\\r\\n        uint256 payment = (address(this).balance - pendingRefereeAwards) / 4;\\r\\n        require(payment > 0, \\\"Empty balance\\\");\\r\\n\\r\\n        sendToOwners(payment);\\r\\n    }\\r\\n\\r\\n    function emergencyWithdraw() external onlyOwner {\\r\\n        uint256 payment = address(this).balance / 4;\\r\\n        require(payment > 0, \\\"Empty balance\\\");\\r\\n\\r\\n        sendToOwners(payment);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n    =========================================\\r\\n    Mint Functions\\r\\n    @dev these functions are relevant  \\r\\n        for minting purposes only\\r\\n    =========================================\\r\\n    */\\r\\n    function whitelistPurchase(uint256 numberOfTokens, bytes32[] calldata proof)\\r\\n    external\\r\\n    payable\\r\\n    onlyWhitelisted(msg.sender, address(this), proof) {\\r\\n        address user = msg.sender;\\r\\n        uint256 buyAmount = whitelistSalePrice * numberOfTokens;\\r\\n\\r\\n        require(saleState == SaleState.PRESALE, \\\"Presale is not started!\\\");\\r\\n        require(spaceCows.balanceOf(user) + numberOfTokens < maxPresaleMintsPerWallet + 1, \\\"You can only mint 10 token(s) on presale per wallet!\\\");\\r\\n        require(msg.value > buyAmount - 1, \\\"Not enough ETH!\\\");\\r\\n\\r\\n        uint256 index = 0;\\r\\n        uint256[] memory tmpTokenIds = new uint256[](numberOfTokens);\\r\\n        while (index < numberOfTokens) {\\r\\n            uint256 tokenId = _manifest.draw();\\r\\n            bool doExists = spaceCows.exists(tokenId);\\r\\n\\r\\n            if (!doExists) {\\r\\n                tmpTokenIds[index] = tokenId;\\r\\n                index++;\\r\\n            } else {\\r\\n                continue;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        spaceCows.cowMint(user, tmpTokenIds);\\r\\n    }\\r\\n\\r\\n    function publicPurchase(uint256 numberOfTokens, address referee)\\r\\n    external\\r\\n    payable {\\r\\n        address user = msg.sender;\\r\\n        uint256 totalSupply = spaceCows.totalSupply();\\r\\n        uint256 buyAmount = publicSalePrice * numberOfTokens;\\r\\n\\r\\n        require(saleState == SaleState.OPEN, \\\"Sale not started!\\\");\\r\\n        require(numberOfTokens < maxMintsPerTxn + 1, \\\"You can buy up to 10 per transaction\\\");\\r\\n        require(totalSupply + numberOfTokens < maxTokenSupply + 1, \\\"Not enough tokens!\\\");\\r\\n        require(msg.value > buyAmount - 1, \\\"Not enough ETH!\\\");\\r\\n\\r\\n        uint256 index = 0;\\r\\n        uint256[] memory tmpTokenIds = new uint256[](numberOfTokens);\\r\\n        while (index < numberOfTokens) {\\r\\n            uint256 tokenId = _manifest.draw();\\r\\n            bool doExists = spaceCows.exists(tokenId);\\r\\n\\r\\n            if (!doExists) {\\r\\n                tmpTokenIds[index] = tokenId;\\r\\n                index++;\\r\\n            } else {\\r\\n                continue;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        spaceCows.cowMint(user, tmpTokenIds);\\r\\n\\r\\n        if (msg.sender != referee && referee != address(0)) {\\r\\n            updateReferee(referee);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getRefereeData(address referee) public view returns (Referee memory) {\\r\\n        Referee memory _r = _refereeAccounts[referee];\\r\\n        _r.reward = (_r.reward == 0) ? 0 : _r.reward - 1;\\r\\n\\r\\n        return _r;\\r\\n    }\\r\\n\\r\\n    function claimRefereeRewards() external {\\r\\n        address referee = msg.sender;\\r\\n        uint256 refereeReward = (_refereeAccounts[referee].reward == 0) ? 0 : uint256(_refereeAccounts[referee].reward) - 1;\\r\\n        uint256 accountBalance = address(this).balance;\\r\\n        require(accountBalance > 0, \\\"Empty balance\\\");\\r\\n        require(refereeReward > 0, \\\"Empty reward\\\");\\r\\n\\r\\n        sendValue(payable(referee), refereeReward);\\r\\n\\r\\n        Referee storage _refereeObject = _refereeAccounts[referee];\\r\\n        _refereeObject.reward = 1;\\r\\n\\r\\n        pendingRefereeAwards -= refereeReward;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    ============================================\\r\\n    Public & External Functions\\r\\n    @dev functions that can be called by anyone\\r\\n    ============================================\\r\\n    */\\r\\n    function remaining() public view returns (uint256) {\\r\\n        return _manifest.remaining();\\r\\n    }\\r\\n\\r\\n    function getSaleState() public view returns (uint256) {\\r\\n        return uint256(saleState);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    ============================================\\r\\n    Internal Functions\\r\\n    @dev functions that can be use inside the contract\\r\\n    ============================================\\r\\n    */\\r\\n    function updateReferee(address referee) internal {\\r\\n        uint128 reward = uint128(msg.value) * 15 / 100;\\r\\n\\r\\n        if (_refereeAccounts[referee].referredCount != 0) {\\r\\n            Referee storage _refereeObject = _refereeAccounts[referee];\\r\\n            _refereeObject.reward += reward;\\r\\n            _refereeObject.referredCount += 1;\\r\\n        } else {\\r\\n            _refereeAccounts[referee] = Referee({\\r\\n                referredCount: 1,\\r\\n                reward: reward + 1\\r\\n            });\\r\\n        }\\r\\n\\r\\n        pendingRefereeAwards += reward;\\r\\n    }\\r\\n\\r\\n    function sendToOwners(uint256 payment) internal {\\r\\n        sendValue(payable(0xced6ACCbEbF5cb8BD23e2B2E8B49C78471FaAe20), payment);\\r\\n        sendValue(payable(0x4386103c101ce063C668B304AD06621d6DEF59c9), payment);\\r\\n        sendValue(payable(0x19Bb04164f17FF2136A1768aA4ed22cb7f1dAa00), payment);\\r\\n        sendValue(payable(0x910040fA04518c7D166e783DB427Af74BE320Ac7), payment);\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interface/ISpaceCows.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface ISpaceCows {\\n    function totalSupply() external view returns(uint256);\\n\\tfunction getMintingRate(address _address) external view returns(uint256);\\n    function cowMint(address _user, uint256[] memory _tokenId) external;\\n    function exists(uint256 _tokenId) external view returns(bool);\\n    function balanceOf(address owner) external returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/Sale/Modules/Whitelisted.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\r\\n\\r\\nabstract contract Whitelisted {\\r\\n    bytes32 private _whitelistRoot;\\r\\n\\r\\n    modifier onlyWhitelisted(address _user, address _contract, bytes32[] calldata merkleProof) {\\r\\n        bytes32 node = keccak256(abi.encodePacked(_user, _contract));\\r\\n\\r\\n        require(MerkleProof.verify(merkleProof, _whitelistRoot, node), \\\"You are not whitelisted!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _setWhitelistRoot(bytes32 root) internal {\\r\\n        _whitelistRoot = root;\\r\\n    }\\r\\n\\r\\n    function getWhitelistRoot() public view returns (bytes32) {\\r\\n        return _whitelistRoot;\\r\\n    }\\r\\n\\r\\n    function isWhitelisted(bytes32[] calldata merkleProof) public view returns (bool) {\\r\\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, address(this)));\\r\\n        if (MerkleProof.verify(merkleProof, _whitelistRoot, node)) {\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Sale/Modules/Random.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nlibrary Random {\\n    function random() internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp, msg.sender)) ;\\n    }\\n\\n    struct Manifest {\\n        uint256[] _data;\\n    }\\n\\n    function setup(Manifest storage self, uint256 length) internal {\\n        uint256[] storage data = self._data;\\n\\n        require(data.length == 0, \\\"Can't setup empty\\\");\\n        assembly { sstore(data.slot, length) }\\n    }\\n\\n    function draw(Manifest storage self) internal returns (uint256) {\\n        return draw(self, random());\\n    }\\n\\n    function draw(Manifest storage self, bytes32 seed) internal returns (uint256) {\\n        uint256[] storage data = self._data;\\n\\n        uint256 dl = data.length;\\n        uint256 di = uint256(seed) % dl;\\n        uint256 dx = data[di];\\n        uint256 dy = data[--dl];\\n        if (dx == 0) { dx = di + 1;   }\\n        if (dy == 0) { dy = dl + 1;   }\\n        if (di != dl) { data[di] = dy; }\\n        data.pop();\\n        return dx;\\n    }\\n\\n    function remaining(Manifest storage self) internal view returns (uint256) {\\n        return self._data.length;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_whitelistSalePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_publicSalePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxMintsPerTxn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPresaleMintsPerWallet\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimRefereeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"}],\"name\":\"getRefereeData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"referredCount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"reward\",\"type\":\"uint128\"}],\"internalType\":\"struct Sale.Referee\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSaleState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelistRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"givewayReserved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintsPerTxn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPresaleMintsPerWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRefereeAwards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"}],\"name\":\"publicPurchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleState\",\"outputs\":[{\"internalType\":\"enum Sale.SaleState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxMintsPerTxn\",\"type\":\"uint256\"}],\"name\":\"setMaxMintsPerTxn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setMaxPresaleMintsPerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxTokenSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setPublicPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_state\",\"type\":\"uint256\"}],\"name\":\"setSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newNftContract\",\"type\":\"address\"}],\"name\":\"setSpaceCowsAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setWhitelistPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newWhitelistRoot\",\"type\":\"bytes32\"}],\"name\":\"setWhitelistRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spaceCows\",\"outputs\":[{\"internalType\":\"contract ISpaceCows\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"whitelistPurchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Sale", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000000001aa535d3d0c00000000000000000000000000000000000000000000000000000000000000002755000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}