{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/governance/VotePower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IGovernance.sol\\\";\\nimport \\\"../../interfaces/IMemberRoles.sol\\\";\\nimport \\\"../../interfaces/INXMMaster.sol\\\";\\nimport \\\"../../interfaces/INXMToken.sol\\\";\\nimport \\\"../../interfaces/ITokenController.sol\\\";\\n\\ncontract VotePower {\\n\\n  string constant public name = \\\"NXM balance with delegations\\\";\\n  string constant public symbol = \\\"NXMD\\\";\\n  uint8 constant public decimals = 18;\\n\\n  INXMMaster immutable public master;\\n\\n  enum Role {UnAssigned, AdvisoryBoard, Member}\\n\\n  constructor(INXMMaster _master) {\\n    master = _master;\\n  }\\n\\n  function totalSupply() public view returns (uint) {\\n    return INXMToken(master.tokenAddress()).totalSupply();\\n  }\\n\\n  function balanceOf(address member) public view returns (uint) {\\n\\n    ITokenController tokenController = ITokenController(master.dAppLocker());\\n    IMemberRoles memberRoles = IMemberRoles(master.getLatestAddress(\\\"MR\\\"));\\n    IGovernance governance = IGovernance(master.getLatestAddress(\\\"GV\\\"));\\n\\n    uint delegationId = governance.followerDelegation(member);\\n\\n    if (delegationId != 0) {\\n      (, address leader,) = governance.allDelegation(delegationId);\\n      if (leader != address(0)) {\\n        return 0;\\n      }\\n    }\\n\\n    uint balance = tokenController.totalBalanceOf(member) + 1e18;\\n    uint[] memory delegationIds = governance.getFollowers(member);\\n\\n    for (uint i = 0; i < delegationIds.length; i++) {\\n\\n      (address follower, address leader,) = governance.allDelegation(delegationIds[i]);\\n\\n      if (\\n        leader != member ||\\n        !memberRoles.checkRole(follower, uint(Role.Member))\\n      ) {\\n        continue;\\n      }\\n\\n      balance += tokenController.totalBalanceOf(follower) + 1e18;\\n    }\\n\\n    return balance;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IGovernance {\\n\\n  event Proposal(\\n    address indexed proposalOwner,\\n    uint256 indexed proposalId,\\n    uint256 dateAdd,\\n    string proposalTitle,\\n    string proposalSD,\\n    string proposalDescHash\\n  );\\n\\n  event Solution(\\n    uint256 indexed proposalId,\\n    address indexed solutionOwner,\\n    uint256 indexed solutionId,\\n    string solutionDescHash,\\n    uint256 dateAdd\\n  );\\n\\n  event Vote(\\n    address indexed from,\\n    uint256 indexed proposalId,\\n    uint256 indexed voteId,\\n    uint256 dateAdd,\\n    uint256 solutionChosen\\n  );\\n\\n  event RewardClaimed(\\n    address indexed member,\\n    uint gbtReward\\n  );\\n\\n  /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal.\\n  event VoteCast (uint256 proposalId);\\n\\n  /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can\\n  ///      call any offchain actions\\n  event ProposalAccepted (uint256 proposalId);\\n\\n  /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\\n  event CloseProposalOnTime (\\n    uint256 indexed proposalId,\\n    uint256 time\\n  );\\n\\n  /// @dev ActionSuccess event is called whenever an onchain action is executed.\\n  event ActionSuccess (\\n    uint256 proposalId\\n  );\\n\\n  struct DelegateVote {\\n    address follower;\\n    address leader;\\n    uint lastUpd;\\n  }\\n\\n  /// @dev Creates a new proposal\\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\n  function createProposal(\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash,\\n    uint _categoryId\\n  )\\n  external;\\n\\n  /// @dev Edits the details of an existing proposal and creates new version\\n  /// @param _proposalId Proposal id that details needs to be updated\\n  /// @param _proposalDescHash Proposal description hash having long and short description of proposal.\\n  function updateProposal(\\n    uint _proposalId,\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash\\n  )\\n  external;\\n\\n  /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\\n  function categorizeProposal(\\n    uint _proposalId,\\n    uint _categoryId,\\n    uint _incentives\\n  )\\n  external;\\n\\n  /// @dev Submit proposal with solution\\n  /// @param _proposalId Proposal id\\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\n  function submitProposalWithSolution(\\n    uint _proposalId,\\n    string calldata _solutionHash,\\n    bytes calldata _action\\n  )\\n  external;\\n\\n  /// @dev Creates a new proposal with solution and votes for the solution\\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\n  function createProposalwithSolution(\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash,\\n    uint _categoryId,\\n    string calldata _solutionHash,\\n    bytes calldata _action\\n  )\\n  external;\\n\\n  /// @dev Casts vote\\n  /// @param _proposalId Proposal id\\n  /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\\n  function submitVote(uint _proposalId, uint _solutionChosen) external;\\n\\n  function closeProposal(uint _proposalId) external;\\n\\n  function claimReward(address _memberAddress, uint _maxRecords) external returns (uint pendingDAppReward);\\n\\n  function proposal(uint _proposalId)\\n  external\\n  view\\n  returns (\\n    uint proposalId,\\n    uint category,\\n    uint status,\\n    uint finalVerdict,\\n    uint totalReward\\n  );\\n\\n  function canCloseProposal(uint _proposalId) external view returns (uint closeValue);\\n\\n  function allowedToCatgorize() external view returns (uint roleId);\\n\\n  function removeDelegation(address _add) external;\\n\\n  function getPendingReward(address _memberAddress) external view returns (uint pendingDAppReward);\\n\\n  function getFollowers(address _add) external view returns (uint[] memory);\\n\\n  function followerDelegation(address _add) external view returns (uint delegationId);\\n\\n  function allDelegation(uint _delegationId) external view returns (address follower, address leader, uint lastUpd);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMemberRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IMemberRoles {\\n\\n  enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\\n\\n  function payJoiningFee(address _userAddress) external payable;\\n\\n  function switchMembership(address _newAddress) external;\\n\\n  function switchMembershipAndAssets(\\n    address newAddress,\\n    uint[] calldata coverIds,\\n    address[] calldata stakingPools\\n  ) external;\\n\\n  function switchMembershipOf(address member, address _newAddress) external;\\n\\n  function swapOwner(address _newOwnerAddress) external;\\n\\n  function addInitialABMembers(address[] calldata abArray) external;\\n\\n  function kycVerdict(address payable _userAddress, bool verdict) external;\\n\\n  function totalRoles() external view returns (uint256);\\n\\n  function changeAuthorized(uint _roleId, address _newAuthorized) external;\\n\\n  function members(uint _memberRoleId) external view returns (uint, address[] memory memberArray);\\n\\n  function numberOfMembers(uint _memberRoleId) external view returns (uint);\\n\\n  function authorized(uint _memberRoleId) external view returns (address);\\n\\n  function roles(address _memberAddress) external view returns (uint[] memory);\\n\\n  function checkRole(address _memberAddress, uint _roleId) external view returns (bool);\\n\\n  function getMemberLengthForAllRoles() external view returns (uint[] memory totalMembers);\\n\\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool);\\n\\n  function membersLength(uint _memberRoleId) external view returns (uint);\\n\\n  event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\\n\\n  event switchedMembership(address indexed previousMember, address indexed newMember, uint timeStamp);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INXMMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface INXMMaster {\\n\\n  function tokenAddress() external view returns (address);\\n\\n  function owner() external view returns (address);\\n\\n  function masterInitialized() external view returns (bool);\\n\\n  function isInternal(address _add) external view returns (bool);\\n\\n  function isPause() external view returns (bool check);\\n\\n  function isOwner(address _add) external view returns (bool);\\n\\n  function isMember(address _add) external view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\\n\\n  function dAppLocker() external view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\\n\\n  function contractAddresses(bytes2 code) external view returns (address payable);\\n\\n  function upgradeMultipleContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses\\n  ) external;\\n\\n  function removeContracts(bytes2[] calldata contractCodesToRemove) external;\\n\\n  function addNewInternalContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses,\\n    uint[] calldata _types\\n  ) external;\\n\\n  function updateOwnerParameters(bytes8 code, address payable val) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INXMToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface INXMToken {\\n\\n  function burn(uint256 amount) external returns (bool);\\n\\n  function burnFrom(address from, uint256 value) external returns (bool);\\n\\n  function operatorTransfer(address from, uint256 value) external returns (bool);\\n\\n  function mint(address account, uint256 amount) external;\\n\\n  function isLockedForMV(address member) external view returns (uint);\\n\\n  function addToWhiteList(address _member) external returns (bool);\\n\\n  function removeFromWhiteList(address _member) external returns (bool);\\n\\n  function changeOperator(address _newOperator) external returns (bool);\\n\\n  function lockForMemberVote(address _of, uint _days) external;\\n\\n  /**\\n * @dev Returns the amount of tokens in existence.\\n */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./INXMToken.sol\\\";\\n\\ninterface ITokenController {\\n\\n  struct CoverInfo {\\n    uint16 claimCount;\\n    bool hasOpenClaim;\\n    bool hasAcceptedClaim;\\n    // note: still 224 bits available here, can be used later\\n  }\\n\\n  function coverInfo(uint id) external view returns (uint16 claimCount, bool hasOpenClaim, bool hasAcceptedClaim);\\n\\n  function withdrawCoverNote(\\n    address _of,\\n    uint[] calldata _coverIds,\\n    uint[] calldata _indexes\\n  ) external;\\n\\n  function changeOperator(address _newOperator) external;\\n\\n  function operatorTransfer(address _from, address _to, uint _value) external returns (bool);\\n\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time) external returns (bool);\\n\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time) external returns (bool);\\n\\n  function burnFrom(address _of, uint amount) external returns (bool);\\n\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) external;\\n\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function addToWhitelist(address _member) external;\\n\\n  function removeFromWhitelist(address _member) external;\\n\\n  function mint(address _member, uint _amount) external;\\n\\n  function lockForMemberVote(address _of, uint _days) external;\\n  function withdrawClaimAssessmentTokens(address _of) external;\\n\\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons);\\n\\n  function getLockedTokensValidity(address _of, bytes32 reason) external view returns (uint256 validity);\\n\\n  function getUnlockableTokens(address _of) external view returns (uint256 unlockableTokens);\\n\\n  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\\n  external\\n  view\\n  returns (uint256 amount, uint256 validity);\\n\\n  function tokensUnlockable(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) external view returns (uint256 amount);\\n  function totalBalanceOf(address _of) external view returns (uint256 amount);\\n\\n  function totalLockedBalance(address _of) external view returns (uint256 amount);\\n\\n  function token() external view returns (INXMToken);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"_master\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VotePower", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000001bfd82675dbcc7762c84019ca518e701c0cd07e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}