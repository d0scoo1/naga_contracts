{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.3;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    /**\r\n    * Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering.\r\n     * One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0\r\n     * and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * Returns the total number of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n    * Gets the balance of the address specified.\r\n    * @param addr The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address addr) external view returns (uint256);\r\n\r\n    /**\r\n     * Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * This event is triggered when a given amount of tokens is sent to an address.\r\n     * @param from The address of the sender\r\n     * @param to The address of the receiver\r\n     * @param value The amount transferred\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * This event is triggered when a given address is approved to spend a specific amount of tokens\r\n     * on behalf of the sender.\r\n     * @param owner The owner of the token\r\n     * @param spender The spender\r\n     * @param value The amount to transfer\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Represents an ownable resource.\r\n */\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n     * Constructor\r\n     * @param addr The owner of the smart contract\r\n     */\r\n    constructor (address addr) {\r\n        require(addr != address(0), \"non-zero address required\");\r\n        require(addr != address(1), \"ecrecover address not allowed\");\r\n        _owner = addr;\r\n        emit OwnershipTransferred(address(0), addr);\r\n    }\r\n\r\n    /**\r\n     * @notice This modifier indicates that the function can only be called by the owner.\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"Only owner requirement\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership to the address specified.\r\n     * @param addr Specifies the address of the new owner.\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    function transferOwnership (address addr) public onlyOwner {\r\n        require(addr != address(0), \"non-zero address required\");\r\n        emit OwnershipTransferred(_owner, addr);\r\n        _owner = addr;\r\n    }\r\n\r\n    /**\r\n     * @notice Destroys the smart contract.\r\n     * @param addr The payable address of the recipient.\r\n     */\r\n    function destroy(address payable addr) public virtual onlyOwner {\r\n        require(addr != address(0), \"non-zero address required\");\r\n        require(addr != address(1), \"ecrecover address not allowed\");\r\n        selfdestruct(addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the address of the owner.\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Indicates if the address specified is the owner of the resource.\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner(address addr) public view returns (bool) {\r\n        return addr == _owner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Represents an ERC-20\r\n */\r\ncontract ERC20 is IERC20 {\r\n    // Basic ERC-20 data\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    uint256 internal _totalSupply;\r\n\r\n    // The balance of each owner\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    // The allowance set by each owner\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param tokenName The name of the token\r\n     * @param tokenSymbol The symbol of the token\r\n     * @param tokenDecimals The decimals of the token\r\n     * @param initialSupply The initial supply\r\n     */\r\n    constructor (string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals, uint256 initialSupply) {\r\n        _name = tokenName;\r\n        _symbol = tokenSymbol;\r\n        _decimals = tokenDecimals;\r\n        _totalSupply = initialSupply;\r\n    }\r\n\r\n    /**\r\n    * @notice Transfers a given amount tokens to the address specified.\r\n    * @param from The address of the sender.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    * @return Returns true in case of success.\r\n    */\r\n    function executeErc20Transfer (address from, address to, uint256 value) private returns (bool) {\r\n        // Checks\r\n        require(to != address(0), \"non-zero address required\");\r\n        require(from != address(0), \"non-zero sender required\");\r\n        require(value > 0, \"Amount cannot be zero\");\r\n        require(_balances[from] >= value, \"Amount exceeds sender balance\");\r\n\r\n        // State changes\r\n        _balances[from] = _balances[from] - value;\r\n        _balances[to] = _balances[to] + value;\r\n\r\n        // Emit the event per ERC-20\r\n        emit Transfer(from, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @dev Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering.\r\n     * One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0\r\n     * and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param ownerAddr The address of the owner.\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     * @return Returns true in case of success.\r\n     */\r\n    function approveSpender(address ownerAddr, address spender, uint256 value) private returns (bool) {\r\n        require(spender != address(0), \"non-zero spender required\");\r\n        require(ownerAddr != address(0), \"non-zero owner required\");\r\n\r\n        // State changes\r\n        _allowances[ownerAddr][spender] = value;\r\n\r\n        // Emit the event\r\n        emit Approval(ownerAddr, spender, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Transfers a given amount tokens to the address specified.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    * @return Returns true in case of success.\r\n    */\r\n    function transfer(address to, uint256 value) public override returns (bool) {\r\n        require (executeErc20Transfer(msg.sender, to, value), \"Failed to execute ERC20 transfer\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer tokens from one address to another.\r\n     * @dev Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     * @return Returns true in case of success.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public override returns (bool) {\r\n        require (executeErc20Transfer(from, to, value), \"Failed to execute transferFrom\");\r\n\r\n        uint256 currentAllowance = _allowances[from][msg.sender];\r\n        require(currentAllowance >= value, \"Amount exceeds allowance\");\r\n\r\n        require(approveSpender(from, msg.sender, currentAllowance - value), \"ERC20: Approval failed\");\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @dev Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering.\r\n     * One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0\r\n     * and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     * @return Returns true in case of success.\r\n     */\r\n    function approve(address spender, uint256 value) public override returns (bool) {\r\n        require(approveSpender(msg.sender, spender, value), \"ERC20: Approval failed\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the total supply of tokens\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the name of the token.\r\n     */\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the symbol of the token.\r\n     */\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the decimals of the token.\r\n     */\r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n    * Gets the balance of the address specified.\r\n    * @param addr The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address addr) public view override returns (uint256) {\r\n        return _balances[addr];\r\n    }\r\n\r\n    /**\r\n     * Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Represents an ERC20 that can be minted and/or burnt by multiple parties.\r\n */\r\ncontract Mintable is ERC20, Ownable {\r\n    /**\r\n     * @notice The maximum circulating supply of tokens\r\n     */\r\n    uint256 public maxSupply;\r\n\r\n    // Keeps track of the authorized minters\r\n    mapping (address => bool) internal _authorizedMinters;\r\n\r\n    // Keeps track of the authorized burners\r\n    mapping (address => bool) internal _authorizedBurners;\r\n\r\n    // ---------------------------------------\r\n    // Events\r\n    // ---------------------------------------\r\n    /**\r\n     * This event is triggered whenever an address is added as a valid minter.\r\n     * @param addr The address that became a valid minter\r\n     */\r\n    event OnMinterGranted(address addr);\r\n\r\n    /**\r\n     * This event is triggered when a minter is revoked.\r\n     * @param addr The address that was revoked\r\n     */\r\n    event OnMinterRevoked(address addr);\r\n\r\n    /**\r\n     * This event is triggered whenever an address is added as a valid burner.\r\n     * @param addr The address that became a valid burner\r\n     */\r\n    event OnBurnerGranted(address addr);\r\n\r\n    /**\r\n     * This event is triggered when a burner is revoked.\r\n     * @param addr The address that was revoked\r\n     */\r\n    event OnBurnerRevoked(address addr);\r\n\r\n    /**\r\n     * This event is triggered when the maximum limit for minting tokens is updated.\r\n     * @param prevValue The previous limit\r\n     * @param newValue The new limit\r\n     */\r\n    event OnMaxSupplyChanged(uint256 prevValue, uint256 newValue);\r\n\r\n    // ---------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------\r\n    /**\r\n     * @notice Constructor\r\n     * @param newOwner The contract owner\r\n     * @param tokenName The name of the token\r\n     * @param tokenSymbol The symbol of the token\r\n     * @param tokenDecimals The decimals of the token\r\n     * @param initialSupply The initial supply\r\n     */\r\n    constructor (address newOwner, string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals, uint256 initialSupply)\r\n    ERC20(tokenName, tokenSymbol, tokenDecimals, initialSupply)\r\n    Ownable(newOwner) { // solhint-disable-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if the sender is not a valid minter\r\n     */\r\n    modifier onlyMinter() {\r\n        require(_authorizedMinters[msg.sender], \"Unauthorized minter\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if the sender is not a valid burner\r\n     */\r\n    modifier onlyBurner() {\r\n        require(_authorizedBurners[msg.sender], \"Unauthorized burner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Grants the right to issue new tokens to the address specified.\r\n     * @dev This function can be called by the owner only.\r\n     * @param addr The destination address\r\n     */\r\n    function grantMinter (address addr) public onlyOwner {\r\n        require(!_authorizedMinters[addr], \"Address authorized already\");\r\n        _authorizedMinters[addr] = true;\r\n        emit OnMinterGranted(addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Revokes the right to issue new tokens from the address specified.\r\n     * @dev This function can be called by the owner only.\r\n     * @param addr The destination address\r\n     */\r\n    function revokeMinter (address addr) public onlyOwner {\r\n        require(_authorizedMinters[addr], \"Address was never authorized\");\r\n        _authorizedMinters[addr] = false;\r\n        emit OnMinterRevoked(addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Grants the right to burn tokens to the address specified.\r\n     * @dev This function can be called by the owner only.\r\n     * @param addr The destination address\r\n     */\r\n    function grantBurner (address addr) public onlyOwner {\r\n        require(!_authorizedBurners[addr], \"Address authorized already\");\r\n        _authorizedBurners[addr] = true;\r\n        emit OnBurnerGranted(addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Revokes the right to burn tokens from the address specified.\r\n     * @dev This function can be called by the owner only.\r\n     * @param addr The destination address\r\n     */\r\n    function revokeBurner (address addr) public onlyOwner {\r\n        require(_authorizedBurners[addr], \"Address was never authorized\");\r\n        _authorizedBurners[addr] = false;\r\n        emit OnBurnerRevoked(addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the maximum limit for minting tokens.\r\n     * @param newValue The new limit\r\n     */\r\n    function changeMaxSupply (uint256 newValue) public onlyOwner {\r\n        require(newValue == 0 || newValue > _totalSupply, \"Invalid max supply\");\r\n        emit OnMaxSupplyChanged(maxSupply, newValue);\r\n        maxSupply = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Issues a given number of tokens to the address specified.\r\n     * @dev This function throws if the sender is not a whitelisted minter.\r\n     * @param addr The destination address\r\n     * @param amount The number of tokens\r\n     */\r\n    function mint (address addr, uint256 amount) public onlyMinter {\r\n        require(addr != address(0) && addr != address(this), \"Invalid address\");\r\n        require(amount > 0, \"Invalid amount\");\r\n        require(canMint(amount), \"Max token supply exceeded\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[addr] += amount;\r\n        emit Transfer(address(0), addr, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burns a given number of tokens from the address specified.\r\n     * @dev This function throws if the sender is not a whitelisted minter. In this context, minters and burners have the same privileges.\r\n     * @param addr The destination address\r\n     * @param amount The number of tokens\r\n     */\r\n    function burn (address addr, uint256 amount) public onlyBurner {\r\n        require(addr != address(0) && addr != address(this), \"Invalid address\");\r\n        require(amount > 0, \"Invalid amount\");\r\n        require(_totalSupply > 0, \"No token supply\");\r\n\r\n        uint256 accountBalance = _balances[addr];\r\n        require(accountBalance >= amount, \"Burn amount exceeds balance\");\r\n\r\n        _balances[addr] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(addr, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Indicates if we can issue/mint the number of tokens specified.\r\n     * @param amount The number of tokens to issue/mint\r\n     */\r\n    function canMint (uint256 amount) public view returns (bool) {\r\n        return (maxSupply == 0) || (_totalSupply + amount <= maxSupply);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Represents a receipt token. The token is fully compliant with the ERC20 interface.\r\n * @dev The token can be minted or burnt by whitelisted addresses only. Only the owner is allowed to enable/disable addresses.\r\n */\r\ncontract ReceiptToken is Mintable {\r\n    /**\r\n     * @notice Constructor.\r\n     * @param newOwner The owner of the smart contract.\r\n     */\r\n    constructor (address newOwner, uint256 initialMaxSupply) Mintable(newOwner, \"Fractal Protocol Vault Token\", \"USDF\", 6, 0) {\r\n        maxSupply = initialMaxSupply;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialMaxSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OnBurnerGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OnBurnerRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"OnMaxSupplyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OnMinterGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OnMinterRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"canMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"changeMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"grantBurner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"grantMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"revokeBurner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"revokeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ReceiptToken", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c692d583567cda0fde14cd3d6136c2623202ed68000000000000000000000000000000000000000000000000000000174876e800", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://541bc9cc0a33e0fae3e729a5b8fb937627dd2edf9217ad1638c68f86b1fbebbe"}]}