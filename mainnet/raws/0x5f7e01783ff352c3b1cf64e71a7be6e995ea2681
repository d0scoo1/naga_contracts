{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\r\n   ____            __   __        __   _\r\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\r\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\r\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\r\n     /___/\r\n\r\n* Synthetix: migrations/Migration_Peacock.sol\r\n*\r\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/migrations/Migration_Peacock.sol\r\n* Docs: https://docs.synthetix.io/contracts/migrations/Migration_Peacock\r\n*\r\n* Contract Dependencies: \r\n*\t- BaseMigration\r\n*\t- EternalStorage\r\n*\t- IAddressResolver\r\n*\t- IFeePool\r\n*\t- IRewardEscrow\r\n*\t- LimitedSetup\r\n*\t- MixinResolver\r\n*\t- MixinSystemSettings\r\n*\t- Owned\r\n*\t- Proxyable\r\n*\t- State\r\n* Libraries: \r\n*\t- SafeDecimalMath\r\n*\t- SafeMath\r\n*\t- VestingEntries\r\n*\r\n* MIT License\r\n* ===========\r\n*\r\n* Copyright (c) 2022 Synthetix\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/\r\n\r\n\r\n\r\npragma solidity ^0.5.16;\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/owned\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    constructor(address _owner) public {\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    function nominateNewOwner(address _owner) external onlyOwner {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    function _onlyOwner() private view {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n\r\ncontract BaseMigration is Owned {\r\n    address public deployer;\r\n\r\n    constructor(address _owner) internal Owned(_owner) {\r\n        deployer = msg.sender;\r\n    }\r\n\r\n    // safety value to return ownership (anyone can invoke)\r\n    function returnOwnership(address forContract) public {\r\n        bytes memory payload = abi.encodeWithSignature(\"nominateNewOwner(address)\", owner);\r\n\r\n        // solhint-disable avoid-low-level-calls\r\n        (bool success, ) = forContract.call(payload);\r\n\r\n        if (!success) {\r\n            // then try legacy way\r\n            bytes memory legacyPayload = abi.encodeWithSignature(\"nominateOwner(address)\", owner);\r\n\r\n            // solhint-disable avoid-low-level-calls\r\n            (bool legacySuccess, ) = forContract.call(legacyPayload);\r\n\r\n            require(legacySuccess, \"Legacy nomination failed\");\r\n        }\r\n    }\r\n\r\n    function _requireDeployer() private view {\r\n        require(msg.sender == deployer, \"Only the deployer can invoke this\");\r\n    }\r\n\r\n    modifier onlyDeployer() {\r\n        _requireDeployer();\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\r\ninterface IAddressResolver {\r\n    function getAddress(bytes32 name) external view returns (address);\r\n\r\n    function getSynth(bytes32 key) external view returns (address);\r\n\r\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\r\ninterface ISynth {\r\n    // Views\r\n    function currencyKey() external view returns (bytes32);\r\n\r\n    function transferableSynths(address account) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function transferAndSettle(address to, uint value) external returns (bool);\r\n\r\n    function transferFromAndSettle(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    // Restricted: used internally to Synthetix\r\n    function burn(address account, uint amount) external;\r\n\r\n    function issue(address account, uint amount) external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\r\ninterface IIssuer {\r\n    // Views\r\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\r\n\r\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\r\n\r\n    function availableSynthCount() external view returns (uint);\r\n\r\n    function availableSynths(uint index) external view returns (ISynth);\r\n\r\n    function canBurnSynths(address account) external view returns (bool);\r\n\r\n    function collateral(address account) external view returns (uint);\r\n\r\n    function collateralisationRatio(address issuer) external view returns (uint);\r\n\r\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\r\n        external\r\n        view\r\n        returns (uint cratio, bool anyRateIsInvalid);\r\n\r\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\r\n\r\n    function issuanceRatio() external view returns (uint);\r\n\r\n    function lastIssueEvent(address account) external view returns (uint);\r\n\r\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\r\n\r\n    function minimumStakeTime() external view returns (uint);\r\n\r\n    function remainingIssuableSynths(address issuer)\r\n        external\r\n        view\r\n        returns (\r\n            uint maxIssuable,\r\n            uint alreadyIssued,\r\n            uint totalSystemDebt\r\n        );\r\n\r\n    function synths(bytes32 currencyKey) external view returns (ISynth);\r\n\r\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\r\n\r\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\r\n\r\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\r\n\r\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\r\n        external\r\n        view\r\n        returns (uint transferable, bool anyRateIsInvalid);\r\n\r\n    // Restricted: used internally to Synthetix\r\n    function issueSynths(address from, uint amount) external;\r\n\r\n    function issueSynthsOnBehalf(\r\n        address issueFor,\r\n        address from,\r\n        uint amount\r\n    ) external;\r\n\r\n    function issueMaxSynths(address from) external;\r\n\r\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\r\n\r\n    function burnSynths(address from, uint amount) external;\r\n\r\n    function burnSynthsOnBehalf(\r\n        address burnForAddress,\r\n        address from,\r\n        uint amount\r\n    ) external;\r\n\r\n    function burnSynthsToTarget(address from) external;\r\n\r\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\r\n\r\n    function burnForRedemption(\r\n        address deprecatedSynthProxy,\r\n        address account,\r\n        uint balance\r\n    ) external;\r\n\r\n    function liquidateDelinquentAccount(\r\n        address account,\r\n        uint susdAmount,\r\n        address liquidator\r\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\r\n}\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\r\ncontract MixinResolver {\r\n    AddressResolver public resolver;\r\n\r\n    mapping(bytes32 => address) private addressCache;\r\n\r\n    constructor(address _resolver) internal {\r\n        resolver = AddressResolver(_resolver);\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\r\n        internal\r\n        pure\r\n        returns (bytes32[] memory combination)\r\n    {\r\n        combination = new bytes32[](first.length + second.length);\r\n\r\n        for (uint i = 0; i < first.length; i++) {\r\n            combination[i] = first[i];\r\n        }\r\n\r\n        for (uint j = 0; j < second.length; j++) {\r\n            combination[first.length + j] = second[j];\r\n        }\r\n    }\r\n\r\n    /* ========== PUBLIC FUNCTIONS ========== */\r\n\r\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\r\n\r\n    function rebuildCache() public {\r\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\r\n        // The resolver must call this function whenver it updates its state\r\n        for (uint i = 0; i < requiredAddresses.length; i++) {\r\n            bytes32 name = requiredAddresses[i];\r\n            // Note: can only be invoked once the resolver has all the targets needed added\r\n            address destination =\r\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\r\n            addressCache[name] = destination;\r\n            emit CacheUpdated(name, destination);\r\n        }\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function isResolverCached() external view returns (bool) {\r\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\r\n        for (uint i = 0; i < requiredAddresses.length; i++) {\r\n            bytes32 name = requiredAddresses[i];\r\n            // false if our cache is invalid or if the resolver doesn't have the required address\r\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\r\n        address _foundAddress = addressCache[name];\r\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\r\n        return _foundAddress;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event CacheUpdated(bytes32 name, address destination);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\r\ncontract AddressResolver is Owned, IAddressResolver {\r\n    mapping(bytes32 => address) public repository;\r\n\r\n    constructor(address _owner) public Owned(_owner) {}\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\r\n        require(names.length == destinations.length, \"Input lengths must match\");\r\n\r\n        for (uint i = 0; i < names.length; i++) {\r\n            bytes32 name = names[i];\r\n            address destination = destinations[i];\r\n            repository[name] = destination;\r\n            emit AddressImported(name, destination);\r\n        }\r\n    }\r\n\r\n    /* ========= PUBLIC FUNCTIONS ========== */\r\n\r\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\r\n        for (uint i = 0; i < destinations.length; i++) {\r\n            destinations[i].rebuildCache();\r\n        }\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\r\n        for (uint i = 0; i < names.length; i++) {\r\n            if (repository[names[i]] != destinations[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getAddress(bytes32 name) external view returns (address) {\r\n        return repository[name];\r\n    }\r\n\r\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\r\n        address _foundAddress = repository[name];\r\n        require(_foundAddress != address(0), reason);\r\n        return _foundAddress;\r\n    }\r\n\r\n    function getSynth(bytes32 key) external view returns (address) {\r\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\r\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\r\n        return address(issuer.synths(key));\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AddressImported(bytes32 name, address destination);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\r\ncontract Proxyable is Owned {\r\n    // This contract should be treated like an abstract contract\r\n\r\n    /* The proxy this contract exists behind. */\r\n    Proxy public proxy;\r\n\r\n    /* The caller of the proxy, passed through to this contract.\r\n     * Note that every function using this member must apply the onlyProxy or\r\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\r\n    address public messageSender;\r\n\r\n    constructor(address payable _proxy) internal {\r\n        // This contract is abstract, and thus cannot be instantiated directly\r\n        require(owner != address(0), \"Owner must be set\");\r\n\r\n        proxy = Proxy(_proxy);\r\n        emit ProxyUpdated(_proxy);\r\n    }\r\n\r\n    function setProxy(address payable _proxy) external onlyOwner {\r\n        proxy = Proxy(_proxy);\r\n        emit ProxyUpdated(_proxy);\r\n    }\r\n\r\n    function setMessageSender(address sender) external onlyProxy {\r\n        messageSender = sender;\r\n    }\r\n\r\n    modifier onlyProxy {\r\n        _onlyProxy();\r\n        _;\r\n    }\r\n\r\n    function _onlyProxy() private view {\r\n        require(Proxy(msg.sender) == proxy, \"Only the proxy can call\");\r\n    }\r\n\r\n    modifier optionalProxy {\r\n        _optionalProxy();\r\n        _;\r\n    }\r\n\r\n    function _optionalProxy() private {\r\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\r\n            messageSender = msg.sender;\r\n        }\r\n    }\r\n\r\n    modifier optionalProxy_onlyOwner {\r\n        _optionalProxy_onlyOwner();\r\n        _;\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function _optionalProxy_onlyOwner() private {\r\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\r\n            messageSender = msg.sender;\r\n        }\r\n        require(messageSender == owner, \"Owner only function\");\r\n    }\r\n\r\n    event ProxyUpdated(address proxyAddress);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/proxy\r\ncontract Proxy is Owned {\r\n    Proxyable public target;\r\n\r\n    constructor(address _owner) public Owned(_owner) {}\r\n\r\n    function setTarget(Proxyable _target) external onlyOwner {\r\n        target = _target;\r\n        emit TargetUpdated(_target);\r\n    }\r\n\r\n    function _emit(\r\n        bytes calldata callData,\r\n        uint numTopics,\r\n        bytes32 topic1,\r\n        bytes32 topic2,\r\n        bytes32 topic3,\r\n        bytes32 topic4\r\n    ) external onlyTarget {\r\n        uint size = callData.length;\r\n        bytes memory _callData = callData;\r\n\r\n        assembly {\r\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\r\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\r\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\r\n             * This means moving call_data across 32 bytes guarantees we correctly access\r\n             * the data itself. */\r\n            switch numTopics\r\n                case 0 {\r\n                    log0(add(_callData, 32), size)\r\n                }\r\n                case 1 {\r\n                    log1(add(_callData, 32), size, topic1)\r\n                }\r\n                case 2 {\r\n                    log2(add(_callData, 32), size, topic1, topic2)\r\n                }\r\n                case 3 {\r\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\r\n                }\r\n                case 4 {\r\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\r\n                }\r\n        }\r\n    }\r\n\r\n    // solhint-disable no-complex-fallback\r\n    function() external payable {\r\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\r\n        target.setMessageSender(msg.sender);\r\n\r\n        assembly {\r\n            let free_ptr := mload(0x40)\r\n            calldatacopy(free_ptr, 0, calldatasize)\r\n\r\n            /* We must explicitly forward ether to the underlying contract as well. */\r\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\r\n            returndatacopy(free_ptr, 0, returndatasize)\r\n\r\n            if iszero(result) {\r\n                revert(free_ptr, returndatasize)\r\n            }\r\n            return(free_ptr, returndatasize)\r\n        }\r\n    }\r\n\r\n    modifier onlyTarget {\r\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\r\n        _;\r\n    }\r\n\r\n    event TargetUpdated(Proxyable newTarget);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/state\r\ncontract State is Owned {\r\n    // the address of the contract that can modify variables\r\n    // this can only be changed by the owner of this contract\r\n    address public associatedContract;\r\n\r\n    constructor(address _associatedContract) internal {\r\n        // This contract is abstract, and thus cannot be instantiated directly\r\n        require(owner != address(0), \"Owner must be set\");\r\n\r\n        associatedContract = _associatedContract;\r\n        emit AssociatedContractUpdated(_associatedContract);\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    // Change the associated contract to a new address\r\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\r\n        associatedContract = _associatedContract;\r\n        emit AssociatedContractUpdated(_associatedContract);\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyAssociatedContract {\r\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AssociatedContractUpdated(address associatedContract);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/eternalstorage\r\n/**\r\n * @notice  This contract is based on the code available from this blog\r\n * https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88/\r\n * Implements support for storing a keccak256 key and value pairs. It is the more flexible\r\n * and extensible option. This ensures data schema changes can be implemented without\r\n * requiring upgrades to the storage contract.\r\n */\r\ncontract EternalStorage is Owned, State {\r\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\r\n\r\n    /* ========== DATA TYPES ========== */\r\n    mapping(bytes32 => uint) internal UIntStorage;\r\n    mapping(bytes32 => string) internal StringStorage;\r\n    mapping(bytes32 => address) internal AddressStorage;\r\n    mapping(bytes32 => bytes) internal BytesStorage;\r\n    mapping(bytes32 => bytes32) internal Bytes32Storage;\r\n    mapping(bytes32 => bool) internal BooleanStorage;\r\n    mapping(bytes32 => int) internal IntStorage;\r\n\r\n    // UIntStorage;\r\n    function getUIntValue(bytes32 record) external view returns (uint) {\r\n        return UIntStorage[record];\r\n    }\r\n\r\n    function setUIntValue(bytes32 record, uint value) external onlyAssociatedContract {\r\n        UIntStorage[record] = value;\r\n    }\r\n\r\n    function deleteUIntValue(bytes32 record) external onlyAssociatedContract {\r\n        delete UIntStorage[record];\r\n    }\r\n\r\n    // StringStorage\r\n    function getStringValue(bytes32 record) external view returns (string memory) {\r\n        return StringStorage[record];\r\n    }\r\n\r\n    function setStringValue(bytes32 record, string calldata value) external onlyAssociatedContract {\r\n        StringStorage[record] = value;\r\n    }\r\n\r\n    function deleteStringValue(bytes32 record) external onlyAssociatedContract {\r\n        delete StringStorage[record];\r\n    }\r\n\r\n    // AddressStorage\r\n    function getAddressValue(bytes32 record) external view returns (address) {\r\n        return AddressStorage[record];\r\n    }\r\n\r\n    function setAddressValue(bytes32 record, address value) external onlyAssociatedContract {\r\n        AddressStorage[record] = value;\r\n    }\r\n\r\n    function deleteAddressValue(bytes32 record) external onlyAssociatedContract {\r\n        delete AddressStorage[record];\r\n    }\r\n\r\n    // BytesStorage\r\n    function getBytesValue(bytes32 record) external view returns (bytes memory) {\r\n        return BytesStorage[record];\r\n    }\r\n\r\n    function setBytesValue(bytes32 record, bytes calldata value) external onlyAssociatedContract {\r\n        BytesStorage[record] = value;\r\n    }\r\n\r\n    function deleteBytesValue(bytes32 record) external onlyAssociatedContract {\r\n        delete BytesStorage[record];\r\n    }\r\n\r\n    // Bytes32Storage\r\n    function getBytes32Value(bytes32 record) external view returns (bytes32) {\r\n        return Bytes32Storage[record];\r\n    }\r\n\r\n    function setBytes32Value(bytes32 record, bytes32 value) external onlyAssociatedContract {\r\n        Bytes32Storage[record] = value;\r\n    }\r\n\r\n    function deleteBytes32Value(bytes32 record) external onlyAssociatedContract {\r\n        delete Bytes32Storage[record];\r\n    }\r\n\r\n    // BooleanStorage\r\n    function getBooleanValue(bytes32 record) external view returns (bool) {\r\n        return BooleanStorage[record];\r\n    }\r\n\r\n    function setBooleanValue(bytes32 record, bool value) external onlyAssociatedContract {\r\n        BooleanStorage[record] = value;\r\n    }\r\n\r\n    function deleteBooleanValue(bytes32 record) external onlyAssociatedContract {\r\n        delete BooleanStorage[record];\r\n    }\r\n\r\n    // IntStorage\r\n    function getIntValue(bytes32 record) external view returns (int) {\r\n        return IntStorage[record];\r\n    }\r\n\r\n    function setIntValue(bytes32 record, int value) external onlyAssociatedContract {\r\n        IntStorage[record] = value;\r\n    }\r\n\r\n    function deleteIntValue(bytes32 record) external onlyAssociatedContract {\r\n        delete IntStorage[record];\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/limitedsetup\r\ncontract LimitedSetup {\r\n    uint public setupExpiryTime;\r\n\r\n    /**\r\n     * @dev LimitedSetup Constructor.\r\n     * @param setupDuration The time the setup period will last for.\r\n     */\r\n    constructor(uint setupDuration) internal {\r\n        setupExpiryTime = now + setupDuration;\r\n    }\r\n\r\n    modifier onlyDuringSetup {\r\n        require(now < setupExpiryTime, \"Can only perform this action during setup\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/feepooleternalstorage\r\ncontract FeePoolEternalStorage is EternalStorage, LimitedSetup {\r\n    bytes32 internal constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\r\n\r\n    constructor(address _owner, address _feePool) public EternalStorage(_owner, _feePool) LimitedSetup(6 weeks) {}\r\n\r\n    function importFeeWithdrawalData(address[] calldata accounts, uint[] calldata feePeriodIDs)\r\n        external\r\n        onlyOwner\r\n        onlyDuringSetup\r\n    {\r\n        require(accounts.length == feePeriodIDs.length, \"Length mismatch\");\r\n\r\n        for (uint8 i = 0; i < accounts.length; i++) {\r\n            this.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, accounts[i])), feePeriodIDs[i]);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\r\nlibrary SafeDecimalMath {\r\n    using SafeMath for uint;\r\n\r\n    /* Number of decimal places in the representations. */\r\n    uint8 public constant decimals = 18;\r\n    uint8 public constant highPrecisionDecimals = 27;\r\n\r\n    /* The number representing 1.0. */\r\n    uint public constant UNIT = 10**uint(decimals);\r\n\r\n    /* The number representing 1.0 for higher fidelity numbers. */\r\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\r\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\r\n\r\n    /**\r\n     * @return Provides an interface to UNIT.\r\n     */\r\n    function unit() external pure returns (uint) {\r\n        return UNIT;\r\n    }\r\n\r\n    /**\r\n     * @return Provides an interface to PRECISE_UNIT.\r\n     */\r\n    function preciseUnit() external pure returns (uint) {\r\n        return PRECISE_UNIT;\r\n    }\r\n\r\n    /**\r\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\r\n     * decimals.\r\n     *\r\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\r\n     * so that product must be less than 2**256. As this is an integer division,\r\n     * the internal division always rounds down. This helps save on gas. Rounding\r\n     * is more expensive on gas.\r\n     */\r\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\r\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\r\n        return x.mul(y) / UNIT;\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely multiplying x and y, interpreting the operands\r\n     * as fixed-point decimals of the specified precision unit.\r\n     *\r\n     * @dev The operands should be in the form of a the specified unit factor which will be\r\n     * divided out after the product of x and y is evaluated, so that product must be\r\n     * less than 2**256.\r\n     *\r\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\r\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\r\n     * (eg. small fractions or percentages).\r\n     */\r\n    function _multiplyDecimalRound(\r\n        uint x,\r\n        uint y,\r\n        uint precisionUnit\r\n    ) private pure returns (uint) {\r\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\r\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\r\n\r\n        if (quotientTimesTen % 10 >= 5) {\r\n            quotientTimesTen += 10;\r\n        }\r\n\r\n        return quotientTimesTen / 10;\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely multiplying x and y, interpreting the operands\r\n     * as fixed-point decimals of a precise unit.\r\n     *\r\n     * @dev The operands should be in the precise unit factor which will be\r\n     * divided out after the product of x and y is evaluated, so that product must be\r\n     * less than 2**256.\r\n     *\r\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\r\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\r\n     * (eg. small fractions or percentages).\r\n     */\r\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\r\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely multiplying x and y, interpreting the operands\r\n     * as fixed-point decimals of a standard unit.\r\n     *\r\n     * @dev The operands should be in the standard unit factor which will be\r\n     * divided out after the product of x and y is evaluated, so that product must be\r\n     * less than 2**256.\r\n     *\r\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\r\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\r\n     * (eg. small fractions or percentages).\r\n     */\r\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\r\n        return _multiplyDecimalRound(x, y, UNIT);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is a high\r\n     * precision decimal.\r\n     *\r\n     * @dev y is divided after the product of x and the standard precision unit\r\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\r\n     * this is an integer division, the result is always rounded down.\r\n     * This helps save on gas. Rounding is more expensive on gas.\r\n     */\r\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\r\n        /* Reintroduce the UNIT factor that will be divided out by y. */\r\n        return x.mul(UNIT).div(y);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is as a rounded\r\n     * decimal in the precision unit specified in the parameter.\r\n     *\r\n     * @dev y is divided after the product of x and the specified precision unit\r\n     * is evaluated, so the product of x and the specified precision unit must\r\n     * be less than 2**256. The result is rounded to the nearest increment.\r\n     */\r\n    function _divideDecimalRound(\r\n        uint x,\r\n        uint y,\r\n        uint precisionUnit\r\n    ) private pure returns (uint) {\r\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\r\n\r\n        if (resultTimesTen % 10 >= 5) {\r\n            resultTimesTen += 10;\r\n        }\r\n\r\n        return resultTimesTen / 10;\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is as a rounded\r\n     * standard precision decimal.\r\n     *\r\n     * @dev y is divided after the product of x and the standard precision unit\r\n     * is evaluated, so the product of x and the standard precision unit must\r\n     * be less than 2**256. The result is rounded to the nearest increment.\r\n     */\r\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\r\n        return _divideDecimalRound(x, y, UNIT);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is as a rounded\r\n     * high precision decimal.\r\n     *\r\n     * @dev y is divided after the product of x and the high precision unit\r\n     * is evaluated, so the product of x and the high precision unit must\r\n     * be less than 2**256. The result is rounded to the nearest increment.\r\n     */\r\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\r\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\r\n    }\r\n\r\n    /**\r\n     * @dev Convert a standard decimal representation to a high precision one.\r\n     */\r\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\r\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Convert a high precision decimal to a standard decimal representation.\r\n     */\r\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\r\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\r\n\r\n        if (quotientTimesTen % 10 >= 5) {\r\n            quotientTimesTen += 10;\r\n        }\r\n\r\n        return quotientTimesTen / 10;\r\n    }\r\n\r\n    // Computes `a - b`, setting the value to 0 if b > a.\r\n    function floorsub(uint a, uint b) internal pure returns (uint) {\r\n        return b >= a ? 0 : a - b;\r\n    }\r\n\r\n    /* ---------- Utilities ---------- */\r\n    /*\r\n     * Absolute value of the input, returned as a signed number.\r\n     */\r\n    function signedAbs(int x) internal pure returns (int) {\r\n        return x < 0 ? -x : x;\r\n    }\r\n\r\n    /*\r\n     * Absolute value of the input, returned as an unsigned number.\r\n     */\r\n    function abs(int x) internal pure returns (uint) {\r\n        return uint(signedAbs(x));\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\r\ninterface IFeePool {\r\n    // Views\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function FEE_ADDRESS() external view returns (address);\r\n\r\n    function feesAvailable(address account) external view returns (uint, uint);\r\n\r\n    function feePeriodDuration() external view returns (uint);\r\n\r\n    function isFeesClaimable(address account) external view returns (bool);\r\n\r\n    function targetThreshold() external view returns (uint);\r\n\r\n    function totalFeesAvailable() external view returns (uint);\r\n\r\n    function totalRewardsAvailable() external view returns (uint);\r\n\r\n    // Mutative Functions\r\n    function claimFees() external returns (bool);\r\n\r\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\r\n\r\n    function closeCurrentFeePeriod() external;\r\n\r\n    // Restricted: used internally to Synthetix\r\n    function appendAccountIssuanceRecord(\r\n        address account,\r\n        uint lockedAmount,\r\n        uint debtEntryIndex\r\n    ) external;\r\n\r\n    function recordFeePaid(uint sUSDAmount) external;\r\n\r\n    function setRewardsToDistribute(uint amount) external;\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/feepoolstate\r\ncontract FeePoolState is Owned, LimitedSetup {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    uint8 public constant FEE_PERIOD_LENGTH = 6;\r\n\r\n    address public feePool;\r\n\r\n    // The IssuanceData activity that's happened in a fee period.\r\n    struct IssuanceData {\r\n        uint debtPercentage;\r\n        uint debtEntryIndex;\r\n    }\r\n\r\n    // The IssuanceData activity that's happened in a fee period.\r\n    mapping(address => IssuanceData[FEE_PERIOD_LENGTH]) public accountIssuanceLedger;\r\n\r\n    constructor(address _owner, IFeePool _feePool) public Owned(_owner) LimitedSetup(6 weeks) {\r\n        feePool = address(_feePool);\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice set the FeePool contract as it is the only authority to be able to call\r\n     * appendAccountIssuanceRecord with the onlyFeePool modifer\r\n     * @dev Must be set by owner when FeePool logic is upgraded\r\n     */\r\n    function setFeePool(IFeePool _feePool) external onlyOwner {\r\n        feePool = address(_feePool);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    /**\r\n     * @notice Get an accounts issuanceData for\r\n     * @param account users account\r\n     * @param index Index in the array to retrieve. Upto FEE_PERIOD_LENGTH\r\n     */\r\n    function getAccountsDebtEntry(address account, uint index)\r\n        public\r\n        view\r\n        returns (uint debtPercentage, uint debtEntryIndex)\r\n    {\r\n        require(index < FEE_PERIOD_LENGTH, \"index exceeds the FEE_PERIOD_LENGTH\");\r\n\r\n        debtPercentage = accountIssuanceLedger[account][index].debtPercentage;\r\n        debtEntryIndex = accountIssuanceLedger[account][index].debtEntryIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Find the oldest debtEntryIndex for the corresponding closingDebtIndex\r\n     * @param account users account\r\n     * @param closingDebtIndex the last periods debt index on close\r\n     */\r\n    function applicableIssuanceData(address account, uint closingDebtIndex) external view returns (uint, uint) {\r\n        IssuanceData[FEE_PERIOD_LENGTH] memory issuanceData = accountIssuanceLedger[account];\r\n\r\n        // We want to use the user's debtEntryIndex at when the period closed\r\n        // Find the oldest debtEntryIndex for the corresponding closingDebtIndex\r\n        for (uint i = 0; i < FEE_PERIOD_LENGTH; i++) {\r\n            if (closingDebtIndex >= issuanceData[i].debtEntryIndex) {\r\n                return (issuanceData[i].debtPercentage, issuanceData[i].debtEntryIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Logs an accounts issuance data in the current fee period which is then stored historically\r\n     * @param account Message.Senders account address\r\n     * @param debtRatio Debt of this account as a percentage of the global debt.\r\n     * @param debtEntryIndex The index in the global debt ledger. synthetix.synthetixState().issuanceData(account)\r\n     * @param currentPeriodStartDebtIndex The startingDebtIndex of the current fee period\r\n     * @dev onlyFeePool to call me on synthetix.issue() & synthetix.burn() calls to store the locked SNX\r\n     * per fee period so we know to allocate the correct proportions of fees and rewards per period\r\n      accountIssuanceLedger[account][0] has the latest locked amount for the current period. This can be update as many time\r\n      accountIssuanceLedger[account][1-2] has the last locked amount for a previous period they minted or burned\r\n     */\r\n    function appendAccountIssuanceRecord(\r\n        address account,\r\n        uint debtRatio,\r\n        uint debtEntryIndex,\r\n        uint currentPeriodStartDebtIndex\r\n    ) external onlyFeePool {\r\n        // Is the current debtEntryIndex within this fee period\r\n        if (accountIssuanceLedger[account][0].debtEntryIndex < currentPeriodStartDebtIndex) {\r\n            // If its older then shift the previous IssuanceData entries periods down to make room for the new one.\r\n            issuanceDataIndexOrder(account);\r\n        }\r\n\r\n        // Always store the latest IssuanceData entry at [0]\r\n        accountIssuanceLedger[account][0].debtPercentage = debtRatio;\r\n        accountIssuanceLedger[account][0].debtEntryIndex = debtEntryIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Pushes down the entire array of debt ratios per fee period\r\n     */\r\n    function issuanceDataIndexOrder(address account) private {\r\n        for (uint i = FEE_PERIOD_LENGTH - 2; i < FEE_PERIOD_LENGTH; i--) {\r\n            uint next = i + 1;\r\n            accountIssuanceLedger[account][next].debtPercentage = accountIssuanceLedger[account][i].debtPercentage;\r\n            accountIssuanceLedger[account][next].debtEntryIndex = accountIssuanceLedger[account][i].debtEntryIndex;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Import issuer data from synthetixState.issuerData on FeePeriodClose() block #\r\n     * @dev Only callable by the contract owner, and only for 6 weeks after deployment.\r\n     * @param accounts Array of issuing addresses\r\n     * @param ratios Array of debt ratios\r\n     * @param periodToInsert The Fee Period to insert the historical records into\r\n     * @param feePeriodCloseIndex An accounts debtEntryIndex is valid when within the fee peroid,\r\n     * since the input ratio will be an average of the pervious periods it just needs to be\r\n     * > recentFeePeriods[periodToInsert].startingDebtIndex\r\n     * < recentFeePeriods[periodToInsert - 1].startingDebtIndex\r\n     */\r\n    function importIssuerData(\r\n        address[] calldata accounts,\r\n        uint[] calldata ratios,\r\n        uint periodToInsert,\r\n        uint feePeriodCloseIndex\r\n    ) external onlyOwner onlyDuringSetup {\r\n        require(accounts.length == ratios.length, \"Length mismatch\");\r\n\r\n        for (uint i = 0; i < accounts.length; i++) {\r\n            accountIssuanceLedger[accounts[i]][periodToInsert].debtPercentage = ratios[i];\r\n            accountIssuanceLedger[accounts[i]][periodToInsert].debtEntryIndex = feePeriodCloseIndex;\r\n            emit IssuanceDebtRatioEntry(accounts[i], ratios[i], feePeriodCloseIndex);\r\n        }\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyFeePool {\r\n        require(msg.sender == address(feePool), \"Only the FeePool contract can perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== Events ========== */\r\n    event IssuanceDebtRatioEntry(address indexed account, uint debtRatio, uint feePeriodCloseIndex);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/irewardescrow\r\ninterface IRewardEscrow {\r\n    // Views\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function numVestingEntries(address account) external view returns (uint);\r\n\r\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\r\n\r\n    function totalVestedAccountBalance(address account) external view returns (uint);\r\n\r\n    function getVestingScheduleEntry(address account, uint index) external view returns (uint[2] memory);\r\n\r\n    function getNextVestingIndex(address account) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function appendVestingEntry(address account, uint quantity) external;\r\n\r\n    function vest() external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\r\ninterface IERC20 {\r\n    // ERC20 Optional Views\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    // Views\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\ninterface IVirtualSynth {\r\n    // Views\r\n    function balanceOfUnderlying(address account) external view returns (uint);\r\n\r\n    function rate() external view returns (uint);\r\n\r\n    function readyToSettle() external view returns (bool);\r\n\r\n    function secsLeftInWaitingPeriod() external view returns (uint);\r\n\r\n    function settled() external view returns (bool);\r\n\r\n    function synth() external view returns (ISynth);\r\n\r\n    // Mutative functions\r\n    function settle(address account) external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\r\ninterface ISynthetix {\r\n    // Views\r\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\r\n\r\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\r\n\r\n    function availableSynthCount() external view returns (uint);\r\n\r\n    function availableSynths(uint index) external view returns (ISynth);\r\n\r\n    function collateral(address account) external view returns (uint);\r\n\r\n    function collateralisationRatio(address issuer) external view returns (uint);\r\n\r\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\r\n\r\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\r\n\r\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\r\n\r\n    function remainingIssuableSynths(address issuer)\r\n        external\r\n        view\r\n        returns (\r\n            uint maxIssuable,\r\n            uint alreadyIssued,\r\n            uint totalSystemDebt\r\n        );\r\n\r\n    function synths(bytes32 currencyKey) external view returns (ISynth);\r\n\r\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\r\n\r\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function totalIssuedSynthsExcludeOtherCollateral(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function transferableSynthetix(address account) external view returns (uint transferable);\r\n\r\n    // Mutative Functions\r\n    function burnSynths(uint amount) external;\r\n\r\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\r\n\r\n    function burnSynthsToTarget() external;\r\n\r\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\r\n\r\n    function exchange(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeOnBehalf(\r\n        address exchangeForAddress,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeWithTracking(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address rewardAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeWithTrackingForInitiator(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address rewardAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeOnBehalfWithTracking(\r\n        address exchangeForAddress,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address rewardAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeWithVirtual(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\r\n\r\n    function exchangeAtomically(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function issueMaxSynths() external;\r\n\r\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\r\n\r\n    function issueSynths(uint amount) external;\r\n\r\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\r\n\r\n    function mint() external returns (bool);\r\n\r\n    function settle(bytes32 currencyKey)\r\n        external\r\n        returns (\r\n            uint reclaimed,\r\n            uint refunded,\r\n            uint numEntries\r\n        );\r\n\r\n    // Liquidations\r\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\r\n\r\n    // Restricted Functions\r\n\r\n    function mintSecondary(address account, uint amount) external;\r\n\r\n    function mintSecondaryRewards(uint amount) external;\r\n\r\n    function burnSecondary(address account, uint amount) external;\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/rewardescrow\r\ncontract RewardEscrow is Owned, IRewardEscrow {\r\n    using SafeMath for uint;\r\n\r\n    /* The corresponding Synthetix contract. */\r\n    ISynthetix public synthetix;\r\n\r\n    IFeePool public feePool;\r\n\r\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\r\n     * These are the times at which each given quantity of SNX vests. */\r\n    mapping(address => uint[2][]) public vestingSchedules;\r\n\r\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\r\n    mapping(address => uint) public totalEscrowedAccountBalance;\r\n\r\n    /* An account's total vested reward synthetix. */\r\n    mapping(address => uint) public totalVestedAccountBalance;\r\n\r\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\r\n    uint public totalEscrowedBalance;\r\n\r\n    uint internal constant TIME_INDEX = 0;\r\n    uint internal constant QUANTITY_INDEX = 1;\r\n\r\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\r\n     * There are 5 years of the supply schedule */\r\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        address _owner,\r\n        ISynthetix _synthetix,\r\n        IFeePool _feePool\r\n    ) public Owned(_owner) {\r\n        synthetix = _synthetix;\r\n        feePool = _feePool;\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\r\n     */\r\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\r\n        synthetix = _synthetix;\r\n        emit SynthetixUpdated(address(_synthetix));\r\n    }\r\n\r\n    /**\r\n     * @notice set the FeePool contract as it is the only authority to be able to call\r\n     * appendVestingEntry with the onlyFeePool modifer\r\n     */\r\n    function setFeePool(IFeePool _feePool) external onlyOwner {\r\n        feePool = _feePool;\r\n        emit FeePoolUpdated(address(_feePool));\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\r\n     */\r\n    function balanceOf(address account) public view returns (uint) {\r\n        return totalEscrowedAccountBalance[account];\r\n    }\r\n\r\n    function _numVestingEntries(address account) internal view returns (uint) {\r\n        return vestingSchedules[account].length;\r\n    }\r\n\r\n    /**\r\n     * @notice The number of vesting dates in an account's schedule.\r\n     */\r\n    function numVestingEntries(address account) external view returns (uint) {\r\n        return vestingSchedules[account].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Get a particular schedule entry for an account.\r\n     * @return A pair of uints: (timestamp, synthetix quantity).\r\n     */\r\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {\r\n        return vestingSchedules[account][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the time at which a given schedule entry will vest.\r\n     */\r\n    function getVestingTime(address account, uint index) public view returns (uint) {\r\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the quantity of SNX associated with a given schedule entry.\r\n     */\r\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\r\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\r\n     */\r\n    function getNextVestingIndex(address account) public view returns (uint) {\r\n        uint len = _numVestingEntries(account);\r\n        for (uint i = 0; i < len; i++) {\r\n            if (getVestingTime(account, i) != 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the next schedule entry that will vest for a given user.\r\n     * @return A pair of uints: (timestamp, synthetix quantity). */\r\n    function getNextVestingEntry(address account) public view returns (uint[2] memory) {\r\n        uint index = getNextVestingIndex(account);\r\n        if (index == _numVestingEntries(account)) {\r\n            return [uint(0), 0];\r\n        }\r\n        return getVestingScheduleEntry(account, index);\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\r\n     */\r\n    function getNextVestingTime(address account) external view returns (uint) {\r\n        return getNextVestingEntry(account)[TIME_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\r\n     */\r\n    function getNextVestingQuantity(address account) external view returns (uint) {\r\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice return the full vesting schedule entries vest for a given user.\r\n     * @dev For DApps to display the vesting schedule for the\r\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\r\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\r\n     */\r\n    function checkAccountSchedule(address account) public view returns (uint[520] memory) {\r\n        uint[520] memory _result;\r\n        uint schedules = _numVestingEntries(account);\r\n        for (uint i = 0; i < schedules; i++) {\r\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\r\n            _result[i * 2] = pair[0];\r\n            _result[i * 2 + 1] = pair[1];\r\n        }\r\n        return _result;\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function _appendVestingEntry(address account, uint quantity) internal {\r\n        /* No empty or already-passed vesting entries allowed. */\r\n        require(quantity != 0, \"Quantity cannot be zero\");\r\n\r\n        /* There must be enough balance in the contract to provide for the vesting entry. */\r\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\r\n        require(\r\n            totalEscrowedBalance <= IERC20(address(synthetix)).balanceOf(address(this)),\r\n            \"Must be enough balance in the contract to provide for the vesting entry\"\r\n        );\r\n\r\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\r\n        uint scheduleLength = vestingSchedules[account].length;\r\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\r\n\r\n        /* Escrow the tokens for 1 year. */\r\n        uint time = now + 52 weeks;\r\n\r\n        if (scheduleLength == 0) {\r\n            totalEscrowedAccountBalance[account] = quantity;\r\n        } else {\r\n            /* Disallow adding new vested SNX earlier than the last one.\r\n             * Since entries are only appended, this means that no vesting date can be repeated. */\r\n            require(\r\n                getVestingTime(account, scheduleLength - 1) < time,\r\n                \"Cannot add new vested entries earlier than the last one\"\r\n            );\r\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\r\n        }\r\n\r\n        vestingSchedules[account].push([time, quantity]);\r\n\r\n        emit VestingEntryCreated(account, now, quantity);\r\n    }\r\n\r\n    /**\r\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\r\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\r\n     * to ensure that when the funds are withdrawn, there is enough balance.\r\n     * Note; although this function could technically be used to produce unbounded\r\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\r\n     * @param account The account to append a new vesting entry to.\r\n     * @param quantity The quantity of SNX that will be escrowed.\r\n     */\r\n    function appendVestingEntry(address account, uint quantity) external onlyFeePool {\r\n        _appendVestingEntry(account, quantity);\r\n    }\r\n\r\n    /**\r\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\r\n     */\r\n    function vest() external {\r\n        uint numEntries = _numVestingEntries(msg.sender);\r\n        uint total;\r\n        for (uint i = 0; i < numEntries; i++) {\r\n            uint time = getVestingTime(msg.sender, i);\r\n            /* The list is sorted; when we reach the first future time, bail out. */\r\n            if (time > now) {\r\n                break;\r\n            }\r\n            uint qty = getVestingQuantity(msg.sender, i);\r\n            if (qty > 0) {\r\n                vestingSchedules[msg.sender][i] = [0, 0];\r\n                total = total.add(qty);\r\n            }\r\n        }\r\n\r\n        if (total != 0) {\r\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\r\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\r\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\r\n            IERC20(address(synthetix)).transfer(msg.sender, total);\r\n            emit Vested(msg.sender, now, total);\r\n        }\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyFeePool() {\r\n        bool isFeePool = msg.sender == address(feePool);\r\n\r\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event SynthetixUpdated(address newSynthetix);\r\n\r\n    event FeePoolUpdated(address newFeePool);\r\n\r\n    event Vested(address indexed beneficiary, uint time, uint value);\r\n\r\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\r\ninterface IFlexibleStorage {\r\n    // Views\r\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\r\n\r\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\r\n\r\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\r\n\r\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\r\n\r\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\r\n\r\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\r\n\r\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\r\n\r\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\r\n\r\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\r\n\r\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\r\n\r\n    // Mutative functions\r\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\r\n\r\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\r\n\r\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\r\n\r\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\r\n\r\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\r\n\r\n    function setUIntValue(\r\n        bytes32 contractName,\r\n        bytes32 record,\r\n        uint value\r\n    ) external;\r\n\r\n    function setUIntValues(\r\n        bytes32 contractName,\r\n        bytes32[] calldata records,\r\n        uint[] calldata values\r\n    ) external;\r\n\r\n    function setIntValue(\r\n        bytes32 contractName,\r\n        bytes32 record,\r\n        int value\r\n    ) external;\r\n\r\n    function setIntValues(\r\n        bytes32 contractName,\r\n        bytes32[] calldata records,\r\n        int[] calldata values\r\n    ) external;\r\n\r\n    function setAddressValue(\r\n        bytes32 contractName,\r\n        bytes32 record,\r\n        address value\r\n    ) external;\r\n\r\n    function setAddressValues(\r\n        bytes32 contractName,\r\n        bytes32[] calldata records,\r\n        address[] calldata values\r\n    ) external;\r\n\r\n    function setBoolValue(\r\n        bytes32 contractName,\r\n        bytes32 record,\r\n        bool value\r\n    ) external;\r\n\r\n    function setBoolValues(\r\n        bytes32 contractName,\r\n        bytes32[] calldata records,\r\n        bool[] calldata values\r\n    ) external;\r\n\r\n    function setBytes32Value(\r\n        bytes32 contractName,\r\n        bytes32 record,\r\n        bytes32 value\r\n    ) external;\r\n\r\n    function setBytes32Values(\r\n        bytes32 contractName,\r\n        bytes32[] calldata records,\r\n        bytes32[] calldata values\r\n    ) external;\r\n}\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\r\ncontract MixinSystemSettings is MixinResolver {\r\n    // must match the one defined SystemSettingsLib, defined in both places due to sol v0.5 limitations\r\n    bytes32 internal constant SETTING_CONTRACT_NAME = \"SystemSettings\";\r\n\r\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \"waitingPeriodSecs\";\r\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \"priceDeviationThresholdFactor\";\r\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \"issuanceRatio\";\r\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \"feePeriodDuration\";\r\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \"targetThreshold\";\r\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \"liquidationDelay\";\r\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \"liquidationRatio\";\r\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \"liquidationPenalty\";\r\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \"rateStalePeriod\";\r\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \"exchangeFeeRate\";\r\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \"minimumStakeTime\";\r\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \"aggregatorWarningFlags\";\r\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \"tradingRewardsEnabled\";\r\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \"debtSnapshotStaleTime\";\r\n    bytes32 internal constant SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = \"crossDomainDepositGasLimit\";\r\n    bytes32 internal constant SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = \"crossDomainEscrowGasLimit\";\r\n    bytes32 internal constant SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = \"crossDomainRewardGasLimit\";\r\n    bytes32 internal constant SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = \"crossDomainWithdrawalGasLimit\";\r\n    bytes32 internal constant SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT = \"crossDomainRelayGasLimit\";\r\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MAX_ETH = \"etherWrapperMaxETH\";\r\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MINT_FEE_RATE = \"etherWrapperMintFeeRate\";\r\n    bytes32 internal constant SETTING_ETHER_WRAPPER_BURN_FEE_RATE = \"etherWrapperBurnFeeRate\";\r\n    bytes32 internal constant SETTING_WRAPPER_MAX_TOKEN_AMOUNT = \"wrapperMaxTokens\";\r\n    bytes32 internal constant SETTING_WRAPPER_MINT_FEE_RATE = \"wrapperMintFeeRate\";\r\n    bytes32 internal constant SETTING_WRAPPER_BURN_FEE_RATE = \"wrapperBurnFeeRate\";\r\n    bytes32 internal constant SETTING_INTERACTION_DELAY = \"interactionDelay\";\r\n    bytes32 internal constant SETTING_COLLAPSE_FEE_RATE = \"collapseFeeRate\";\r\n    bytes32 internal constant SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK = \"atomicMaxVolumePerBlock\";\r\n    bytes32 internal constant SETTING_ATOMIC_TWAP_WINDOW = \"atomicTwapWindow\";\r\n    bytes32 internal constant SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING = \"atomicEquivalentForDexPricing\";\r\n    bytes32 internal constant SETTING_ATOMIC_EXCHANGE_FEE_RATE = \"atomicExchangeFeeRate\";\r\n    bytes32 internal constant SETTING_ATOMIC_PRICE_BUFFER = \"atomicPriceBuffer\";\r\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = \"atomicVolConsiderationWindow\";\r\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD = \"atomicVolUpdateThreshold\";\r\n\r\n    bytes32 internal constant CONTRACT_FLEXIBLESTORAGE = \"FlexibleStorage\";\r\n\r\n    enum CrossDomainMessageGasLimits {Deposit, Escrow, Reward, Withdrawal, Relay}\r\n\r\n    constructor(address _resolver) internal MixinResolver(_resolver) {}\r\n\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\r\n        addresses = new bytes32[](1);\r\n        addresses[0] = CONTRACT_FLEXIBLESTORAGE;\r\n    }\r\n\r\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\r\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));\r\n    }\r\n\r\n    function _getGasLimitSetting(CrossDomainMessageGasLimits gasLimitType) internal pure returns (bytes32) {\r\n        if (gasLimitType == CrossDomainMessageGasLimits.Deposit) {\r\n            return SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT;\r\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Escrow) {\r\n            return SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT;\r\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Reward) {\r\n            return SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT;\r\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Withdrawal) {\r\n            return SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT;\r\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Relay) {\r\n            return SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT;\r\n        } else {\r\n            revert(\"Unknown gas limit type\");\r\n        }\r\n    }\r\n\r\n    function getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, _getGasLimitSetting(gasLimitType));\r\n    }\r\n\r\n    function getTradingRewardsEnabled() internal view returns (bool) {\r\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\r\n    }\r\n\r\n    function getWaitingPeriodSecs() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\r\n    }\r\n\r\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\r\n    }\r\n\r\n    function getIssuanceRatio() internal view returns (uint) {\r\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\r\n    }\r\n\r\n    function getFeePeriodDuration() internal view returns (uint) {\r\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\r\n    }\r\n\r\n    function getTargetThreshold() internal view returns (uint) {\r\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\r\n    }\r\n\r\n    function getLiquidationDelay() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\r\n    }\r\n\r\n    function getLiquidationRatio() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\r\n    }\r\n\r\n    function getLiquidationPenalty() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\r\n    }\r\n\r\n    function getRateStalePeriod() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\r\n    }\r\n\r\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\r\n            );\r\n    }\r\n\r\n    function getMinimumStakeTime() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\r\n    }\r\n\r\n    function getAggregatorWarningFlags() internal view returns (address) {\r\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\r\n    }\r\n\r\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\r\n    }\r\n\r\n    function getEtherWrapperMaxETH() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);\r\n    }\r\n\r\n    function getEtherWrapperMintFeeRate() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);\r\n    }\r\n\r\n    function getEtherWrapperBurnFeeRate() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);\r\n    }\r\n\r\n    function getWrapperMaxTokenAmount(address wrapper) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, wrapper))\r\n            );\r\n    }\r\n\r\n    function getWrapperMintFeeRate(address wrapper) internal view returns (int) {\r\n        return\r\n            flexibleStorage().getIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE, wrapper))\r\n            );\r\n    }\r\n\r\n    function getWrapperBurnFeeRate(address wrapper) internal view returns (int) {\r\n        return\r\n            flexibleStorage().getIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE, wrapper))\r\n            );\r\n    }\r\n\r\n    function getInteractionDelay(address collateral) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, collateral))\r\n            );\r\n    }\r\n\r\n    function getCollapseFeeRate(address collateral) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, collateral))\r\n            );\r\n    }\r\n\r\n    function getAtomicMaxVolumePerBlock() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK);\r\n    }\r\n\r\n    function getAtomicTwapWindow() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_TWAP_WINDOW);\r\n    }\r\n\r\n    function getAtomicEquivalentForDexPricing(bytes32 currencyKey) internal view returns (address) {\r\n        return\r\n            flexibleStorage().getAddressValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING, currencyKey))\r\n            );\r\n    }\r\n\r\n    function getAtomicExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE, currencyKey))\r\n            );\r\n    }\r\n\r\n    function getAtomicPriceBuffer(bytes32 currencyKey) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_ATOMIC_PRICE_BUFFER, currencyKey))\r\n            );\r\n    }\r\n\r\n    function getAtomicVolatilityConsiderationWindow(bytes32 currencyKey) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW, currencyKey))\r\n            );\r\n    }\r\n\r\n    function getAtomicVolatilityUpdateThreshold(bytes32 currencyKey) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD, currencyKey))\r\n            );\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\r\ninterface ISystemStatus {\r\n    struct Status {\r\n        bool canSuspend;\r\n        bool canResume;\r\n    }\r\n\r\n    struct Suspension {\r\n        bool suspended;\r\n        // reason is an integer code,\r\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\r\n        uint248 reason;\r\n    }\r\n\r\n    // Views\r\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\r\n\r\n    function requireSystemActive() external view;\r\n\r\n    function requireIssuanceActive() external view;\r\n\r\n    function requireExchangeActive() external view;\r\n\r\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\r\n\r\n    function requireSynthActive(bytes32 currencyKey) external view;\r\n\r\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\r\n\r\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\r\n\r\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\r\n\r\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\r\n\r\n    function synthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\r\n\r\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\r\n\r\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\r\n        external\r\n        view\r\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\r\n\r\n    function getSynthSuspensions(bytes32[] calldata synths)\r\n        external\r\n        view\r\n        returns (bool[] memory suspensions, uint256[] memory reasons);\r\n\r\n    // Restricted functions\r\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\r\n\r\n    function updateAccessControl(\r\n        bytes32 section,\r\n        address account,\r\n        bool canSuspend,\r\n        bool canResume\r\n    ) external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\r\ninterface IExchanger {\r\n    // Views\r\n    function calculateAmountAfterSettlement(\r\n        address from,\r\n        bytes32 currencyKey,\r\n        uint amount,\r\n        uint refunded\r\n    ) external view returns (uint amountAfterSettlement);\r\n\r\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\r\n\r\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\r\n\r\n    function settlementOwing(address account, bytes32 currencyKey)\r\n        external\r\n        view\r\n        returns (\r\n            uint reclaimAmount,\r\n            uint rebateAmount,\r\n            uint numEntries\r\n        );\r\n\r\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\r\n\r\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\r\n        external\r\n        view\r\n        returns (uint exchangeFeeRate);\r\n\r\n    function getAmountsForExchange(\r\n        uint sourceAmount,\r\n        bytes32 sourceCurrencyKey,\r\n        bytes32 destinationCurrencyKey\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint amountReceived,\r\n            uint fee,\r\n            uint exchangeFeeRate\r\n        );\r\n\r\n    function priceDeviationThresholdFactor() external view returns (uint);\r\n\r\n    function waitingPeriodSecs() external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function exchange(\r\n        address exchangeForAddress,\r\n        address from,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address destinationAddress,\r\n        bool virtualSynth,\r\n        address rewardAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\r\n\r\n    function exchangeAtomically(\r\n        address from,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address destinationAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function settle(address from, bytes32 currencyKey)\r\n        external\r\n        returns (\r\n            uint reclaimed,\r\n            uint refunded,\r\n            uint numEntries\r\n        );\r\n\r\n    function resetLastExchangeRate(bytes32[] calldata currencyKeys) external;\r\n\r\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetixstate\r\ninterface ISynthetixState {\r\n    // Views\r\n    function debtLedger(uint index) external view returns (uint);\r\n\r\n    function issuanceData(address account) external view returns (uint initialDebtOwnership, uint debtEntryIndex);\r\n\r\n    function debtLedgerLength() external view returns (uint);\r\n\r\n    function hasIssued(address account) external view returns (bool);\r\n\r\n    function lastDebtLedgerEntry() external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function incrementTotalIssuerCount() external;\r\n\r\n    function decrementTotalIssuerCount() external;\r\n\r\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external;\r\n\r\n    function appendDebtLedgerValue(uint value) external;\r\n\r\n    function clearIssuanceData(address account) external;\r\n}\r\n\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary VestingEntries {\r\n    struct VestingEntry {\r\n        uint64 endTime;\r\n        uint256 escrowAmount;\r\n    }\r\n    struct VestingEntryWithID {\r\n        uint64 endTime;\r\n        uint256 escrowAmount;\r\n        uint256 entryID;\r\n    }\r\n}\r\n\r\ninterface IRewardEscrowV2 {\r\n    // Views\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function numVestingEntries(address account) external view returns (uint);\r\n\r\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\r\n\r\n    function totalVestedAccountBalance(address account) external view returns (uint);\r\n\r\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\r\n\r\n    function getVestingSchedules(\r\n        address account,\r\n        uint256 index,\r\n        uint256 pageSize\r\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\r\n\r\n    function getAccountVestingEntryIDs(\r\n        address account,\r\n        uint256 index,\r\n        uint256 pageSize\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\r\n\r\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\r\n\r\n    // Mutative functions\r\n    function vest(uint256[] calldata entryIDs) external;\r\n\r\n    function createEscrowEntry(\r\n        address beneficiary,\r\n        uint256 deposit,\r\n        uint256 duration\r\n    ) external;\r\n\r\n    function appendVestingEntry(\r\n        address account,\r\n        uint256 quantity,\r\n        uint256 duration\r\n    ) external;\r\n\r\n    function migrateVestingSchedule(address _addressToMigrate) external;\r\n\r\n    function migrateAccountEscrowBalances(\r\n        address[] calldata accounts,\r\n        uint256[] calldata escrowBalances,\r\n        uint256[] calldata vestedBalances\r\n    ) external;\r\n\r\n    // Account Merging\r\n    function startMergingWindow() external;\r\n\r\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\r\n\r\n    function nominateAccountToMerge(address account) external;\r\n\r\n    function accountMergingIsOpen() external view returns (bool);\r\n\r\n    // L2 Migration\r\n    function importVestingEntries(\r\n        address account,\r\n        uint256 escrowedAmount,\r\n        VestingEntries.VestingEntry[] calldata vestingEntries\r\n    ) external;\r\n\r\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\r\n    function burnForMigration(address account, uint256[] calldata entryIDs)\r\n        external\r\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/idelegateapprovals\r\ninterface IDelegateApprovals {\r\n    // Views\r\n    function canBurnFor(address authoriser, address delegate) external view returns (bool);\r\n\r\n    function canIssueFor(address authoriser, address delegate) external view returns (bool);\r\n\r\n    function canClaimFor(address authoriser, address delegate) external view returns (bool);\r\n\r\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool);\r\n\r\n    // Mutative\r\n    function approveAllDelegatePowers(address delegate) external;\r\n\r\n    function removeAllDelegatePowers(address delegate) external;\r\n\r\n    function approveBurnOnBehalf(address delegate) external;\r\n\r\n    function removeBurnOnBehalf(address delegate) external;\r\n\r\n    function approveIssueOnBehalf(address delegate) external;\r\n\r\n    function removeIssueOnBehalf(address delegate) external;\r\n\r\n    function approveClaimOnBehalf(address delegate) external;\r\n\r\n    function removeClaimOnBehalf(address delegate) external;\r\n\r\n    function approveExchangeOnBehalf(address delegate) external;\r\n\r\n    function removeExchangeOnBehalf(address delegate) external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/irewardsdistribution\r\ninterface IRewardsDistribution {\r\n    // Structs\r\n    struct DistributionData {\r\n        address destination;\r\n        uint amount;\r\n    }\r\n\r\n    // Views\r\n    function authority() external view returns (address);\r\n\r\n    function distributions(uint index) external view returns (address destination, uint amount); // DistributionData\r\n\r\n    function distributionsLength() external view returns (uint);\r\n\r\n    // Mutative Functions\r\n    function distributeRewards(uint amount) external returns (bool);\r\n}\r\n\r\n\r\ninterface ICollateralManager {\r\n    // Manager information\r\n    function hasCollateral(address collateral) external view returns (bool);\r\n\r\n    function isSynthManaged(bytes32 currencyKey) external view returns (bool);\r\n\r\n    // State information\r\n    function long(bytes32 synth) external view returns (uint amount);\r\n\r\n    function short(bytes32 synth) external view returns (uint amount);\r\n\r\n    function totalLong() external view returns (uint susdValue, bool anyRateIsInvalid);\r\n\r\n    function totalShort() external view returns (uint susdValue, bool anyRateIsInvalid);\r\n\r\n    function getBorrowRate() external view returns (uint borrowRate, bool anyRateIsInvalid);\r\n\r\n    function getShortRate(bytes32 synth) external view returns (uint shortRate, bool rateIsInvalid);\r\n\r\n    function getRatesAndTime(uint index)\r\n        external\r\n        view\r\n        returns (\r\n            uint entryRate,\r\n            uint lastRate,\r\n            uint lastUpdated,\r\n            uint newIndex\r\n        );\r\n\r\n    function getShortRatesAndTime(bytes32 currency, uint index)\r\n        external\r\n        view\r\n        returns (\r\n            uint entryRate,\r\n            uint lastRate,\r\n            uint lastUpdated,\r\n            uint newIndex\r\n        );\r\n\r\n    function exceedsDebtLimit(uint amount, bytes32 currency) external view returns (bool canIssue, bool anyRateIsInvalid);\r\n\r\n    function areSynthsAndCurrenciesSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function areShortableSynthsSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    // Loans\r\n    function getNewLoanId() external returns (uint id);\r\n\r\n    // Manager mutative\r\n    function addCollaterals(address[] calldata collaterals) external;\r\n\r\n    function removeCollaterals(address[] calldata collaterals) external;\r\n\r\n    function addSynths(bytes32[] calldata synthNamesInResolver, bytes32[] calldata synthKeys) external;\r\n\r\n    function removeSynths(bytes32[] calldata synths, bytes32[] calldata synthKeys) external;\r\n\r\n    function addShortableSynths(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys) external;\r\n\r\n    function removeShortableSynths(bytes32[] calldata synths) external;\r\n\r\n    // State mutative\r\n\r\n    function incrementLongs(bytes32 synth, uint amount) external;\r\n\r\n    function decrementLongs(bytes32 synth, uint amount) external;\r\n\r\n    function incrementShorts(bytes32 synth, uint amount) external;\r\n\r\n    function decrementShorts(bytes32 synth, uint amount) external;\r\n\r\n    function accrueInterest(\r\n        uint interestIndex,\r\n        bytes32 currency,\r\n        bool isShort\r\n    ) external returns (uint difference, uint index);\r\n\r\n    function updateBorrowRatesCollateral(uint rate) external;\r\n\r\n    function updateShortRatesCollateral(bytes32 currency, uint rate) external;\r\n}\r\n\r\n\r\ninterface IWETH {\r\n    // ERC20 Optional Views\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    // Views\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    // WETH-specific functions.\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint amount) external;\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Deposit(address indexed to, uint amount);\r\n    event Withdrawal(address indexed to, uint amount);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/ietherwrapper\r\ncontract IEtherWrapper {\r\n    function mint(uint amount) external;\r\n\r\n    function burn(uint amount) external;\r\n\r\n    function distributeFees() external;\r\n\r\n    function capacity() external view returns (uint);\r\n\r\n    function getReserves() external view returns (uint);\r\n\r\n    function totalIssuedSynths() external view returns (uint);\r\n\r\n    function calculateMintFee(uint amount) public view returns (uint);\r\n\r\n    function calculateBurnFee(uint amount) public view returns (uint);\r\n\r\n    function maxETH() public view returns (uint256);\r\n\r\n    function mintFeeRate() public view returns (uint256);\r\n\r\n    function burnFeeRate() public view returns (uint256);\r\n\r\n    function weth() public view returns (IWETH);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iwrapperfactory\r\ninterface IWrapperFactory {\r\n    function isWrapper(address possibleWrapper) external view returns (bool);\r\n\r\n    function createWrapper(\r\n        IERC20 token,\r\n        bytes32 currencyKey,\r\n        bytes32 synthContractName\r\n    ) external returns (address);\r\n\r\n    function distributeFees() external;\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/feepool\r\ncontract FeePool is Owned, Proxyable, LimitedSetup, MixinSystemSettings, IFeePool {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    bytes32 public constant CONTRACT_NAME = \"FeePool\";\r\n\r\n    // Where fees are pooled in sUSD.\r\n    address public constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\r\n\r\n    // sUSD currencyKey. Fees stored and paid in sUSD\r\n    bytes32 private sUSD = \"sUSD\";\r\n\r\n    // This struct represents the issuance activity that's happened in a fee period.\r\n    struct FeePeriod {\r\n        uint64 feePeriodId;\r\n        uint64 startingDebtIndex;\r\n        uint64 startTime;\r\n        uint feesToDistribute;\r\n        uint feesClaimed;\r\n        uint rewardsToDistribute;\r\n        uint rewardsClaimed;\r\n    }\r\n\r\n    // A staker(mintr) can claim from the previous fee period (7 days) only.\r\n    // Fee Periods stored and managed from [0], such that [0] is always\r\n    // the current active fee period which is not claimable until the\r\n    // public function closeCurrentFeePeriod() is called closing the\r\n    // current weeks collected fees. [1] is last weeks feeperiod\r\n    uint8 public constant FEE_PERIOD_LENGTH = 2;\r\n\r\n    FeePeriod[FEE_PERIOD_LENGTH] private _recentFeePeriods;\r\n    uint256 private _currentFeePeriod;\r\n\r\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\r\n\r\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\r\n    bytes32 private constant CONTRACT_SYNTHETIX = \"Synthetix\";\r\n    bytes32 private constant CONTRACT_FEEPOOLSTATE = \"FeePoolState\";\r\n    bytes32 private constant CONTRACT_FEEPOOLETERNALSTORAGE = \"FeePoolEternalStorage\";\r\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\r\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\r\n    bytes32 private constant CONTRACT_SYNTHETIXSTATE = \"SynthetixState\";\r\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \"RewardEscrowV2\";\r\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \"DelegateApprovals\";\r\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \"CollateralManager\";\r\n    bytes32 private constant CONTRACT_REWARDSDISTRIBUTION = \"RewardsDistribution\";\r\n    bytes32 private constant CONTRACT_ETHER_WRAPPER = \"EtherWrapper\";\r\n    bytes32 private constant CONTRACT_WRAPPER_FACTORY = \"WrapperFactory\";\r\n\r\n    /* ========== ETERNAL STORAGE CONSTANTS ========== */\r\n\r\n    bytes32 private constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\r\n\r\n    constructor(\r\n        address payable _proxy,\r\n        address _owner,\r\n        address _resolver\r\n    ) public Owned(_owner) Proxyable(_proxy) LimitedSetup(3 weeks) MixinSystemSettings(_resolver) {\r\n        // Set our initial fee period\r\n        _recentFeePeriodsStorage(0).feePeriodId = 1;\r\n        _recentFeePeriodsStorage(0).startTime = uint64(now);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\r\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\r\n        bytes32[] memory newAddresses = new bytes32[](13);\r\n        newAddresses[0] = CONTRACT_SYSTEMSTATUS;\r\n        newAddresses[1] = CONTRACT_SYNTHETIX;\r\n        newAddresses[2] = CONTRACT_FEEPOOLSTATE;\r\n        newAddresses[3] = CONTRACT_FEEPOOLETERNALSTORAGE;\r\n        newAddresses[4] = CONTRACT_EXCHANGER;\r\n        newAddresses[5] = CONTRACT_ISSUER;\r\n        newAddresses[6] = CONTRACT_SYNTHETIXSTATE;\r\n        newAddresses[7] = CONTRACT_REWARDESCROW_V2;\r\n        newAddresses[8] = CONTRACT_DELEGATEAPPROVALS;\r\n        newAddresses[9] = CONTRACT_REWARDSDISTRIBUTION;\r\n        newAddresses[10] = CONTRACT_COLLATERALMANAGER;\r\n        newAddresses[11] = CONTRACT_WRAPPER_FACTORY;\r\n        newAddresses[12] = CONTRACT_ETHER_WRAPPER;\r\n        addresses = combineArrays(existingAddresses, newAddresses);\r\n    }\r\n\r\n    function systemStatus() internal view returns (ISystemStatus) {\r\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\r\n    }\r\n\r\n    function synthetix() internal view returns (ISynthetix) {\r\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));\r\n    }\r\n\r\n    function feePoolState() internal view returns (FeePoolState) {\r\n        return FeePoolState(requireAndGetAddress(CONTRACT_FEEPOOLSTATE));\r\n    }\r\n\r\n    function feePoolEternalStorage() internal view returns (FeePoolEternalStorage) {\r\n        return FeePoolEternalStorage(requireAndGetAddress(CONTRACT_FEEPOOLETERNALSTORAGE));\r\n    }\r\n\r\n    function exchanger() internal view returns (IExchanger) {\r\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\r\n    }\r\n\r\n    function collateralManager() internal view returns (ICollateralManager) {\r\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\r\n    }\r\n\r\n    function issuer() internal view returns (IIssuer) {\r\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\r\n    }\r\n\r\n    function synthetixState() internal view returns (ISynthetixState) {\r\n        return ISynthetixState(requireAndGetAddress(CONTRACT_SYNTHETIXSTATE));\r\n    }\r\n\r\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\r\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\r\n    }\r\n\r\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\r\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\r\n    }\r\n\r\n    function rewardsDistribution() internal view returns (IRewardsDistribution) {\r\n        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));\r\n    }\r\n\r\n    function etherWrapper() internal view returns (IEtherWrapper) {\r\n        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));\r\n    }\r\n\r\n    function wrapperFactory() internal view returns (IWrapperFactory) {\r\n        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));\r\n    }\r\n\r\n    function issuanceRatio() external view returns (uint) {\r\n        return getIssuanceRatio();\r\n    }\r\n\r\n    function feePeriodDuration() external view returns (uint) {\r\n        return getFeePeriodDuration();\r\n    }\r\n\r\n    function targetThreshold() external view returns (uint) {\r\n        return getTargetThreshold();\r\n    }\r\n\r\n    function recentFeePeriods(uint index)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 feePeriodId,\r\n            uint64 startingDebtIndex,\r\n            uint64 startTime,\r\n            uint feesToDistribute,\r\n            uint feesClaimed,\r\n            uint rewardsToDistribute,\r\n            uint rewardsClaimed\r\n        )\r\n    {\r\n        FeePeriod memory feePeriod = _recentFeePeriodsStorage(index);\r\n        return (\r\n            feePeriod.feePeriodId,\r\n            feePeriod.startingDebtIndex,\r\n            feePeriod.startTime,\r\n            feePeriod.feesToDistribute,\r\n            feePeriod.feesClaimed,\r\n            feePeriod.rewardsToDistribute,\r\n            feePeriod.rewardsClaimed\r\n        );\r\n    }\r\n\r\n    function _recentFeePeriodsStorage(uint index) internal view returns (FeePeriod storage) {\r\n        return _recentFeePeriods[(_currentFeePeriod + index) % FEE_PERIOD_LENGTH];\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Logs an accounts issuance data per fee period\r\n     * @param account Message.Senders account address\r\n     * @param debtRatio Debt percentage this account has locked after minting or burning their synth\r\n     * @param debtEntryIndex The index in the global debt ledger. synthetixState.issuanceData(account)\r\n     * @dev onlyIssuer to call me on synthetix.issue() & synthetix.burn() calls to store the locked SNX\r\n     * per fee period so we know to allocate the correct proportions of fees and rewards per period\r\n     */\r\n    function appendAccountIssuanceRecord(\r\n        address account,\r\n        uint debtRatio,\r\n        uint debtEntryIndex\r\n    ) external onlyIssuerAndSynthetixState {\r\n        feePoolState().appendAccountIssuanceRecord(\r\n            account,\r\n            debtRatio,\r\n            debtEntryIndex,\r\n            _recentFeePeriodsStorage(0).startingDebtIndex\r\n        );\r\n\r\n        emitIssuanceDebtRatioEntry(account, debtRatio, debtEntryIndex, _recentFeePeriodsStorage(0).startingDebtIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice The Exchanger contract informs us when fees are paid.\r\n     * @param amount susd amount in fees being paid.\r\n     */\r\n    function recordFeePaid(uint amount) external onlyInternalContracts {\r\n        // Keep track off fees in sUSD in the open fee pool period.\r\n        _recentFeePeriodsStorage(0).feesToDistribute = _recentFeePeriodsStorage(0).feesToDistribute.add(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice The RewardsDistribution contract informs us how many SNX rewards are sent to RewardEscrow to be claimed.\r\n     */\r\n    function setRewardsToDistribute(uint amount) external optionalProxy {\r\n        require(messageSender == address(rewardsDistribution()), \"RewardsDistribution only\");\r\n        // Add the amount of SNX rewards to distribute on top of any rolling unclaimed amount\r\n        _recentFeePeriodsStorage(0).rewardsToDistribute = _recentFeePeriodsStorage(0).rewardsToDistribute.add(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Close the current fee period and start a new one.\r\n     */\r\n    function closeCurrentFeePeriod() external issuanceActive {\r\n        require(getFeePeriodDuration() > 0, \"Fee Period Duration not set\");\r\n        require(_recentFeePeriodsStorage(0).startTime <= (now - getFeePeriodDuration()), \"Too early to close fee period\");\r\n\r\n        etherWrapper().distributeFees();\r\n        wrapperFactory().distributeFees();\r\n\r\n        // Note:  when FEE_PERIOD_LENGTH = 2, periodClosing is the current period & periodToRollover is the last open claimable period\r\n        FeePeriod storage periodClosing = _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2);\r\n        FeePeriod storage periodToRollover = _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 1);\r\n\r\n        // Any unclaimed fees from the last period in the array roll back one period.\r\n        // Because of the subtraction here, they're effectively proportionally redistributed to those who\r\n        // have already claimed from the old period, available in the new period.\r\n        // The subtraction is important so we don't create a ticking time bomb of an ever growing\r\n        // number of fees that can never decrease and will eventually overflow at the end of the fee pool.\r\n        _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2).feesToDistribute = periodToRollover\r\n            .feesToDistribute\r\n            .sub(periodToRollover.feesClaimed)\r\n            .add(periodClosing.feesToDistribute);\r\n        _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2).rewardsToDistribute = periodToRollover\r\n            .rewardsToDistribute\r\n            .sub(periodToRollover.rewardsClaimed)\r\n            .add(periodClosing.rewardsToDistribute);\r\n\r\n        // Shift the previous fee periods across to make room for the new one.\r\n        _currentFeePeriod = _currentFeePeriod.add(FEE_PERIOD_LENGTH).sub(1).mod(FEE_PERIOD_LENGTH);\r\n\r\n        // Clear the first element of the array to make sure we don't have any stale values.\r\n        delete _recentFeePeriods[_currentFeePeriod];\r\n\r\n        // Open up the new fee period.\r\n        // Increment periodId from the recent closed period feePeriodId\r\n        _recentFeePeriodsStorage(0).feePeriodId = uint64(uint256(_recentFeePeriodsStorage(1).feePeriodId).add(1));\r\n        _recentFeePeriodsStorage(0).startingDebtIndex = uint64(synthetixState().debtLedgerLength());\r\n        _recentFeePeriodsStorage(0).startTime = uint64(now);\r\n\r\n        emitFeePeriodClosed(_recentFeePeriodsStorage(1).feePeriodId);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim fees for last period when available or not already withdrawn.\r\n     */\r\n    function claimFees() external issuanceActive optionalProxy returns (bool) {\r\n        return _claimFees(messageSender);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegated claimFees(). Call from the deletegated address\r\n     * and the fees will be sent to the claimingForAddress.\r\n     * approveClaimOnBehalf() must be called first to approve the deletage address\r\n     * @param claimingForAddress The account you are claiming fees for\r\n     */\r\n    function claimOnBehalf(address claimingForAddress) external issuanceActive optionalProxy returns (bool) {\r\n        require(delegateApprovals().canClaimFor(claimingForAddress, messageSender), \"Not approved to claim on behalf\");\r\n\r\n        return _claimFees(claimingForAddress);\r\n    }\r\n\r\n    function _claimFees(address claimingAddress) internal returns (bool) {\r\n        uint rewardsPaid = 0;\r\n        uint feesPaid = 0;\r\n        uint availableFees;\r\n        uint availableRewards;\r\n\r\n        // Address won't be able to claim fees if it is too far below the target c-ratio.\r\n        // It will need to burn synths then try claiming again.\r\n        (bool feesClaimable, bool anyRateIsInvalid) = _isFeesClaimableAndAnyRatesInvalid(claimingAddress);\r\n\r\n        require(feesClaimable, \"C-Ratio below penalty threshold\");\r\n\r\n        require(!anyRateIsInvalid, \"A synth or SNX rate is invalid\");\r\n\r\n        // Get the claimingAddress available fees and rewards\r\n        (availableFees, availableRewards) = feesAvailable(claimingAddress);\r\n\r\n        require(\r\n            availableFees > 0 || availableRewards > 0,\r\n            \"No fees or rewards available for period, or fees already claimed\"\r\n        );\r\n\r\n        // Record the address has claimed for this period\r\n        _setLastFeeWithdrawal(claimingAddress, _recentFeePeriodsStorage(1).feePeriodId);\r\n\r\n        if (availableFees > 0) {\r\n            // Record the fee payment in our recentFeePeriods\r\n            feesPaid = _recordFeePayment(availableFees);\r\n\r\n            // Send them their fees\r\n            _payFees(claimingAddress, feesPaid);\r\n        }\r\n\r\n        if (availableRewards > 0) {\r\n            // Record the reward payment in our recentFeePeriods\r\n            rewardsPaid = _recordRewardPayment(availableRewards);\r\n\r\n            // Send them their rewards\r\n            _payRewards(claimingAddress, rewardsPaid);\r\n        }\r\n\r\n        emitFeesClaimed(claimingAddress, feesPaid, rewardsPaid);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to import the FeePeriod data from the previous contract\r\n     */\r\n    function importFeePeriod(\r\n        uint feePeriodIndex,\r\n        uint feePeriodId,\r\n        uint startingDebtIndex,\r\n        uint startTime,\r\n        uint feesToDistribute,\r\n        uint feesClaimed,\r\n        uint rewardsToDistribute,\r\n        uint rewardsClaimed\r\n    ) public optionalProxy_onlyOwner onlyDuringSetup {\r\n        require(startingDebtIndex <= synthetixState().debtLedgerLength(), \"Cannot import bad data\");\r\n\r\n        _recentFeePeriods[_currentFeePeriod.add(feePeriodIndex).mod(FEE_PERIOD_LENGTH)] = FeePeriod({\r\n            feePeriodId: uint64(feePeriodId),\r\n            startingDebtIndex: uint64(startingDebtIndex),\r\n            startTime: uint64(startTime),\r\n            feesToDistribute: feesToDistribute,\r\n            feesClaimed: feesClaimed,\r\n            rewardsToDistribute: rewardsToDistribute,\r\n            rewardsClaimed: rewardsClaimed\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Record the fee payment in our recentFeePeriods.\r\n     * @param sUSDAmount The amount of fees priced in sUSD.\r\n     */\r\n    function _recordFeePayment(uint sUSDAmount) internal returns (uint) {\r\n        // Don't assign to the parameter\r\n        uint remainingToAllocate = sUSDAmount;\r\n\r\n        uint feesPaid;\r\n        // Start at the oldest period and record the amount, moving to newer periods\r\n        // until we've exhausted the amount.\r\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\r\n        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\r\n            uint feesAlreadyClaimed = _recentFeePeriodsStorage(i).feesClaimed;\r\n            uint delta = _recentFeePeriodsStorage(i).feesToDistribute.sub(feesAlreadyClaimed);\r\n\r\n            if (delta > 0) {\r\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\r\n                uint amountInPeriod = delta < remainingToAllocate ? delta : remainingToAllocate;\r\n\r\n                _recentFeePeriodsStorage(i).feesClaimed = feesAlreadyClaimed.add(amountInPeriod);\r\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\r\n                feesPaid = feesPaid.add(amountInPeriod);\r\n\r\n                // No need to continue iterating if we've recorded the whole amount;\r\n                if (remainingToAllocate == 0) return feesPaid;\r\n\r\n                // We've exhausted feePeriods to distribute and no fees remain in last period\r\n                // User last to claim would in this scenario have their remainder slashed\r\n                if (i == 0 && remainingToAllocate > 0) {\r\n                    remainingToAllocate = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        return feesPaid;\r\n    }\r\n\r\n    /**\r\n     * @notice Record the reward payment in our recentFeePeriods.\r\n     * @param snxAmount The amount of SNX tokens.\r\n     */\r\n    function _recordRewardPayment(uint snxAmount) internal returns (uint) {\r\n        // Don't assign to the parameter\r\n        uint remainingToAllocate = snxAmount;\r\n\r\n        uint rewardPaid;\r\n\r\n        // Start at the oldest period and record the amount, moving to newer periods\r\n        // until we've exhausted the amount.\r\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\r\n        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\r\n            uint toDistribute =\r\n                _recentFeePeriodsStorage(i).rewardsToDistribute.sub(_recentFeePeriodsStorage(i).rewardsClaimed);\r\n\r\n            if (toDistribute > 0) {\r\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\r\n                uint amountInPeriod = toDistribute < remainingToAllocate ? toDistribute : remainingToAllocate;\r\n\r\n                _recentFeePeriodsStorage(i).rewardsClaimed = _recentFeePeriodsStorage(i).rewardsClaimed.add(amountInPeriod);\r\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\r\n                rewardPaid = rewardPaid.add(amountInPeriod);\r\n\r\n                // No need to continue iterating if we've recorded the whole amount;\r\n                if (remainingToAllocate == 0) return rewardPaid;\r\n\r\n                // We've exhausted feePeriods to distribute and no rewards remain in last period\r\n                // User last to claim would in this scenario have their remainder slashed\r\n                // due to rounding up of PreciseDecimal\r\n                if (i == 0 && remainingToAllocate > 0) {\r\n                    remainingToAllocate = 0;\r\n                }\r\n            }\r\n        }\r\n        return rewardPaid;\r\n    }\r\n\r\n    /**\r\n     * @notice Send the fees to claiming address.\r\n     * @param account The address to send the fees to.\r\n     * @param sUSDAmount The amount of fees priced in sUSD.\r\n     */\r\n    function _payFees(address account, uint sUSDAmount) internal notFeeAddress(account) {\r\n        // Grab the sUSD Synth\r\n        ISynth sUSDSynth = issuer().synths(sUSD);\r\n\r\n        // NOTE: we do not control the FEE_ADDRESS so it is not possible to do an\r\n        // ERC20.approve() transaction to allow this feePool to call ERC20.transferFrom\r\n        // to the accounts address\r\n\r\n        // Burn the source amount\r\n        sUSDSynth.burn(FEE_ADDRESS, sUSDAmount);\r\n\r\n        // Mint their new synths\r\n        sUSDSynth.issue(account, sUSDAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Send the rewards to claiming address - will be locked in rewardEscrow.\r\n     * @param account The address to send the fees to.\r\n     * @param snxAmount The amount of SNX.\r\n     */\r\n    function _payRewards(address account, uint snxAmount) internal notFeeAddress(account) {\r\n        /* Escrow the tokens for 1 year. */\r\n        uint escrowDuration = 52 weeks;\r\n\r\n        // Record vesting entry for claiming address and amount\r\n        // SNX already minted to rewardEscrow balance\r\n        rewardEscrowV2().appendVestingEntry(account, snxAmount, escrowDuration);\r\n    }\r\n\r\n    /**\r\n     * @notice The total fees available in the system to be withdrawnn in sUSD\r\n     */\r\n    function totalFeesAvailable() external view returns (uint) {\r\n        uint totalFees = 0;\r\n\r\n        // Fees in fee period [0] are not yet available for withdrawal\r\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\r\n            totalFees = totalFees.add(_recentFeePeriodsStorage(i).feesToDistribute);\r\n            totalFees = totalFees.sub(_recentFeePeriodsStorage(i).feesClaimed);\r\n        }\r\n\r\n        return totalFees;\r\n    }\r\n\r\n    /**\r\n     * @notice The total SNX rewards available in the system to be withdrawn\r\n     */\r\n    function totalRewardsAvailable() external view returns (uint) {\r\n        uint totalRewards = 0;\r\n\r\n        // Rewards in fee period [0] are not yet available for withdrawal\r\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\r\n            totalRewards = totalRewards.add(_recentFeePeriodsStorage(i).rewardsToDistribute);\r\n            totalRewards = totalRewards.sub(_recentFeePeriodsStorage(i).rewardsClaimed);\r\n        }\r\n\r\n        return totalRewards;\r\n    }\r\n\r\n    /**\r\n     * @notice The fees available to be withdrawn by a specific account, priced in sUSD\r\n     * @dev Returns two amounts, one for fees and one for SNX rewards\r\n     */\r\n    function feesAvailable(address account) public view returns (uint, uint) {\r\n        // Add up the fees\r\n        uint[2][FEE_PERIOD_LENGTH] memory userFees = feesByPeriod(account);\r\n\r\n        uint totalFees = 0;\r\n        uint totalRewards = 0;\r\n\r\n        // Fees & Rewards in fee period [0] are not yet available for withdrawal\r\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\r\n            totalFees = totalFees.add(userFees[i][0]);\r\n            totalRewards = totalRewards.add(userFees[i][1]);\r\n        }\r\n\r\n        // And convert totalFees to sUSD\r\n        // Return totalRewards as is in SNX amount\r\n        return (totalFees, totalRewards);\r\n    }\r\n\r\n    function _isFeesClaimableAndAnyRatesInvalid(address account) internal view returns (bool, bool) {\r\n        // Threshold is calculated from ratio % above the target ratio (issuanceRatio).\r\n        //  0  <  10%:   Claimable\r\n        // 10% > above:  Unable to claim\r\n        (uint ratio, bool anyRateIsInvalid) = issuer().collateralisationRatioAndAnyRatesInvalid(account);\r\n        uint targetRatio = getIssuanceRatio();\r\n\r\n        // Claimable if collateral ratio below target ratio\r\n        if (ratio < targetRatio) {\r\n            return (true, anyRateIsInvalid);\r\n        }\r\n\r\n        // Calculate the threshold for collateral ratio before fees can't be claimed.\r\n        uint ratio_threshold = targetRatio.multiplyDecimal(SafeDecimalMath.unit().add(getTargetThreshold()));\r\n\r\n        // Not claimable if collateral ratio above threshold\r\n        if (ratio > ratio_threshold) {\r\n            return (false, anyRateIsInvalid);\r\n        }\r\n\r\n        return (true, anyRateIsInvalid);\r\n    }\r\n\r\n    function isFeesClaimable(address account) external view returns (bool feesClaimable) {\r\n        (feesClaimable, ) = _isFeesClaimableAndAnyRatesInvalid(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates fees by period for an account, priced in sUSD\r\n     * @param account The address you want to query the fees for\r\n     */\r\n    function feesByPeriod(address account) public view returns (uint[2][FEE_PERIOD_LENGTH] memory results) {\r\n        // What's the user's debt entry index and the debt they owe to the system at current feePeriod\r\n        uint userOwnershipPercentage;\r\n        uint debtEntryIndex;\r\n        FeePoolState _feePoolState = feePoolState();\r\n\r\n        (userOwnershipPercentage, debtEntryIndex) = _feePoolState.getAccountsDebtEntry(account, 0);\r\n\r\n        // If they don't have any debt ownership and they never minted, they don't have any fees.\r\n        // User ownership can reduce to 0 if user burns all synths,\r\n        // however they could have fees applicable for periods they had minted in before so we check debtEntryIndex.\r\n        if (debtEntryIndex == 0 && userOwnershipPercentage == 0) {\r\n            uint[2][FEE_PERIOD_LENGTH] memory nullResults;\r\n            return nullResults;\r\n        }\r\n\r\n        // The [0] fee period is not yet ready to claim, but it is a fee period that they can have\r\n        // fees owing for, so we need to report on it anyway.\r\n        uint feesFromPeriod;\r\n        uint rewardsFromPeriod;\r\n        (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(0, userOwnershipPercentage, debtEntryIndex);\r\n\r\n        results[0][0] = feesFromPeriod;\r\n        results[0][1] = rewardsFromPeriod;\r\n\r\n        // Retrieve user's last fee claim by periodId\r\n        uint lastFeeWithdrawal = getLastFeeWithdrawal(account);\r\n\r\n        // Go through our fee periods from the oldest feePeriod[FEE_PERIOD_LENGTH - 1] and figure out what we owe them.\r\n        // Condition checks for periods > 0\r\n        for (uint i = FEE_PERIOD_LENGTH - 1; i > 0; i--) {\r\n            uint next = i - 1;\r\n            uint nextPeriodStartingDebtIndex = _recentFeePeriodsStorage(next).startingDebtIndex;\r\n\r\n            // We can skip the period, as no debt minted during period (next period's startingDebtIndex is still 0)\r\n            if (nextPeriodStartingDebtIndex > 0 && lastFeeWithdrawal < _recentFeePeriodsStorage(i).feePeriodId) {\r\n                // We calculate a feePeriod's closingDebtIndex by looking at the next feePeriod's startingDebtIndex\r\n                // we can use the most recent issuanceData[0] for the current feePeriod\r\n                // else find the applicableIssuanceData for the feePeriod based on the StartingDebtIndex of the period\r\n                uint closingDebtIndex = uint256(nextPeriodStartingDebtIndex).sub(1);\r\n\r\n                // Gas optimisation - to reuse debtEntryIndex if found new applicable one\r\n                // if applicable is 0,0 (none found) we keep most recent one from issuanceData[0]\r\n                // return if userOwnershipPercentage = 0)\r\n                (userOwnershipPercentage, debtEntryIndex) = _feePoolState.applicableIssuanceData(account, closingDebtIndex);\r\n\r\n                (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(i, userOwnershipPercentage, debtEntryIndex);\r\n\r\n                results[i][0] = feesFromPeriod;\r\n                results[i][1] = rewardsFromPeriod;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice ownershipPercentage is a high precision decimals uint based on\r\n     * wallet's debtPercentage. Gives a precise amount of the feesToDistribute\r\n     * for fees in the period. Precision factor is removed before results are\r\n     * returned.\r\n     * @dev The reported fees owing for the current period [0] are just a\r\n     * running balance until the fee period closes\r\n     */\r\n    function _feesAndRewardsFromPeriod(\r\n        uint period,\r\n        uint ownershipPercentage,\r\n        uint debtEntryIndex\r\n    ) internal view returns (uint, uint) {\r\n        // If it's zero, they haven't issued, and they have no fees OR rewards.\r\n        if (ownershipPercentage == 0) return (0, 0);\r\n\r\n        uint debtOwnershipForPeriod = ownershipPercentage;\r\n\r\n        // If period has closed we want to calculate debtPercentage for the period\r\n        if (period > 0) {\r\n            uint closingDebtIndex = uint256(_recentFeePeriodsStorage(period - 1).startingDebtIndex).sub(1);\r\n            debtOwnershipForPeriod = _effectiveDebtRatioForPeriod(closingDebtIndex, ownershipPercentage, debtEntryIndex);\r\n        }\r\n\r\n        // Calculate their percentage of the fees / rewards in this period\r\n        // This is a high precision integer.\r\n        uint feesFromPeriod = _recentFeePeriodsStorage(period).feesToDistribute.multiplyDecimal(debtOwnershipForPeriod);\r\n\r\n        uint rewardsFromPeriod =\r\n            _recentFeePeriodsStorage(period).rewardsToDistribute.multiplyDecimal(debtOwnershipForPeriod);\r\n\r\n        return (feesFromPeriod.preciseDecimalToDecimal(), rewardsFromPeriod.preciseDecimalToDecimal());\r\n    }\r\n\r\n    function _effectiveDebtRatioForPeriod(\r\n        uint closingDebtIndex,\r\n        uint ownershipPercentage,\r\n        uint debtEntryIndex\r\n    ) internal view returns (uint) {\r\n        // Figure out their global debt percentage delta at end of fee Period.\r\n        // This is a high precision integer.\r\n        ISynthetixState _synthetixState = synthetixState();\r\n        uint feePeriodDebtOwnership =\r\n            _synthetixState\r\n                .debtLedger(closingDebtIndex)\r\n                .divideDecimalRoundPrecise(_synthetixState.debtLedger(debtEntryIndex))\r\n                .multiplyDecimalRoundPrecise(ownershipPercentage);\r\n\r\n        return feePeriodDebtOwnership;\r\n    }\r\n\r\n    function effectiveDebtRatioForPeriod(address account, uint period) external view returns (uint) {\r\n        require(period != 0, \"Current period is not closed yet\");\r\n        require(period < FEE_PERIOD_LENGTH, \"Exceeds the FEE_PERIOD_LENGTH\");\r\n\r\n        // If the period being checked is uninitialised then return 0. This is only at the start of the system.\r\n        if (_recentFeePeriodsStorage(period - 1).startingDebtIndex == 0) return 0;\r\n\r\n        uint closingDebtIndex = uint256(_recentFeePeriodsStorage(period - 1).startingDebtIndex).sub(1);\r\n\r\n        uint ownershipPercentage;\r\n        uint debtEntryIndex;\r\n        (ownershipPercentage, debtEntryIndex) = feePoolState().applicableIssuanceData(account, closingDebtIndex);\r\n\r\n        // internal function will check closingDebtIndex has corresponding debtLedger entry\r\n        return _effectiveDebtRatioForPeriod(closingDebtIndex, ownershipPercentage, debtEntryIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the feePeriodID of the last claim this account made\r\n     * @param _claimingAddress account to check the last fee period ID claim for\r\n     * @return uint of the feePeriodID this account last claimed\r\n     */\r\n    function getLastFeeWithdrawal(address _claimingAddress) public view returns (uint) {\r\n        return feePoolEternalStorage().getUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, _claimingAddress)));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the collateral ratio before user is blocked from claiming.\r\n     */\r\n    function getPenaltyThresholdRatio() public view returns (uint) {\r\n        return getIssuanceRatio().multiplyDecimal(SafeDecimalMath.unit().add(getTargetThreshold()));\r\n    }\r\n\r\n    /**\r\n     * @notice Set the feePeriodID of the last claim this account made\r\n     * @param _claimingAddress account to set the last feePeriodID claim for\r\n     * @param _feePeriodID the feePeriodID this account claimed fees for\r\n     */\r\n    function _setLastFeeWithdrawal(address _claimingAddress, uint _feePeriodID) internal {\r\n        feePoolEternalStorage().setUIntValue(\r\n            keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, _claimingAddress)),\r\n            _feePeriodID\r\n        );\r\n    }\r\n\r\n    /* ========== Modifiers ========== */\r\n    modifier onlyInternalContracts {\r\n        bool isExchanger = msg.sender == address(exchanger());\r\n        bool isSynth = issuer().synthsByAddress(msg.sender) != bytes32(0);\r\n        bool isCollateral = collateralManager().hasCollateral(msg.sender);\r\n        bool isEtherWrapper = msg.sender == address(etherWrapper());\r\n        bool isWrapper = msg.sender == address(wrapperFactory());\r\n\r\n        require(isExchanger || isSynth || isCollateral || isEtherWrapper || isWrapper, \"Only Internal Contracts\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyIssuerAndSynthetixState {\r\n        bool isIssuer = msg.sender == address(issuer());\r\n        bool isSynthetixState = msg.sender == address(synthetixState());\r\n        require(isIssuer || isSynthetixState, \"Issuer and SynthetixState only\");\r\n        _;\r\n    }\r\n\r\n    modifier notFeeAddress(address account) {\r\n        require(account != FEE_ADDRESS, \"Fee address not allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier issuanceActive() {\r\n        systemStatus().requireIssuanceActive();\r\n        _;\r\n    }\r\n\r\n    /* ========== Proxy Events ========== */\r\n\r\n    event IssuanceDebtRatioEntry(\r\n        address indexed account,\r\n        uint debtRatio,\r\n        uint debtEntryIndex,\r\n        uint feePeriodStartingDebtIndex\r\n    );\r\n    bytes32 private constant ISSUANCEDEBTRATIOENTRY_SIG =\r\n        keccak256(\"IssuanceDebtRatioEntry(address,uint256,uint256,uint256)\");\r\n\r\n    function emitIssuanceDebtRatioEntry(\r\n        address account,\r\n        uint debtRatio,\r\n        uint debtEntryIndex,\r\n        uint feePeriodStartingDebtIndex\r\n    ) internal {\r\n        proxy._emit(\r\n            abi.encode(debtRatio, debtEntryIndex, feePeriodStartingDebtIndex),\r\n            2,\r\n            ISSUANCEDEBTRATIOENTRY_SIG,\r\n            bytes32(uint256(uint160(account))),\r\n            0,\r\n            0\r\n        );\r\n    }\r\n\r\n    event FeePeriodClosed(uint feePeriodId);\r\n    bytes32 private constant FEEPERIODCLOSED_SIG = keccak256(\"FeePeriodClosed(uint256)\");\r\n\r\n    function emitFeePeriodClosed(uint feePeriodId) internal {\r\n        proxy._emit(abi.encode(feePeriodId), 1, FEEPERIODCLOSED_SIG, 0, 0, 0);\r\n    }\r\n\r\n    event FeesClaimed(address account, uint sUSDAmount, uint snxRewards);\r\n    bytes32 private constant FEESCLAIMED_SIG = keccak256(\"FeesClaimed(address,uint256,uint256)\");\r\n\r\n    function emitFeesClaimed(\r\n        address account,\r\n        uint sUSDAmount,\r\n        uint snxRewards\r\n    ) internal {\r\n        proxy._emit(abi.encode(account, sUSDAmount, snxRewards), 1, FEESCLAIMED_SIG, 0, 0, 0);\r\n    }\r\n}\r\n\r\n\r\ninterface ISynthetixNamedContract {\r\n    // solhint-disable func-name-mixedcase\r\n    function CONTRACT_NAME() external view returns (bytes32);\r\n}\r\n\r\n// solhint-disable contract-name-camelcase\r\ncontract Migration_Peacock is BaseMigration {\r\n    // https://etherscan.io/address/0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\r\n    address public constant OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\r\n\r\n    // ----------------------------\r\n    // EXISTING SYNTHETIX CONTRACTS\r\n    // ----------------------------\r\n\r\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\r\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\r\n    // https://etherscan.io/address/0xb440DD674e1243644791a4AdfE3A2AbB0A92d309\r\n    Proxy public constant proxyfeepool_i = Proxy(0xb440DD674e1243644791a4AdfE3A2AbB0A92d309);\r\n    // https://etherscan.io/address/0xC9DFff5fA5605fd94F8B7927b892F2B57391e8bB\r\n    FeePoolEternalStorage public constant feepooleternalstorage_i = FeePoolEternalStorage(0xC9DFff5fA5605fd94F8B7927b892F2B57391e8bB);\r\n    // https://etherscan.io/address/0x11164F6a47C3f8472D19b9aDd516Fc780cb7Ee02\r\n    FeePoolState public constant feepoolstate_i = FeePoolState(0x11164F6a47C3f8472D19b9aDd516Fc780cb7Ee02);\r\n    // https://etherscan.io/address/0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F\r\n    RewardEscrow public constant rewardescrow_i = RewardEscrow(0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F);\r\n    // https://etherscan.io/address/0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd\r\n    FeePool public constant feepool_i = FeePool(0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd);\r\n\r\n    // ----------------------------------\r\n    // NEW CONTRACTS DEPLOYED TO BE ADDED\r\n    // ----------------------------------\r\n\r\n    // https://etherscan.io/address/0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd\r\n        address public constant new_FeePool_contract = 0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd;\r\n\r\n    constructor() public BaseMigration(OWNER) {}\r\n\r\n    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {\r\n        contracts = new address[](6);\r\n        contracts[0]= address(addressresolver_i);\r\n        contracts[1]= address(proxyfeepool_i);\r\n        contracts[2]= address(feepooleternalstorage_i);\r\n        contracts[3]= address(feepoolstate_i);\r\n        contracts[4]= address(rewardescrow_i);\r\n        contracts[5]= address(feepool_i);\r\n    }\r\n\r\n    function migrate(address currentOwner) external onlyDeployer {\r\n        require(owner == currentOwner, \"Only the assigned owner can be re-assigned when complete\");\r\n\r\n        require(ISynthetixNamedContract(new_FeePool_contract).CONTRACT_NAME() == \"FeePool\", \"Invalid contract supplied for FeePool\");\r\n\r\n        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes\r\n        acceptAll();\r\n\r\n        // MIGRATION\r\n        // Import all new contracts into the address resolver;\r\n        addressresolver_importAddresses_0();\r\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;\r\n        addressresolver_rebuildCaches_1();\r\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;\r\n        addressresolver_rebuildCaches_2();\r\n        // Ensure the ProxyFeePool contract has the correct FeePool target set;\r\n        proxyfeepool_i.setTarget(Proxyable(new_FeePool_contract));\r\n        // Ensure the FeePool contract can write to its EternalStorage;\r\n        feepooleternalstorage_i.setAssociatedContract(new_FeePool_contract);\r\n        // Ensure the FeePool contract can write to its State;\r\n        feepoolstate_i.setFeePool(IFeePool(new_FeePool_contract));\r\n        // Ensure the legacy RewardEscrow contract is connected to the FeePool contract;\r\n        rewardescrow_i.setFeePool(IFeePool(new_FeePool_contract));\r\n        // Import fee period from existing fee pool at index 0;\r\n        importFeePeriod_0();\r\n        // Import fee period from existing fee pool at index 1;\r\n        importFeePeriod_1();\r\n\r\n        // NOMINATE OWNERSHIP back to owner for aforementioned contracts\r\n        nominateAll();\r\n    }\r\n\r\n    function acceptAll() internal {\r\n        address[] memory contracts = contractsRequiringOwnership();\r\n        for (uint i = 0; i < contracts.length; i++) {\r\n            Owned(contracts[i]).acceptOwnership();\r\n        }\r\n    }\r\n\r\n    function nominateAll() internal {\r\n        address[] memory contracts = contractsRequiringOwnership();\r\n        for (uint i = 0; i < contracts.length; i++) {\r\n            returnOwnership(contracts[i]);\r\n        }\r\n    }\r\n\r\n    \r\n    function addressresolver_importAddresses_0() internal {\r\n        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);\r\n        addressresolver_importAddresses_names_0_0[0] = bytes32(\"FeePool\");\r\n        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);\r\n        addressresolver_importAddresses_destinations_0_1[0] = address(new_FeePool_contract);\r\n        addressresolver_i.importAddresses(addressresolver_importAddresses_names_0_0, addressresolver_importAddresses_destinations_0_1);\r\n    }\r\n\r\n    \r\n    function addressresolver_rebuildCaches_1() internal {\r\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20);\r\n        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(0xDA4eF8520b1A57D7d63f1E249606D1A459698876);\r\n        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(0x2A417C61B8062363e4ff50900779463b45d235f6);\r\n        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(0xC2F1F551bfAd1E9A3b4816513bFd41d77f40F915);\r\n        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(0x02f9bC46beD33acdB9cb002fe346734CeF8a9480);\r\n        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA);\r\n        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0);\r\n        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A);\r\n        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827);\r\n        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(0xde3892383965FBa6eC434bE6350F85f140098708);\r\n        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D);\r\n        addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(0xe2f532c389deb5E42DCe53e78A9762949A885455);\r\n        addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353);\r\n        addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(0xc70B42930BD8D30A79B55415deC3be60827559f7);\r\n        addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(0x3FFE35c3d412150C3B91d3E22eBA60E16030C608);\r\n        addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(0x8f9fa817200F5B95f9572c8Acf2b31410C00335a);\r\n        addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(0x0705F0716b12a703d4F8832Ec7b97C61771f0361);\r\n        addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(0xfA60918C4417b64E722ca15d79C751c1f24Ab995);\r\n        addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(0xcc3aab773e2171b2E257Ee17001400eE378aa52B);\r\n        addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(0xe59dFC746D566EB40F92ed0B162004e24E3AC932);\r\n        addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(0xC1AAE9d18bBe386B102435a8632C8063d31e747C);\r\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);\r\n    }\r\n\r\n    \r\n    function addressresolver_rebuildCaches_2() internal {\r\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](4);\r\n        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(0x5c8344bcdC38F1aB5EB5C1d4a35DdEeA522B5DfA);\r\n        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(0xaa03aB31b55DceEeF845C8d17890CC61cD98eD04);\r\n        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(0x1F2c3a1046c32729862fcB038369696e3273a516);\r\n        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(new_FeePool_contract);\r\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);\r\n    }\r\n\r\n    \r\n    function importFeePeriod_0() internal {\r\n        // https://etherscan.io/address/0xc398406FFfBEd5B0680e706634490062CB1DB579;\r\n        FeePool existingFeePool = FeePool(0xc398406FFfBEd5B0680e706634490062CB1DB579);\r\n        // https://etherscan.io/address/0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd;\r\n        FeePool newFeePool = FeePool(0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd);\r\n        (\r\n                        uint64 feePeriodId_0,\r\n                        uint64 startingDebtIndex_0,\r\n                        uint64 startTime_0,\r\n                        uint feesToDistribute_0,\r\n                        uint feesClaimed_0,\r\n                        uint rewardsToDistribute_0,\r\n                        uint rewardsClaimed_0\r\n                    ) = existingFeePool.recentFeePeriods(0);\r\n        newFeePool.importFeePeriod(\r\n                        0,\r\n                        feePeriodId_0,\r\n                        startingDebtIndex_0,\r\n                        startTime_0,\r\n                        feesToDistribute_0,\r\n                        feesClaimed_0,\r\n                        rewardsToDistribute_0,\r\n                        rewardsClaimed_0\r\n                    );\r\n    }\r\n\r\n    \r\n    function importFeePeriod_1() internal {\r\n        // https://etherscan.io/address/0xc398406FFfBEd5B0680e706634490062CB1DB579;\r\n        FeePool existingFeePool = FeePool(0xc398406FFfBEd5B0680e706634490062CB1DB579);\r\n        // https://etherscan.io/address/0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd;\r\n        FeePool newFeePool = FeePool(0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd);\r\n        (\r\n                        uint64 feePeriodId_1,\r\n                        uint64 startingDebtIndex_1,\r\n                        uint64 startTime_1,\r\n                        uint feesToDistribute_1,\r\n                        uint feesClaimed_1,\r\n                        uint rewardsToDistribute_1,\r\n                        uint rewardsClaimed_1\r\n                    ) = existingFeePool.recentFeePeriods(1);\r\n        newFeePool.importFeePeriod(\r\n                        1,\r\n                        feePeriodId_1,\r\n                        startingDebtIndex_1,\r\n                        startTime_1,\r\n                        feesToDistribute_1,\r\n                        feesClaimed_1,\r\n                        rewardsToDistribute_1,\r\n                        rewardsClaimed_1\r\n                    );\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressresolver_i\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRequiringOwnership\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepool_i\",\"outputs\":[{\"internalType\":\"contract FeePool\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepooleternalstorage_i\",\"outputs\":[{\"internalType\":\"contract FeePoolEternalStorage\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepoolstate_i\",\"outputs\":[{\"internalType\":\"contract FeePoolState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_FeePool_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyfeepool_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"forContract\",\"type\":\"address\"}],\"name\":\"returnOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardescrow_i\",\"outputs\":[{\"internalType\":\"contract RewardEscrow\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Migration_Peacock", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://458cc57e99af28387b19e75e1d22aa117c7fc203171b7c9d9c73c1057de5c1ee"}]}