{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.10;\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                  EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(\r\n                        abi.encode(\r\n                            keccak256(\r\n                                \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n                            ),\r\n                            owner,\r\n                            spender,\r\n                            value,\r\n                            nonces[owner]++,\r\n                            deadline\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                       INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\r\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\r\nabstract contract Auth {\r\n    event OwnerUpdated(address indexed user, address indexed newOwner);\r\n\r\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\r\n\r\n    address public owner;\r\n\r\n    Authority public authority;\r\n\r\n    constructor(address _owner, Authority _authority) {\r\n        owner = _owner;\r\n        authority = _authority;\r\n\r\n        emit OwnerUpdated(msg.sender, _owner);\r\n        emit AuthorityUpdated(msg.sender, _authority);\r\n    }\r\n\r\n    modifier requiresAuth() {\r\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\r\n\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\r\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\r\n\r\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\r\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\r\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\r\n    }\r\n\r\n    function setAuthority(Authority newAuthority) public virtual {\r\n        // We check if the caller is the owner first because we want to ensure they can\r\n        // always swap out the authority even if it's reverting or using up a lot of gas.\r\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\r\n\r\n        authority = newAuthority;\r\n\r\n        emit AuthorityUpdated(msg.sender, newAuthority);\r\n    }\r\n\r\n    function setOwner(address newOwner) public virtual requiresAuth {\r\n        owner = newOwner;\r\n\r\n        emit OwnerUpdated(msg.sender, newOwner);\r\n    }\r\n}\r\n\r\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\r\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\r\ninterface Authority {\r\n    function canCall(\r\n        address user,\r\n        address target,\r\n        bytes4 functionSig\r\n    ) external view returns (bool);\r\n}\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\r\nlibrary SafeTransferLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                           ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 100 because the calldata length is 4 + 32 * 3.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                         INTERNAL HELPER LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\r\n        assembly {\r\n            // Get how many bytes the call returned.\r\n            let returnDataSize := returndatasize()\r\n\r\n            // If the call reverted:\r\n            if iszero(callStatus) {\r\n                // Copy the revert message into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Revert with the same message.\r\n                revert(0, returnDataSize)\r\n            }\r\n\r\n            switch returnDataSize\r\n            case 32 {\r\n                // Copy the return data into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Set success to whether it returned true.\r\n                success := iszero(iszero(mload(0)))\r\n            }\r\n            case 0 {\r\n                // There was no return data.\r\n                success := 1\r\n            }\r\n            default {\r\n                // It returned some malformed output.\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n @title Rewards Module for Flywheel\r\n @notice The rewards module is a minimal interface for determining the quantity of rewards accrued to a flywheel market.\r\n\r\n Different module strategies include:\r\n  * a static reward rate per second\r\n  * a decaying reward rate\r\n  * a dynamic just-in-time reward stream\r\n  * liquid governance reward delegation\r\n */\r\ninterface IFlywheelRewards {\r\n    function getAccruedRewards(ERC20 market, uint32 lastUpdatedTimestamp) external returns (uint256 rewards);\r\n}\r\n/**\r\n @title Balance Booster Module for Flywheel\r\n @notice An optional module for virtually boosting user balances. This allows a Flywheel Core to plug into some balance boosting logic.\r\n\r\n Boosting logic can be associated with referrals, vote-escrow, or other strategies. It can even be used to model exotic strategies like borrowing.\r\n */\r\ninterface IFlywheelBooster {\r\n    function boostedTotalSupply(ERC20 market) external view returns(uint256);\r\n\r\n    function boostedBalanceOf(ERC20 market, address user) external view returns(uint256);\r\n}\r\n\r\n/**\r\n @title Flywheel Core Incentives Manager\r\n @notice Flywheel is a general framework for managing token incentives.\r\n         It is comprised of the Core (this contract), Rewards module, and optional Booster module.\r\n\r\n         Core is responsible for maintaining reward accrual through reward indexes. \r\n         It delegates the actual accrual logic to the Rewards Module.\r\n\r\n         For maximum accuracy and to avoid exploits, rewards accrual should be notified atomically through the accrue hook. \r\n         Accrue should be called any time tokens are transferred, minted, or burned.\r\n */\r\ncontract FlywheelCore is Auth {\r\n    using SafeTransferLib for ERC20;\r\n\r\n    event AddMarket(address indexed newMarket);\r\n\r\n    event FlywheelRewardsUpdate(address indexed oldFlywheelRewards, address indexed newFlywheelRewards);\r\n\r\n    event AccrueRewards(ERC20 indexed cToken, address indexed owner, uint rewardsDelta, uint rewardsIndex);\r\n    \r\n    event ClaimRewards(address indexed owner, uint256 amount);\r\n\r\n    struct RewardsState {\r\n        /// @notice The market's last updated index\r\n        uint224 index;\r\n\r\n        /// @notice The timestamp the index was last updated at\r\n        uint32 lastUpdatedTimestamp;\r\n    }\r\n\r\n    /// @notice The token to reward\r\n    ERC20 public immutable rewardToken;\r\n\r\n    /// @notice the rewards contract for managing streams\r\n    IFlywheelRewards public flywheelRewards;\r\n\r\n    /// @notice optional booster module for calculating virtual balances on markets\r\n    IFlywheelBooster public immutable flywheelBooster;\r\n\r\n    /// @notice the fixed point factor of flywheel\r\n    uint224 public constant ONE = 1e18;\r\n\r\n    /// @notice The market index and last updated per market\r\n    mapping(ERC20 => RewardsState) public marketState;\r\n\r\n    /// @notice user index per market\r\n    mapping(ERC20 => mapping(address => uint224)) public userIndex;\r\n\r\n    /// @notice The accrued but not yet transferred rewards for each user\r\n    mapping(address => uint256) public rewardsAccrued;\r\n\r\n    /// @dev immutable flag for short-circuiting boosting logic\r\n    bool internal immutable applyBoosting;\r\n\r\n    constructor(\r\n        ERC20 _rewardToken, \r\n        IFlywheelRewards _flywheelRewards, \r\n        IFlywheelBooster _flywheelBooster,\r\n        address _owner,\r\n        Authority _authority\r\n    ) Auth(_owner, _authority) {\r\n        rewardToken = _rewardToken;\r\n        flywheelRewards = _flywheelRewards;\r\n        flywheelBooster = _flywheelBooster;\r\n\r\n        applyBoosting = address(_flywheelBooster) != address(0);\r\n    }\r\n\r\n    /// @notice initialize a new market\r\n    function addMarketForRewards(ERC20 market) external requiresAuth {\r\n        require(marketState[market].index == 0, \"market\");\r\n        marketState[market] = RewardsState({\r\n            index: ONE,\r\n            lastUpdatedTimestamp: uint32(block.timestamp)\r\n        });\r\n\r\n        emit AddMarket(address(market));\r\n    }\r\n\r\n    /// @notice swap out the flywheel rewards contract\r\n    function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {\r\n        address oldFlywheelRewards = address(flywheelRewards);\r\n\r\n        flywheelRewards = newFlywheelRewards;\r\n\r\n        emit FlywheelRewardsUpdate(oldFlywheelRewards, address(newFlywheelRewards));\r\n    }\r\n\r\n    /// @notice accrue rewards for a single user on a market\r\n    function accrue(ERC20 market, address user) public returns (uint256) {\r\n        RewardsState memory state = marketState[market];\r\n\r\n        if (state.index == 0) return 0;\r\n\r\n        state = accrueMarket(market, state);\r\n        return accrueUser(market, user, state);\r\n    }\r\n\r\n    /// @notice accrue rewards for two users on a market\r\n    function accrue(ERC20 market, address user, address secondUser) public returns (uint256, uint256) {\r\n        RewardsState memory state = marketState[market];\r\n\r\n        if (state.index == 0) return (0, 0);\r\n\r\n        state = accrueMarket(market, state);\r\n        return (accrueUser(market, user, state), accrueUser(market, secondUser, state));\r\n    }\r\n\r\n    /// @notice claim rewards for a given owner\r\n    function claimRewards(address owner) external {\r\n        uint256 accrued = rewardsAccrued[owner];\r\n\r\n        if (accrued != 0) {\r\n            rewardsAccrued[owner] = 0;\r\n\r\n            rewardToken.transfer(owner, accrued); \r\n\r\n            emit ClaimRewards(owner, accrued);\r\n        }\r\n    }\r\n\r\n    /// @notice accumulate global rewards on a market\r\n    function accrueMarket(ERC20 market, RewardsState memory state) private returns(RewardsState memory rewardsState) {\r\n        // calculate accrued rewards through module\r\n        uint256 marketRewardsAccrued = flywheelRewards.getAccruedRewards(market, state.lastUpdatedTimestamp);\r\n\r\n        rewardsState = state;\r\n        if (marketRewardsAccrued > 0) {\r\n            // use the booster or token supply to calculate reward index denominator\r\n            uint256 supplyTokens = applyBoosting ? flywheelBooster.boostedTotalSupply(market): market.totalSupply();\r\n\r\n            // accumulate rewards per token onto the index, multiplied by fixed-point factor\r\n            rewardsState = RewardsState({\r\n                index: state.index + uint224(marketRewardsAccrued * ONE / supplyTokens),\r\n                lastUpdatedTimestamp: uint32(block.timestamp)\r\n            });\r\n            marketState[market] = rewardsState;\r\n        }\r\n    }\r\n\r\n    /// @notice accumulate rewards on a market for a specific user\r\n    function accrueUser(ERC20 market, address user, RewardsState memory state) private returns (uint256) {\r\n        // load indices\r\n        uint224 supplyIndex = state.index;\r\n        uint224 supplierIndex = userIndex[market][user];\r\n\r\n        // sync user index to global\r\n        userIndex[market][user] = supplyIndex;\r\n\r\n        // if user hasn't yet accrued rewards, grant them interest from the market beginning if they have a balance\r\n        // zero balances will have no effect other than syncing to global index\r\n        if (supplierIndex == 0) {\r\n            supplierIndex = ONE;\r\n        }\r\n\r\n        uint224 deltaIndex = supplyIndex - supplierIndex;\r\n        // use the booster or token balance to calculate reward balance multiplier\r\n        uint256 supplierTokens = applyBoosting ? flywheelBooster.boostedBalanceOf(market, user) : market.balanceOf(user);\r\n\r\n        // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\r\n        uint256 supplierDelta = supplierTokens * deltaIndex / ONE;\r\n        uint256 supplierAccrued = rewardsAccrued[user] + supplierDelta;\r\n        \r\n        rewardsAccrued[user] = supplierAccrued;\r\n\r\n        emit AccrueRewards(market, user, supplierDelta, supplyIndex);\r\n\r\n        return supplierAccrued;\r\n    }\r\n}\r\n\r\ncontract FuseFlywheelCore is FlywheelCore {\r\n\r\n    bool public constant isRewardsDistributor = true;\r\n\r\n    bool public constant isFlywheel = true;\r\n\r\n    constructor(\r\n        ERC20 _rewardToken, \r\n        IFlywheelRewards _flywheelRewards, \r\n        IFlywheelBooster _flywheelBooster,\r\n        address _owner,\r\n        Authority _authority\r\n    ) FlywheelCore(_rewardToken, _flywheelRewards, _flywheelBooster, _owner, _authority) {}\r\n\r\n    function flywheelPreSupplierAction(ERC20 market, address supplier) external {\r\n        accrue(market, supplier);  \r\n    }\r\n\r\n    function flywheelPreBorrowerAction(ERC20 market, address borrower) external {}\r\n\r\n    function flywheelPreTransferAction(ERC20 market, address src, address dst) external {\r\n        accrue(market, src, dst);\r\n    }\r\n\r\n    function compAccrued(address user) external view returns(uint256) {\r\n        return rewardsAccrued[user];\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"contract IFlywheelRewards\",\"name\":\"_flywheelRewards\",\"type\":\"address\"},{\"internalType\":\"contract IFlywheelBooster\",\"name\":\"_flywheelBooster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract Authority\",\"name\":\"_authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ERC20\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardsDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardsIndex\",\"type\":\"uint256\"}],\"name\":\"AccrueRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMarket\",\"type\":\"address\"}],\"name\":\"AddMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldFlywheelRewards\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFlywheelRewards\",\"type\":\"address\"}],\"name\":\"FlywheelRewardsUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"\",\"type\":\"uint224\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"accrue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondUser\",\"type\":\"address\"}],\"name\":\"accrue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"addMarketForRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"compAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flywheelBooster\",\"outputs\":[{\"internalType\":\"contract IFlywheelBooster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"flywheelPreBorrowerAction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"}],\"name\":\"flywheelPreSupplierAction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"flywheelPreTransferAction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flywheelRewards\",\"outputs\":[{\"internalType\":\"contract IFlywheelRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFlywheel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRewardsDistributor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketState\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"index\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdatedTimestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardsAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFlywheelRewards\",\"name\":\"newFlywheelRewards\",\"type\":\"address\"}],\"name\":\"setFlywheelRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userIndex\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"\",\"type\":\"uint224\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FuseFlywheelCore", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004e3fbd56cd56c3e72c1403e103b45db9da5b9d2b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b290f2f3fad4e540d0550985951cdad2711ac34a0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4a3be05b9ee4eb86b19ce3784c335b4bd0353ba8ec2e7d4425664c4fd4caf8c9"}]}