{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/libraries/logic/eligibility/NFTXAllowAllEligibility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {NFTXEligibility} from \\\"./NFTXEligibility.sol\\\";\\n\\ncontract NFTXAllowAllEligibility is NFTXEligibility {\\n\\n    uint256 public constant ALLOW_ALL_ELIGIBILITY_REVISION = 0x1;\\n\\n    function getRevision() internal pure override virtual returns (uint256) {\\n        return ALLOW_ALL_ELIGIBILITY_REVISION;\\n    }\\n\\n    function name() public pure override virtual returns (string memory) {    \\n        return \\\"AllowAll\\\";\\n    }\\n\\n    function finalized() public view override virtual returns (bool) {    \\n        return true;\\n    }\\n\\n    function targetAsset() public pure override virtual returns (address) {\\n        return address(0);\\n    }\\n\\n    event NFTXEligibilityInit();\\n\\n    function __NFTXEligibility_init_bytes(\\n        bytes memory configData\\n    ) public override virtual initializer {\\n        __NFTXEligibility_init();\\n    }\\n\\n    // Parameters here should mirror the config struct. \\n    function __NFTXEligibility_init(\\n    ) public initializer {\\n        emit NFTXEligibilityInit();\\n    }\\n\\n    function _checkIfEligible(\\n        uint256 _tokenId\\n    ) internal view override virtual returns (bool) {\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/logic/eligibility/NFTXEligibility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {VersionedInitializable} from \\\"../../aave-upgradeability/VersionedInitializable.sol\\\";\\nimport {INFTXEligibility} from \\\"../../../../interfaces/INFTXEligibility.sol\\\";\\n\\n// This is a contract meant to be inherited and overriden to implement eligibility modules. \\nabstract contract NFTXEligibility is INFTXEligibility, VersionedInitializable {\\n\\n  function name() public pure override virtual returns (string memory);\\n  function finalized() public view override virtual returns (bool);\\n  function targetAsset() public pure override virtual returns (address);\\n  \\n  function __NFTXEligibility_init_bytes(bytes memory initData) public override virtual;\\n\\n  function checkIsEligible(uint256 tokenId) external view override virtual returns (bool) {\\n      return _checkIfEligible(tokenId);\\n  }\\n\\n  function checkEligible(uint256[] calldata tokenIds) external override virtual view returns (bool[] memory) {\\n      bool[] memory eligibile = new bool[](tokenIds.length);\\n      for (uint256 i = 0; i < tokenIds.length; i++) {\\n          eligibile[i] = _checkIfEligible(tokenIds[i]);\\n      }\\n      return eligibile;\\n  }\\n\\n  function checkAllEligible(uint256[] calldata tokenIds) external override virtual view returns (bool) {\\n      for (uint256 i = 0; i < tokenIds.length; i++) {\\n          // If any are not eligible, end the loop and return false.\\n          if (!_checkIfEligible(tokenIds[i])) {\\n              return false;\\n          }\\n      }\\n      return true;\\n  }\\n\\n  // Checks if all provided NFTs are NOT eligible. This is needed for mint requesting where all NFTs \\n  // provided must be ineligible.\\n  function checkAllIneligible(uint256[] calldata tokenIds) external override virtual view returns (bool) {\\n      for (uint256 i = 0; i < tokenIds.length; i++) {\\n          // If any are eligible, end the loop and return false.\\n          if (_checkIfEligible(tokenIds[i])) {\\n              return false;\\n          }\\n      }\\n      return true;\\n  }\\n\\n  function beforeMintHook(uint256[] calldata tokenIds) external override virtual {}\\n  function afterMintHook(uint256[] calldata tokenIds) external override virtual {}\\n  function beforeRedeemHook(uint256[] calldata tokenIds) external override virtual {}\\n  function afterRedeemHook(uint256[] calldata tokenIds) external override virtual {}\\n  function afterLiquidationHook(uint256[] calldata tokenIds, uint256[] calldata amounts) external override virtual {}\\n\\n  // Override this to implement your module!\\n  function _checkIfEligible(uint256 _tokenId) internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.11;\\n\\n/**\\n * @title VersionedInitializable\\n *\\n * @dev Helper contract to implement initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n *\\n * @author Aave, inspired by the OpenZeppelin Initializable contract\\n */\\nabstract contract VersionedInitializable {\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  uint256 private lastInitializedRevision = 0;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    uint256 revision = getRevision();\\n    require(\\n      initializing || isConstructor() || revision > lastInitializedRevision,\\n      'Contract instance has already been initialized'\\n    );\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      lastInitializedRevision = revision;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /**\\n   * @dev returns the revision number of the contract\\n   * Needs to be defined in the inherited class as a constant.\\n   **/\\n  function getRevision() internal pure virtual returns (uint256);\\n\\n  /**\\n   * @dev Returns true if and only if the function is running in the constructor\\n   **/\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    uint256 cs;\\n    //solium-disable-next-line\\n    assembly {\\n      cs := extcodesize(address())\\n    }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INFTXEligibility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface INFTXEligibility {\\n    // Read functions.\\n    function name() external pure returns (string memory);\\n    function finalized() external view returns (bool);\\n    function targetAsset() external pure returns (address);\\n    function checkAllEligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n    function checkEligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool[] memory);\\n    function checkAllIneligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n    function checkIsEligible(uint256 tokenId) external view returns (bool);\\n\\n    // Write functions.\\n    function __NFTXEligibility_init_bytes(bytes calldata configData) external;\\n    function beforeMintHook(uint256[] calldata tokenIds) external;\\n    function afterMintHook(uint256[] calldata tokenIds) external;\\n    function beforeRedeemHook(uint256[] calldata tokenIds) external;\\n    function afterRedeemHook(uint256[] calldata tokenIds) external;\\n    function afterLiquidationHook(uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[],\"name\":\"NFTXEligibilityInit\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ALLOW_ALL_ELIGIBILITY_REVISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__NFTXEligibility_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"configData\",\"type\":\"bytes\"}],\"name\":\"__NFTXEligibility_init_bytes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"afterLiquidationHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"afterMintHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"afterRedeemHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"beforeMintHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"beforeRedeemHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"checkAllEligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"checkAllIneligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"checkEligible\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"checkIsEligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "NFTXAllowAllEligibility", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}