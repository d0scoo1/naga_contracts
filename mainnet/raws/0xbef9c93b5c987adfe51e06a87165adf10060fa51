{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AirWild2Sale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.3;\\r\\n\\r\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport {\\r\\n  Initializable\\r\\n} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {\\r\\n  OwnableUpgradeable\\r\\n} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\r\\nimport {IRegistrar} from \\\"./interfaces/IRegistrar.sol\\\";\\r\\nimport {\\r\\n  MerkleProofUpgradeable\\r\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\\\";\\r\\n\\r\\ncontract AirWild2Sale is Initializable, OwnableUpgradeable {\\r\\n  // zNS Registrar\\r\\n  IRegistrar public zNSRegistrar;\\r\\n\\r\\n  event RefundedEther(address buyer, uint256 amount);\\r\\n\\r\\n  event SaleStarted(uint256 block);\\r\\n\\r\\n  // The parent domain to mint sold domains under\\r\\n  uint256 public parentDomainId;\\r\\n\\r\\n  // Price of each domain to be sold\\r\\n  uint256 public salePrice;\\r\\n\\r\\n  // The wallet to transfer proceeds to\\r\\n  address public sellerWallet;\\r\\n\\r\\n  // Total number of domains to be sold\\r\\n  uint256 public totalForSale;\\r\\n\\r\\n  // Number of domains sold so far\\r\\n  uint256 public domainsSold;\\r\\n\\r\\n  // Indicating whether the sale has started or not\\r\\n  bool public saleStarted;\\r\\n\\r\\n  // The block number that a sale started on\\r\\n  uint256 public saleStartBlock;\\r\\n\\r\\n  // If a sale has been paused\\r\\n  bool public paused;\\r\\n\\r\\n  // The number with which to start the metadata index (e.g. number is 100, so indicies are 100, 101, ...)\\r\\n  uint256 public startingMetadataIndex;\\r\\n\\r\\n  // The containing folder hash without a Qm prefix\\r\\n  string public baseFolderHash;\\r\\n\\r\\n  // Merkle root data to verify on mintlist\\r\\n  bytes32[] public mintlistMerkleRoots;\\r\\n\\r\\n  // Time in blocks that each mintlist will last (in order)\\r\\n  uint256[] public mintlistDurations;\\r\\n\\r\\n  // There are multiple mintlists in this sale. Which one are we using now?\\r\\n  uint256 public currentMerkleRootIndex;\\r\\n\\r\\n  // Mapping to keep track of how many domains an account has purchased so far\\r\\n  mapping(address => uint256) public domainsPurchasedByAccount;\\r\\n\\r\\n  function __AirWild2Sale_init(\\r\\n    uint256 parentDomainId_,\\r\\n    uint256 price_,\\r\\n    IRegistrar zNSRegistrar_,\\r\\n    address sellerWallet_,\\r\\n    uint256[] memory mintlistDurations_,\\r\\n    bytes32[] memory merkleRoots_,\\r\\n    uint256 startingMetadataIndex_,\\r\\n    string calldata baseFolderHash_, // in the following format: ipfs://Qm.../\\r\\n    uint256 numForSale_\\r\\n  ) public initializer {\\r\\n    __Ownable_init();\\r\\n\\r\\n    require(mintlistDurations_.length == merkleRoots_.length, \\\"Mintlist and merkle mismatch\\\");\\r\\n\\r\\n    parentDomainId = parentDomainId_;\\r\\n    salePrice = price_;\\r\\n    zNSRegistrar = zNSRegistrar_;\\r\\n    sellerWallet = sellerWallet_;\\r\\n    mintlistDurations = mintlistDurations_;\\r\\n    mintlistMerkleRoots = merkleRoots_;\\r\\n    startingMetadataIndex = startingMetadataIndex_;\\r\\n    baseFolderHash = baseFolderHash_;\\r\\n    totalForSale = numForSale_;\\r\\n  }\\r\\n\\r\\n  function setRegistrar(IRegistrar zNSRegistrar_) external onlyOwner {\\r\\n    require(zNSRegistrar != zNSRegistrar_, \\\"Same registrar\\\");\\r\\n    require(address(zNSRegistrar_) != address(0), \\\"Registrar not initialized\\\");\\r\\n    zNSRegistrar = zNSRegistrar_;\\r\\n  }\\r\\n\\r\\n  // Start the sale if not started\\r\\n  function startSale() external onlyOwner {\\r\\n    require(!saleStarted, \\\"Sale already started\\\");\\r\\n    saleStarted = true;\\r\\n    saleStartBlock = block.number;\\r\\n    emit SaleStarted(saleStartBlock);\\r\\n  }\\r\\n\\r\\n  // Stop the sale if started\\r\\n  function stopSale() external onlyOwner {\\r\\n    require(saleStarted, \\\"Sale not started\\\");\\r\\n    saleStarted = false;\\r\\n  }\\r\\n\\r\\n  // Update the merkle list roots\\r\\n  function setMerkleRules(bytes32[] memory mintlistMerkleRoots_, uint256[] memory mintlistDurations_) external onlyOwner {\\r\\n    require(mintlistMerkleRoots_.length == mintlistDurations_.length, \\\"List length mismatch\\\");\\r\\n    require(mintlistMerkleRoots_.length > 0, \\\"Empty roots array\\\");\\r\\n    // Assume lists are equivalent...\\r\\n    bool listsAreEquivalent = mintlistMerkleRoots.length == mintlistMerkleRoots_.length;\\r\\n    if(listsAreEquivalent){\\r\\n      for(uint256 i = 0; i < mintlistMerkleRoots_.length; i++){\\r\\n        // ...until proven otherwise\\r\\n        if(mintlistMerkleRoots[i] != mintlistMerkleRoots_[i] || mintlistDurations_[i] != mintlistDurations[i]){\\r\\n          listsAreEquivalent = false;\\r\\n          break;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    require(!listsAreEquivalent, \\\"No state change\\\");\\r\\n    mintlistDurations = mintlistDurations_;\\r\\n    mintlistMerkleRoots = mintlistMerkleRoots_;\\r\\n  }\\r\\n\\r\\n  function setMerkleRootIndex(uint8 newIndex_) external onlyOwner {\\r\\n    require(currentMerkleRootIndex!=newIndex_, \\\"Same index\\\");\\r\\n    require(mintlistMerkleRoots[newIndex_] != bytes32(0), \\\"No mintlist stored at that index\\\");\\r\\n    // Consider this the start of a new sale\\r\\n    saleStartBlock = block.number;\\r\\n    currentMerkleRootIndex = newIndex_;\\r\\n  }\\r\\n\\r\\n  // Pause a sale\\r\\n  function setPauseStatus(bool pauseStatus) external onlyOwner {\\r\\n    require(paused != pauseStatus, \\\"No state change\\\");\\r\\n    paused = pauseStatus;\\r\\n  }\\r\\n\\r\\n  // Set the price of this sale\\r\\n  function setSalePrice(uint256 price) external onlyOwner {\\r\\n    require(salePrice != price, \\\"No price change\\\");\\r\\n    salePrice = price;\\r\\n  }\\r\\n\\r\\n  // Modify the address of the seller wallet\\r\\n  function setSellerWallet(address wallet) external onlyOwner {\\r\\n    require(wallet != sellerWallet, \\\"Same Wallet\\\");\\r\\n    sellerWallet = wallet;\\r\\n  }\\r\\n\\r\\n  // Modify parent domain ID of a domain\\r\\n  function setParentDomainId(uint256 parentId) external onlyOwner {\\r\\n    require(parentDomainId != parentId, \\\"Same parent id\\\");\\r\\n    parentDomainId = parentId;\\r\\n  }\\r\\n\\r\\n  // Update the number of blocks that each mintlist will last\\r\\n  function setMintlistDuration(uint256 index, uint256 durationInBlocks) external onlyOwner {\\r\\n    require(mintlistDurations.length > index, \\\"Index out of bounds\\\");\\r\\n    require(mintlistDurations[index] != durationInBlocks, \\\"No state change\\\");\\r\\n    mintlistDurations[index] = durationInBlocks;\\r\\n  }\\r\\n\\r\\n  // Set the number with which to start the metadata index (e.g. number is 100, so indicies are 100, 101, ...)\\r\\n  function setStartIndex(uint256 index) external onlyOwner {\\r\\n    require(index != startingMetadataIndex, \\\"Cannot set to the same index\\\");\\r\\n    startingMetadataIndex = index;\\r\\n  }\\r\\n\\r\\n  // Set the hash of the base IPFS folder that contains the domain metadata\\r\\n  function setBaseFolderHash(string calldata folderHash)\\r\\n    external\\r\\n    onlyOwner\\r\\n  {\\r\\n    require(\\r\\n      keccak256(bytes(folderHash)) !=\\r\\n        keccak256(bytes(baseFolderHash)),\\r\\n      \\\"Cannot set to same folder uri\\\"\\r\\n    );\\r\\n    baseFolderHash = folderHash;\\r\\n  }\\r\\n\\r\\n  // Add new metadata URIs to be sold\\r\\n  function setAmountOfDomainsForSale(uint256 forSale) public onlyOwner {\\r\\n    totalForSale = forSale;\\r\\n  }\\r\\n\\r\\n  // Remove a domain from this sale\\r\\n  function releaseDomain() external onlyOwner {\\r\\n    zNSRegistrar.transferFrom(address(this), owner(), parentDomainId);\\r\\n  }\\r\\n\\r\\n  // Purchase `count` domains\\r\\n  // Not the `purchaseLimit` you provide must be\\r\\n  // less than or equal to what is in the mintlist\\r\\n  function purchaseDomains(\\r\\n    uint8 count,\\r\\n    uint256 index,\\r\\n    uint256 purchaseLimit,\\r\\n    bytes32[] calldata merkleProof\\r\\n  ) public payable {\\r\\n    _canAccountPurchase(msg.sender, count, purchaseLimit);\\r\\n    _requireVariableMerkleProof(index, purchaseLimit, merkleProof);\\r\\n    _purchaseDomains(count);\\r\\n  }\\r\\n\\r\\n  function getNftByIndex(uint256 index) public view returns (string memory) {\\r\\n    return\\r\\n      string(\\r\\n        abi.encodePacked(\\r\\n          baseFolderHash, \\r\\n          Strings.toString(startingMetadataIndex + index)\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n\\r\\n  function _canAccountPurchase(\\r\\n    address account,\\r\\n    uint8 count,\\r\\n    uint256 purchaseLimit\\r\\n  ) internal view {\\r\\n    require(count > 0, \\\"Zero purchase count\\\");\\r\\n    require(domainsSold < totalForSale, \\\"No domains left for sale\\\");\\r\\n    require(\\r\\n      domainsPurchasedByAccount[account] + count <= purchaseLimit,\\r\\n      \\\"Purchasing beyond limit.\\\"\\r\\n    );\\r\\n    require(msg.value >= salePrice * count, \\\"Not enough funds in purchase\\\");\\r\\n    require(!paused, \\\"paused\\\");\\r\\n    require(saleStarted, \\\"Sale hasn't started or has ended\\\");\\r\\n    require(\\r\\n      block.number <= saleStartBlock + mintlistDurations[currentMerkleRootIndex],\\r\\n      \\\"Sale has ended\\\"\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function _purchaseDomains(uint8 count) internal {\\r\\n    uint256 numPurchased = _reserveDomainsForPurchase(count);\\r\\n    uint256 proceeds = salePrice * numPurchased;\\r\\n    _sendPayment(proceeds);\\r\\n    _mintDomains(numPurchased);\\r\\n  }\\r\\n\\r\\n  function _reserveDomainsForPurchase(uint8 count) internal returns (uint256) {\\r\\n    uint256 numPurchased = count;\\r\\n    // If we would are trying to purchase more than is available, purchase the remainder\\r\\n    if (domainsSold + count > totalForSale) {\\r\\n      numPurchased = totalForSale - domainsSold;\\r\\n    }\\r\\n    domainsSold += numPurchased;\\r\\n\\r\\n    // Update number of domains this account has purchased\\r\\n    // This is done before minting domains or sending any eth to prevent\\r\\n    // a re-entrance attack through a recieve() or a safe transfer callback\\r\\n    domainsPurchasedByAccount[msg.sender] =\\r\\n      domainsPurchasedByAccount[msg.sender] +\\r\\n      numPurchased;\\r\\n\\r\\n    return numPurchased;\\r\\n  }\\r\\n\\r\\n  // Transfer funds to the buying user, refunding if necessary\\r\\n  function _sendPayment(uint256 proceeds) internal {\\r\\n    payable(sellerWallet).transfer(proceeds);\\r\\n\\r\\n    // Send refund if neceesary for any unpurchased domains\\r\\n    if (msg.value - proceeds > 0) {\\r\\n      payable(msg.sender).transfer(msg.value - proceeds);\\r\\n      emit RefundedEther(msg.sender, msg.value - proceeds);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _mintDomains(uint256 numPurchased) internal {\\r\\n    // Mint the domains after they have been purchased\\r\\n    for (uint256 i = 0; i < numPurchased; ++i) {\\r\\n      // The sale contract will be the minter and own them at this point\\r\\n      zNSRegistrar.registerDomainAndSend(\\r\\n        parentDomainId,\\r\\n        Strings.toString(startingMetadataIndex + domainsSold - numPurchased + i), \\r\\n        sellerWallet,\\r\\n        getNftByIndex(startingMetadataIndex + domainsSold - numPurchased + i),\\r\\n        0,\\r\\n        true,\\r\\n        msg.sender\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _requireVariableMerkleProof(\\r\\n    uint256 index,\\r\\n    uint256 quantity,\\r\\n    bytes32[] calldata merkleProof\\r\\n  ) internal view {\\r\\n    bytes32 node = keccak256(abi.encodePacked(index, msg.sender, quantity));\\r\\n    bytes32 currentMerkleRoot = mintlistMerkleRoots[currentMerkleRootIndex];\\r\\n    require(\\r\\n      MerkleProofUpgradeable.verify(merkleProof, currentMerkleRoot, node),\\r\\n      \\\"Invalid Merkle Proof\\\"\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRegistrar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.3;\\r\\n\\r\\ninterface IRegistrar {\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external;\\r\\n\\r\\n  function registerDomainAndSend(\\r\\n    uint256 parentId,\\r\\n    string memory label,\\r\\n    address minter,\\r\\n    string memory metadataUri,\\r\\n    uint256 royaltyAmount,\\r\\n    bool locked,\\r\\n    address sendToUser\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  function registerDomainInGroupBulk(\\r\\n    uint256 parentId,\\r\\n    uint256 groupId,\\r\\n    uint256 namingOffset,\\r\\n    uint256 startingIndex,\\r\\n    uint256 endingIndex,\\r\\n    address minter,\\r\\n    uint256 royaltyAmount,\\r\\n    address sendTo\\r\\n  ) external;\\r\\n\\r\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProofUpgradeable {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 400\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundedEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"SaleStarted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"parentDomainId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"},{\"internalType\":\"contract IRegistrar\",\"name\":\"zNSRegistrar_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sellerWallet_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"mintlistDurations_\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleRoots_\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"startingMetadataIndex_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"baseFolderHash_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"numForSale_\",\"type\":\"uint256\"}],\"name\":\"__AirWild2Sale_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseFolderHash\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMerkleRootIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"domainsPurchasedByAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainsSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getNftByIndex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintlistDurations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintlistMerkleRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parentDomainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"count\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"purchaseDomains\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseDomain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forSale\",\"type\":\"uint256\"}],\"name\":\"setAmountOfDomainsForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"folderHash\",\"type\":\"string\"}],\"name\":\"setBaseFolderHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newIndex_\",\"type\":\"uint8\"}],\"name\":\"setMerkleRootIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"mintlistMerkleRoots_\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"mintlistDurations_\",\"type\":\"uint256[]\"}],\"name\":\"setMerkleRules\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"durationInBlocks\",\"type\":\"uint256\"}],\"name\":\"setMintlistDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"parentId\",\"type\":\"uint256\"}],\"name\":\"setParentDomainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"pauseStatus\",\"type\":\"bool\"}],\"name\":\"setPauseStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRegistrar\",\"name\":\"zNSRegistrar_\",\"type\":\"address\"}],\"name\":\"setRegistrar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setSalePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setSellerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"setStartIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingMetadataIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalForSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zNSRegistrar\",\"outputs\":[{\"internalType\":\"contract IRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AirWild2Sale", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "400", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}