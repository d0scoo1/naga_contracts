{"status": "1", "message": "OK", "result": [{"SourceCode": "// Open0x ECDSA \r\nlibrary ECDSA {\r\n\r\n    ///// Signer Address Recovery /////\r\n    \r\n    // In its pure form, address recovery requires the following parameters\r\n    // params: hash, v, r ,s\r\n\r\n    // First, we define some standard checks\r\n    function checkValidityOf_s(bytes32 s) public pure returns (bool) {\r\n        if (uint256(s) > \r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            revert(\"recoverAddressFrom_hash_v_r_s: Invalid s value\");\r\n        }\r\n        return true;\r\n    }\r\n    function checkValidityOf_v(uint8 v) public pure returns (bool) {\r\n        if (v != 27 && v != 28) {\r\n            revert(\"recoverAddressFrom_hash_v_r_s: Invalid v value\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Then, we first define the pure form of recovery.\r\n    function recoverAddressFrom_hash_v_r_s(bytes32 hash, uint8 v, bytes32 r,\r\n    bytes32 s) public pure returns (address) {\r\n        // First, we need to make sure that s and v are in correct ranges\r\n        require(checkValidityOf_s(s) && checkValidityOf_v(v));\r\n\r\n        // call recovery using solidity's built-in ecrecover method\r\n        address _signer = ecrecover(hash, v, r, s);\r\n        \r\n        require(_signer != address(0),\r\n            \"_signer == address(0)\");\r\n\r\n        return _signer;\r\n    }\r\n\r\n    // There are also other ways to receive input without v, r, s values which\r\n    // you will need to parse the unsupported data to find v, r, s and then\r\n    // use those to call ecrecover.\r\n\r\n    // For these, there are 2 other methods:\r\n    // 1. params: hash, r, vs\r\n    // 2. params: hash, signature\r\n\r\n    // These then return the v, r, s values required to use recoverAddressFrom_hash_v_r_s\r\n\r\n    // So, we will parse the first method to get v, r, s\r\n    function get_v_r_s_from_r_vs(bytes32 r, bytes32 vs) public pure \r\n    returns (uint8, bytes32, bytes32) {\r\n        bytes32 s = vs & \r\n            bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        \r\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n\r\n        return (v, r, s);\r\n    }\r\n\r\n    function get_v_r_s_from_signature(bytes memory signature) public pure \r\n    returns (uint8, bytes32, bytes32) {\r\n        // signature.length can be 64 and 65. this depends on the method\r\n        // the standard is 65 bytes1, eip-2098 is 64 bytes1.\r\n        // so, we need to account for these differences\r\n\r\n        // in the case that it is a standard 65 bytes1 signature\r\n        if (signature.length == 65) {\r\n            uint8 v;\r\n            bytes32 r;\r\n            bytes32 s;\r\n\r\n            // assembly magic\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n\r\n            // return the v, r, s \r\n            return (v, r, s);\r\n        }\r\n\r\n        // in the case that it is eip-2098 64 bytes1 signature\r\n        else if (signature.length == 64) {\r\n            bytes32 r;\r\n            bytes32 vs;\r\n\r\n            // assembly magic \r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                vs := mload(add(signature, 0x40))\r\n            }\r\n\r\n            return get_v_r_s_from_r_vs(r, vs);\r\n        }\r\n\r\n        else {\r\n            revert(\"Invalid signature length\");\r\n        }\r\n    }\r\n\r\n    // ///// Embedded toString /////\r\n\r\n    // // We need this in one of the methods of returning a signed message below.\r\n\r\n    // function _toString(uint256 value_) internal pure returns (string memory) {\r\n    //     if (value_ == 0) { return \"0\"; }\r\n    //     uint256 _iterate = value_; uint256 _digits;\r\n    //     while (_iterate != 0) { _digits++; _iterate /= 10; } // get digits in value_\r\n    //     bytes memory _buffer = new bytes(_digits);\r\n    //     while (value_ != 0) { _digits--; _buffer[_digits] = bytes1(uint8(\r\n    //         48 + uint256(value_ % 10 ))); value_ /= 10; } // create bytes of value_\r\n    //     return string(_buffer); // return string converted bytes of value_\r\n    // }\r\n\r\n    // ///// Generation of Hashes /////\r\n    \r\n    // // We need these methods because these methods are used to compare\r\n    // // hash generated off-chain to hash generated on-chain to cross-check the\r\n    // // validity of the signatures\r\n\r\n    // // 1. A bytes32 hash to generate a bytes32 hash embedded with prefix\r\n    // // 2. A bytes memory s to generate a bytes32 hash embedded with prefix\r\n    // // 3. A bytes32 domain seperator and bytes32 structhash to generate \r\n    // //      a bytes32 hash embedded with prefix\r\n\r\n    // // See: EIP-191\r\n    // function toEthSignedMessageHashBytes32(bytes32 hash) public pure \r\n    // returns (bytes32) {\r\n    //     return keccak256(abi.encodePacked(\r\n    //         // Magic prefix determined by the devs\r\n    //         \"\\x19Ethereum Signed Message:\\n32\",\r\n    //         hash\r\n    //     ));\r\n    // }\r\n\r\n    // // See: EIP-191\r\n    // function toEthSignedMessageHashBytes(bytes memory s) public pure\r\n    // returns (bytes32) {\r\n    //     return keccak256(abi.encodePacked(\r\n    //         // Another magic prefix determined by the devs\r\n    //         \"\\x19Ethereum Signed Message:\\n\", \r\n    //         // The bytes length of s\r\n    //         _toString(s.length),\r\n    //         // s itself\r\n    //         s\r\n    //     ));\r\n    // }\r\n\r\n    // // See: EIP-712\r\n    // function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) public\r\n    // pure returns (bytes32) {\r\n    //     return keccak256(abi.encodePacked(\r\n    //         // Yet another magic prefix determined by the devs\r\n    //         \"\\x19\\x01\",\r\n    //         // The domain seperator (EIP-712)\r\n    //         domainSeparator,\r\n    //         // struct hash\r\n    //         structHash\r\n    //     ));\r\n    // }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"checkValidityOf_s\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"checkValidityOf_v\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vs\",\"type\":\"bytes32\"}],\"name\":\"get_v_r_s_from_r_vs\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"get_v_r_s_from_signature\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"recoverAddressFrom_hash_v_r_s\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "ECDSA", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://349984afc3acd48dddc430e3684f1797c239b98e1c5e645098b99c68e9d8a664"}]}