{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.6;\r\n\r\n\r\n\r\n// Part: IBetaOracle\r\n\r\ninterface IBetaOracle {\r\n  /// @dev Returns the given asset price in ETH (wei), multiplied by 2**112.\r\n  /// @param token The token to query for asset price\r\n  function getAssetETHPrice(address token) external returns (uint);\r\n\r\n  /// @dev Returns the given asset value in ETH (wei)\r\n  /// @param token The token to query for asset value\r\n  /// @param amount The amount of token to query\r\n  function getAssetETHValue(address token, uint amount) external returns (uint);\r\n\r\n  /// @dev Returns the conversion from amount of from` to `to`.\r\n  /// @param from The source token to convert.\r\n  /// @param to The destination token to convert.\r\n  /// @param amount The amount of token for conversion.\r\n  function convert(\r\n    address from,\r\n    address to,\r\n    uint amount\r\n  ) external returns (uint);\r\n}\r\n\r\n// Part: IExternalOracle\r\n\r\ninterface IExternalOracle {\r\n  /// @dev Returns the price in terms of ETH for the given token, multiplifed by 2**112.\r\n  function getETHPx(address token) external view returns (uint);\r\n}\r\n\r\n// Part: IUniswapV2Factory\r\n\r\ninterface IUniswapV2Factory {\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n  function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\n// Part: IUniswapV2Pair\r\n\r\ninterface IUniswapV2Pair {\r\n  function getReserves()\r\n    external\r\n    view\r\n    returns (\r\n      uint112 reserve0,\r\n      uint112 reserve1,\r\n      uint32 blockTimestampLast\r\n    );\r\n\r\n  function price0CumulativeLast() external view returns (uint);\r\n\r\n  function price1CumulativeLast() external view returns (uint);\r\n\r\n  function swap(\r\n    uint amount0Out,\r\n    uint amount1Out,\r\n    address to,\r\n    bytes calldata data\r\n  ) external;\r\n}\r\n\r\n// File: BetaOracleUniswapV2.sol\r\n\r\ncontract BetaOracleUniswapV2 is IBetaOracle {\r\n  event SetGovernor(address governor);\r\n  event SetPendingGovernor(address pendingGovernor);\r\n  event Initialize(address token);\r\n  event Observe(address indexed token, uint224 price);\r\n  event SetExternal(address indexed token, address ext);\r\n\r\n  struct Observation {\r\n    uint lastCumu;\r\n    uint224 lastPrice;\r\n    uint32 timestamp;\r\n  }\r\n\r\n  address public immutable weth;\r\n  address public immutable factory;\r\n  uint32 public immutable minTwapTime;\r\n\r\n  address public governor;\r\n  address public pendingGovernor;\r\n  mapping(address => Observation) public observations;\r\n  mapping(address => address) public exts;\r\n\r\n  /// @dev Initializes the oracle contract.\r\n  /// @param _weth WETH address.\r\n  /// @param _factory Uniswap V2 factory address.\r\n  /// @param _minTwapTime Minimum interval for TWAP time (in seconds).\r\n  constructor(\r\n    address _weth,\r\n    address _factory,\r\n    uint32 _minTwapTime\r\n  ) {\r\n    require(_weth != address(0), 'constructor/weth-zero-address');\r\n    require(_factory != address(0), 'constructor/factory-zero-address');\r\n    require(_minTwapTime != 0, 'constructor/min-twap-time-zero-value');\r\n    weth = _weth;\r\n    factory = _factory;\r\n    minTwapTime = _minTwapTime;\r\n    governor = msg.sender;\r\n    emit SetGovernor(msg.sender);\r\n  }\r\n\r\n  /// @dev Sets the next governor, which will be in effect when they accept.\r\n  /// @param _pendingGovernor The next governor address.\r\n  function setPendingGovernor(address _pendingGovernor) external {\r\n    require(msg.sender == governor, 'setPendingGovernor/not-governor');\r\n    pendingGovernor = _pendingGovernor;\r\n    emit SetPendingGovernor(_pendingGovernor);\r\n  }\r\n\r\n  /// @dev Accepts to become the next governor. Must only be called by the pending governor.\r\n  function acceptGovernor() external {\r\n    require(msg.sender == pendingGovernor, 'acceptGovernor/not-pending-governor');\r\n    pendingGovernor = address(0);\r\n    governor = msg.sender;\r\n    emit SetGovernor(msg.sender);\r\n  }\r\n\r\n  /// @dev Updates the external feed contract address for the given tokens by the governor.\r\n  /// @param _tokens The tokens to update external price oracle contract.\r\n  /// @param _ext The external price oracle contract.\r\n  function setExternalOracle(address[] calldata _tokens, address _ext) external {\r\n    require(msg.sender == governor, 'setExternalOracle/not-governor');\r\n    for (uint idx = 0; idx < _tokens.length; idx++) {\r\n      exts[_tokens[idx]] = _ext;\r\n      emit SetExternal(_tokens[idx], _ext);\r\n    }\r\n  }\r\n\r\n  /// @dev Initializes data points for price from pair for the given token.\r\n  /// @param token The token to initialize the price.\r\n  function initPriceFromPair(address token) public {\r\n    Observation storage obs = observations[token];\r\n    require(obs.timestamp == 0, 'initPriceFromPair/already-initialized');\r\n    address pair = IUniswapV2Factory(factory).getPair(token, weth);\r\n    obs.lastCumu = token < weth ? currentPrice0Cumu(pair) : currentPrice1Cumu(pair);\r\n    obs.lastPrice = 0;\r\n    obs.timestamp = uint32(block.timestamp);\r\n    emit Initialize(token);\r\n  }\r\n\r\n  /// @dev Utility functions to initialize multiple pair prices at once.\r\n  /// @param tokens Token list to mass initialize the prices.\r\n  function massInitPriceFromPair(address[] calldata tokens) external {\r\n    for (uint idx = 0; idx < tokens.length; idx++) {\r\n      initPriceFromPair(tokens[idx]);\r\n    }\r\n  }\r\n\r\n  /// @dev Updates price info for the given token and returns the last price.\r\n  /// @param token The token to update token-WETH pair price.\r\n  function updatePriceFromPair(address token) public returns (uint) {\r\n    Observation storage obs = observations[token];\r\n    uint32 lastObserved = obs.timestamp;\r\n    require(lastObserved > 0, 'updatePriceFromPair/uninitialized');\r\n    unchecked {\r\n      uint32 timeElapsed = uint32(block.timestamp) - lastObserved; // overflow is desired\r\n      if (timeElapsed < minTwapTime) {\r\n        uint lastPrice = obs.lastPrice;\r\n        require(lastPrice > 0, 'updatePriceFromPair/no-price');\r\n        return lastPrice;\r\n      }\r\n      address pair = IUniswapV2Factory(factory).getPair(token, weth);\r\n      uint currCumu = token < weth ? currentPrice0Cumu(pair) : currentPrice1Cumu(pair);\r\n      uint224 price = uint224((currCumu - obs.lastCumu) / timeElapsed); // overflow is desired\r\n      obs.lastPrice = price;\r\n      obs.lastCumu = currCumu;\r\n      obs.timestamp = uint32(block.timestamp);\r\n      emit Observe(token, price);\r\n      return price;\r\n    }\r\n  }\r\n\r\n  /// @dev Utility functions to update multiple pair prices at once.\r\n  /// @param tokens Token list to mass update prices.\r\n  function massUpdatePriceFromPair(address[] calldata tokens)\r\n    external\r\n    returns (uint[] memory prices)\r\n  {\r\n    prices = new uint[](tokens.length);\r\n    for (uint idx = 0; idx < tokens.length; idx++) {\r\n      prices[idx] = updatePriceFromPair(tokens[idx]);\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the price of the given asset in terms of ETH (wei), multiplied by 2**112.\r\n  /// @param token The token to get asset price of.\r\n  function getAssetETHPrice(address token) public override returns (uint) {\r\n    if (token == weth) {\r\n      return (1 << 112);\r\n    }\r\n    address ext = exts[token];\r\n    if (ext != address(0)) {\r\n      return IExternalOracle(ext).getETHPx(token);\r\n    }\r\n    return updatePriceFromPair(token);\r\n  }\r\n\r\n  /// @dev Returns the given asset value in ETH (wei)\r\n  /// @param token The token to query for asset value\r\n  /// @param amount The amount of token to query\r\n  function getAssetETHValue(address token, uint amount) external override returns (uint) {\r\n    uint price = getAssetETHPrice(token);\r\n    return (price * amount) >> 112;\r\n  }\r\n\r\n  /// @dev Returns the conversion from amount of from` to `to`.\r\n  /// @param from The source token to convert.\r\n  /// @param to The destination token to convert.\r\n  /// @param amount The amount of token for conversion.\r\n  function convert(\r\n    address from,\r\n    address to,\r\n    uint amount\r\n  ) external override returns (uint) {\r\n    uint fromPrice = getAssetETHPrice(from);\r\n    uint toPrice = getAssetETHPrice(to);\r\n    return (amount * fromPrice) / toPrice;\r\n  }\r\n\r\n  /// @dev Return the current price0 cumulative value on uniswap.\r\n  /// @param pair The uniswap pair to query for price0 cumulative value.\r\n  function currentPrice0Cumu(address pair) public view returns (uint price0Cumu) {\r\n    uint32 currTime = uint32(block.timestamp);\r\n    price0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\r\n    // can use reserves without flash-manipulated risks because cumu changes if reserves change\r\n    (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\r\n    if (lastTime != currTime) {\r\n      unchecked {\r\n        uint32 timeElapsed = currTime - lastTime; // overflow is desired\r\n        price0Cumu += uint((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Return the current price1 cumulative value on uniswap.\r\n  /// @param pair The uniswap pair to query for price1 cumulative value.\r\n  function currentPrice1Cumu(address pair) public view returns (uint price1Cumu) {\r\n    uint32 currTime = uint32(block.timestamp);\r\n    price1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\r\n    // can use reserves without flash-manipulated risks because cumu changes if reserves change\r\n    (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\r\n    if (lastTime != currTime) {\r\n      unchecked {\r\n        uint32 timeElapsed = currTime - lastTime; // overflow is desired\r\n        price1Cumu += uint((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\r\n      }\r\n    }\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_minTwapTime\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint224\",\"name\":\"price\",\"type\":\"uint224\"}],\"name\":\"Observe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ext\",\"type\":\"address\"}],\"name\":\"SetExternal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"SetGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingGovernor\",\"type\":\"address\"}],\"name\":\"SetPendingGovernor\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"currentPrice0Cumu\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price0Cumu\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"currentPrice1Cumu\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price1Cumu\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getAssetETHPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getAssetETHValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"initPriceFromPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"massInitPriceFromPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"massUpdatePriceFromPair\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTwapTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"observations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastCumu\",\"type\":\"uint256\"},{\"internalType\":\"uint224\",\"name\":\"lastPrice\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_ext\",\"type\":\"address\"}],\"name\":\"setExternalOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pendingGovernor\",\"type\":\"address\"}],\"name\":\"setPendingGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"updatePriceFromPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BetaOracleUniswapV2", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac0000000000000000000000000000000000000000000000000000000000000e10", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4e750dbfb8fc9e8e426494b5f024387e577ca8a321bc4c3a331a9e01ae60dcdc"}]}