{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/products/SolaceCoverProduct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"../utils/Governable.sol\\\";\\nimport \\\"../interfaces/utils/IRegistry.sol\\\";\\nimport \\\"../interfaces/risk/IRiskManager.sol\\\";\\nimport \\\"../interfaces/products/ISolaceCoverProduct.sol\\\";\\n\\n/**\\n * @title SolaceCoverProduct\\n * @author solace.fi\\n * @notice A Solace insurance product that allows users to insure all of their DeFi positions against smart contract risk through a single policy.\\n *\\n * Policies can be **purchased** via [`activatePolicy()`](#activatepolicy). Policies are represented as ERC721s, which once minted, cannot then be transferred or burned. Users can change the cover limit of their policy through [`updateCoverLimit()`](#updatecoverlimit).\\n *\\n * The policy will remain active until i.) the user cancels their policy or ii.) the user's account runs out of funds. The policy will be billed like a subscription, every epoch a fee will be charged from the user's account.\\n *\\n * Users can **deposit funds** into their account via [`deposit()`](#deposit). Currently the contract only accepts deposits in **DAI**. Note that both [`activatePolicy()`](#activatepolicy) and [`deposit()`](#deposit) enables a user to perform these actions (activate a policy, make a deposit) on behalf of another user.\\n *\\n * Users can **cancel** their policy via [`deactivatePolicy()`](#deactivatepolicy). This will start a cooldown timer. Users can **withdraw funds** from their account via [`withdraw()`](#withdraw).\\n *\\n * Before the cooldown timer starts or passes, the user cannot withdraw their entire account balance. A minimum required account balance (to cover one epoch's fee) will be left in the user's account. After the cooldown has passed, a user will be able to withdraw their entire account balance.\\n *\\n * Users can enter a **referral code** with [`activatePolicy()`](#activatePolicy) or [`updateCoverLimit()`](#updatecoverlimit). A valid referral code will earn reward points to both the referrer and the referee. When the user's account is charged, reward points will be deducted before deposited funds.\\n * Each account can only enter a valid referral code once, however there are no restrictions on how many times a referral code can be used for new accounts.\\n */\\ncontract SolaceCoverProduct is\\n    ISolaceCoverProduct,\\n    ERC721,\\n    EIP712,\\n    ReentrancyGuard,\\n    Governable\\n{\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n\\n    /***************************************\\n    STATE VARIABLES\\n    ***************************************/\\n\\n    /// @notice Registry contract.\\n    IRegistry internal _registry;\\n\\n    /// @notice Cannot buy new policies while paused. (Default is False)\\n    bool internal _paused;\\n\\n    /// @notice Referral typehash.\\n    /// solhint-disable-next-line var-name-mixedcase\\n    bytes32 private constant _REFERRAL_TYPEHASH = keccak256(\\\"SolaceReferral(uint256 version)\\\");\\n\\n    string public baseURI;\\n\\n    /***************************************\\n    BOOK-KEEPING VARIABLES\\n    ***************************************/\\n\\n    /// @notice The total policy count.\\n    uint256 internal _totalPolicyCount;\\n\\n    /**\\n     * @notice The maximum rate charged per second per 1e-18 (wei) of coverLimit.\\n     * @dev Default to charge 10% of cover limit annually = 1/315360000.\\n     */\\n    uint256 internal _maxRateNum;\\n    uint256 internal _maxRateDenom;\\n\\n    /// @notice Maximum epoch duration over which premiums are charged (Default is one week).\\n    uint256 internal _chargeCycle;\\n\\n    /**\\n     * @notice The cooldown period (Default is one week)\\n     * Cooldown timer is started by the user calling deactivatePolicy().\\n     * Before the cooldown has started or has passed, withdrawing funds will leave a minimim required account balance in the user's account. Only after the cooldown has passed, is a user able to withdraw their entire account balance.\\n     */\\n    uint256 internal _cooldownPeriod;\\n\\n    /**\\n     * @notice The reward points earned (to both the referee and referrer) for a valid referral code. (Default is 50 DAI).\\n     */\\n    uint256 internal _referralReward;\\n\\n    /**\\n     * @notice If true, referral rewards are active. If false, referral rewards are switched off (Default is true).\\n     */\\n    bool internal _isReferralOn;\\n\\n    /**\\n     * @notice policyholder => cooldown start timestamp\\n     * @dev will be 0 if cooldown has not started, or has been reset\\n     */\\n    mapping(address => uint256) internal _cooldownStart;\\n\\n    /// @notice policyholder => policyID.\\n    mapping(address => uint256) internal _policyOf;\\n\\n    /// @notice policyID => coverLimit\\n    mapping(uint256 => uint256) internal _coverLimitOf;\\n\\n    /**\\n     * @notice This is a mapping that no-one likes but seems necessary to circumvent a couple of edge cases. This mapping is intended to mirror the _coverLimitOf mapping, except for the period between i.) cooldown starting when deactivatePolicy() called and ii.) cooldown has passed and user calls withdraw()\\n     * @dev Edge case 1: User deactivates policy -> User can withdraw all funds immediately after, circumventing the intended cooldown mechanic. This occurs because when deactivatePolicy() called, _coverLimitOf[user] is set to 0, which also sets their minRequiredAccountBalance (coverLimit * chargeCycle * maxRate) to 0.\\n     * @dev Edge case 2: A user should not be able to deactivate their policy just prior to the fee charge tranasction, and then avoid the insurance fee for the current epoch.\\n     * @dev will be 0 if cooldown has not started, or has been reset\\n     */\\n    mapping(uint256 => uint256) internal _preDeactivateCoverLimitOf;\\n\\n    /**\\n     * @notice policyholder => reward points.\\n     * Users earn reward points for using a valid referral code (as a referee), and having other users successfully use their referral code (as a referrer)\\n     * Reward points can be manually set by the Cover Promotion Admin\\n     * Reward points act as a credit, when an account is charged, they are deducted from before deposited funds\\n     */\\n    mapping(address => uint256) internal _rewardPointsOf;\\n\\n    /**\\n     * @notice policyID => true if referral code has been used, false if not\\n     * A referral code can only be used once for each policy. There is no way to reset to false.\\n     */\\n    mapping(uint256 => bool) internal _isReferralCodeUsed;\\n\\n    /// @notice policyholder => account balance (in USD, to 18 decimals places)\\n    mapping(address => uint256) private _accountBalanceOf;\\n\\n    /***************************************\\n    MODIFIERS\\n    ***************************************/\\n\\n    modifier whileUnpaused() {\\n        require(!_paused, \\\"contract paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Constructs `Solace Cover Product`.\\n     * @param governance_ The address of the governor.\\n     * @param registry_ The [`Registry`](./Registry) contract address.\\n     * @param domain_ The user readable name of the EIP712 signing domain.\\n     * @param version_ The current major version of the signing domain.\\n     */\\n    constructor(\\n        address governance_,\\n        address registry_,\\n        string memory domain_,\\n        string memory version_\\n    )\\n        ERC721(\\\"Solace Cover Policy\\\", \\\"SCP\\\")\\n        Governable(governance_)\\n        EIP712(domain_, version_)\\n    {\\n        require(registry_ != address(0x0), \\\"zero address registry\\\");\\n        _registry = IRegistry(registry_);\\n        require(_registry.get(\\\"riskManager\\\") != address(0x0), \\\"zero address riskmanager\\\");\\n        require(_registry.get(\\\"dai\\\") != address(0x0), \\\"zero address dai\\\");\\n\\n        // Set default values\\n        _maxRateNum = 1;\\n        _maxRateDenom = 315360000; // Max premium rate of 10% of cover limit per annum\\n        _chargeCycle = 604800; // One-week charge cycle\\n        _cooldownPeriod = 604800; // One-week cooldown period\\n        _referralReward = 50e18; // 50 DAI\\n        _isReferralOn = true; // Referral rewards active\\n        baseURI = string(abi.encodePacked(\\\"https://stats.solace.fi/policy/soteria/?chainID=\\\", Strings.toString(block.chainid), \\\"&policyID=\\\"));\\n    }\\n\\n    /***************************************\\n    POLICYHOLDER FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Activates policy for `policyholder_`\\n     * @param policyholder_ The address of the intended policyholder.\\n     * @param coverLimit_ The maximum value to cover in **USD**.\\n     * @param amount_ The deposit amount in **USD** to fund the policyholder's account.\\n     * @param referralCode_ The referral code.\\n     * @return policyID The ID of the newly minted policy.\\n     */\\n    function activatePolicy(\\n        address policyholder_,\\n        uint256 coverLimit_,\\n        uint256 amount_,\\n        bytes calldata referralCode_\\n    ) external override nonReentrant whileUnpaused returns (uint256 policyID) {\\n        require(policyholder_ != address(0x0), \\\"zero address policyholder\\\");\\n        require(coverLimit_ > 0, \\\"zero cover value\\\");\\n\\n        policyID = policyOf(policyholder_);\\n        require(!policyStatus(policyID), \\\"policy already activated\\\");\\n        require(_canPurchaseNewCover(0, coverLimit_), \\\"insufficient capacity for new cover\\\");\\n        require(IERC20(_getAsset()).balanceOf(msg.sender) >= amount_, \\\"insufficient caller balance for deposit\\\");\\n        require(amount_ + accountBalanceOf(policyholder_) > _minRequiredAccountBalance(coverLimit_), \\\"insufficient deposit for minimum required account balance\\\");\\n\\n        // Exit cooldown\\n        _exitCooldown(policyholder_);\\n\\n        // deposit funds\\n        _deposit(msg.sender, policyholder_, amount_);\\n\\n        // mint policy if doesn't currently exist\\n        if (policyID == 0) {\\n            policyID = ++_totalPolicyCount;\\n            _policyOf[policyholder_] = policyID;\\n            _mint(policyholder_, policyID);\\n        }\\n\\n        _processReferralCode(policyholder_, referralCode_);\\n\\n        // update cover amount\\n        _updateActiveCoverLimit(0, coverLimit_);\\n        _coverLimitOf[policyID] = coverLimit_;\\n        _preDeactivateCoverLimitOf[policyID] = coverLimit_;\\n        emit PolicyCreated(policyID);\\n        return policyID;\\n    }\\n\\n    /**\\n     * @notice Updates the cover limit of a user's policy.\\n     * @notice This will reset the cooldown.\\n     * @param newCoverLimit_ The new maximum value to cover in **USD**.\\n     * @param referralCode_ The referral code.\\n     */\\n    function updateCoverLimit(\\n        uint256 newCoverLimit_,\\n        bytes calldata referralCode_\\n    ) external override nonReentrant whileUnpaused {\\n        require(newCoverLimit_ > 0, \\\"zero cover value\\\");\\n        uint256 policyID = _policyOf[msg.sender];\\n        require(_exists(policyID), \\\"invalid policy\\\");\\n        uint256 currentCoverLimit = coverLimitOf(policyID);\\n        require(\\n            _canPurchaseNewCover(currentCoverLimit, newCoverLimit_),\\n            \\\"insufficient capacity for new cover\\\"\\n        );\\n        require(\\n            _accountBalanceOf[msg.sender] > _minRequiredAccountBalance(newCoverLimit_),\\n            \\\"insufficient deposit for minimum required account balance\\\"\\n        );\\n\\n        _processReferralCode(msg.sender, referralCode_);\\n\\n        _exitCooldown(msg.sender); // Reset cooldown\\n        _coverLimitOf[policyID] = newCoverLimit_;\\n        _preDeactivateCoverLimitOf[policyID] = newCoverLimit_;\\n        _updateActiveCoverLimit(currentCoverLimit, newCoverLimit_);\\n        emit PolicyUpdated(policyID);\\n    }\\n\\n    /**\\n     * @notice Deposits funds into the `policyholder` account.\\n     * @param policyholder The policyholder.\\n     * @param amount The amount to deposit in **USD**.\\n     */\\n    function deposit(\\n        address policyholder,\\n        uint256 amount\\n    ) external override nonReentrant whileUnpaused {\\n        require(policyholder != address(0x0), \\\"zero address policyholder\\\");\\n        _deposit(msg.sender, policyholder, amount);\\n    }\\n\\n    /**\\n     * @notice Withdraw funds from user's account.\\n     *\\n     * @notice If cooldown has passed, the user will withdraw their entire account balance.\\n     *\\n     * @notice If cooldown has not started, or has not passed, the user will not be able to withdraw their entire account. A minimum required account balance (one epoch's fee) will be left in the user's account.\\n     */\\n    function withdraw() external override nonReentrant whileUnpaused {\\n        require(_accountBalanceOf[msg.sender] > 0, \\\"no account balance to withdraw\\\");\\n        if ( _hasCooldownPassed(msg.sender) ) {\\n          _withdraw(msg.sender, _accountBalanceOf[msg.sender]);\\n          _preDeactivateCoverLimitOf[_policyOf[msg.sender]] = 0;\\n        } else {\\n          uint256 preDeactivateCoverLimit = _preDeactivateCoverLimitOf[_policyOf[msg.sender]];\\n          _withdraw(msg.sender, _accountBalanceOf[msg.sender] - _minRequiredAccountBalance(preDeactivateCoverLimit));\\n        }\\n    }\\n\\n    /**\\n     * @notice Deactivate a user's policy.\\n     *\\n     * This will set a user's cover limit to 0, and begin the cooldown timer. Read comments for [`cooldownPeriod()`](#cooldownperiod) for more information on the cooldown mechanic.\\n     */\\n    function deactivatePolicy() external override nonReentrant {\\n        require(policyStatus(_policyOf[msg.sender]), \\\"invalid policy\\\");\\n        _deactivatePolicy(msg.sender);\\n    }\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Returns the policyholder's account account balance in **USD**.\\n     * @param policyholder The policyholder address.\\n     * @return balance The policyholder's account balance in **USD**.\\n     */\\n    function accountBalanceOf(address policyholder) public view override returns (uint256 balance) {\\n        return _accountBalanceOf[policyholder];\\n    }\\n\\n    /**\\n     * @notice The maximum amount of cover that can be sold in **USD** to 18 decimals places.\\n     * @return cover The max amount of cover.\\n     */\\n    function maxCover() public view override returns (uint256 cover) {\\n        return IRiskManager(_registry.get(\\\"riskManager\\\")).maxCoverPerStrategy(address(this));\\n    }\\n\\n    /**\\n     * @notice Returns the active cover limit in **USD** to 18 decimal places. In other words, the total cover that has been sold at the current time.\\n     * @return amount The active cover limit.\\n     */\\n    function activeCoverLimit() public view override returns (uint256 amount) {\\n        return IRiskManager(_registry.get(\\\"riskManager\\\")).activeCoverLimitPerStrategy(address(this));\\n    }\\n\\n    /**\\n     * @notice Determine the available remaining capacity for new cover.\\n     * @return availableCoverCapacity_ The amount of available remaining capacity for new cover.\\n     */\\n    function availableCoverCapacity() public view override returns (uint256 availableCoverCapacity_) {\\n        availableCoverCapacity_ = maxCover() - activeCoverLimit();\\n    }\\n\\n    /**\\n     * @notice Get the reward points that a policyholder has in **USD** to 18 decimal places.\\n     * @param policyholder_ The policyholder address.\\n     * @return rewardPoints_ The reward points for the policyholder.\\n     */\\n    function rewardPointsOf(address policyholder_) public view override returns (uint256 rewardPoints_) {\\n        return _rewardPointsOf[policyholder_];\\n    }\\n\\n    /**\\n     * @notice Gets the policyholder's policy ID.\\n     * @param policyholder_ The address of the policyholder.\\n     * @return policyID The policy ID.\\n     */\\n    function policyOf(address policyholder_) public view override returns (uint256 policyID) {\\n        return _policyOf[policyholder_];\\n    }\\n\\n    /**\\n     * @notice Returns true if the policy is active, false if inactive\\n     * @param policyID_ The policy ID.\\n     * @return status True if policy is active. False otherwise.\\n     */\\n    function policyStatus(uint256 policyID_) public view override returns (bool status) {\\n        return coverLimitOf(policyID_) > 0 ? true : false;\\n    }\\n\\n    /**\\n     * @notice Returns [`Registry`](./Registry) contract address.\\n     * @return registry_ The `Registry` address.\\n     */\\n    function registry() external view override returns (address registry_) {\\n        return address(_registry);\\n    }\\n\\n    /**\\n     * @notice Returns [`RiskManager`](./RiskManager) contract address.\\n     * @return riskManager_ The `RiskManager` address.\\n     */\\n    function riskManager() external view override returns (address riskManager_) {\\n        return address(_registry.get(\\\"riskManager\\\"));\\n    }\\n\\n    /**\\n     * @notice Returns true if the product is paused, false if not.\\n     * @return status True if product is paused.\\n     */\\n    function paused() external view override returns (bool status) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @notice Gets the policy count (amount of policies that have been purchased, includes inactive policies).\\n     * @return count The policy count.\\n     */\\n    function policyCount() public view override returns (uint256 count) {\\n        return _totalPolicyCount;\\n    }\\n\\n    /**\\n     * @notice Gets the max rate numerator.\\n     * @return maxRateNum_ the max rate numerator.\\n     */\\n    function maxRateNum() public view override returns (uint256 maxRateNum_) {\\n        return _maxRateNum;\\n    }\\n\\n    /**\\n     * @notice Gets the max rate denominator.\\n     * @return maxRateDenom_ the max rate denominator.\\n     */\\n    function maxRateDenom() public view override returns (uint256 maxRateDenom_) {\\n        return _maxRateDenom;\\n    }\\n\\n    /**\\n     * @notice Gets the charge cycle duration.\\n     * @return chargeCycle_ the charge cycle duration in seconds.\\n     */\\n    function chargeCycle() public view override returns (uint256 chargeCycle_) {\\n        return _chargeCycle;\\n    }\\n\\n    /**\\n     * @notice Gets cover limit for a given policy ID.\\n     * @param policyID_ The policy ID.\\n     * @return amount The cover limit for given policy ID.\\n     */\\n    function coverLimitOf(uint256 policyID_) public view override returns (uint256 amount) {\\n        return _coverLimitOf[policyID_];\\n    }\\n\\n    /**\\n     * @notice Gets the cooldown period.\\n     *\\n     * Cooldown timer is started by the user calling deactivatePolicy().\\n     * Before the cooldown has started or has passed, withdrawing funds will leave a minimim required account balance in the user's account.\\n     * Only after the cooldown has passed, is a user able to withdraw their entire account balance.\\n     * @return cooldownPeriod_ The cooldown period in seconds.\\n     */\\n    function cooldownPeriod() external view override returns (uint256 cooldownPeriod_) {\\n        return _cooldownPeriod;\\n    }\\n\\n    /**\\n     * @notice The Unix timestamp that a policyholder's cooldown started. If cooldown has not started or has been reset, will return 0.\\n     * @param policyholder_ The policyholder address\\n     * @return cooldownStart_ The cooldown period start expressed as Unix timestamp\\n     */\\n    function cooldownStart(address policyholder_) external view override returns (uint256 cooldownStart_) {\\n        return _cooldownStart[policyholder_];\\n    }\\n\\n    /**\\n     * @notice Gets the current reward amount in USD for a valid referral code.\\n     * @return referralReward_ The referral reward\\n     */\\n    function referralReward() external view override returns (uint256 referralReward_) {\\n        return _referralReward;\\n    }\\n\\n    /**\\n     * @notice Returns true if referral rewards are active, false if not.\\n     * @return isReferralOn_ True if referral rewards are active, false if not.\\n     */\\n    function isReferralOn() external view override returns (bool isReferralOn_) {\\n        return _isReferralOn;\\n    }\\n\\n    /**\\n     * @notice True if a policyholder has previously used a valid referral code, false if not\\n     *\\n     * A policyholder can only use a referral code once. A policyholder is then ineligible to receive further rewards from additional referral codes.\\n     * @return isReferralCodeUsed_ True if the policyholder has previously used a valid referral code, false if not\\n     */\\n    function isReferralCodeUsed(address policyholder) external view override returns (bool isReferralCodeUsed_) {\\n        return _isReferralCodeUsed[_policyOf[policyholder]];\\n    }\\n\\n    /**\\n     * @notice Returns true if valid referral code, false otherwise.\\n     * @param referralCode The referral code.\\n     */\\n    function isReferralCodeValid(bytes calldata referralCode) external view override returns (bool) {\\n        (address referrer,) = ECDSA.tryRecover(_getEIP712Hash(), referralCode);\\n        if(referrer == address(0)) return false;\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get referrer from referral code, returns 0 address if invalid referral code.\\n     * @param referralCode The referral code.\\n     * @return referrer The referrer address, returns 0 address if invalid referral code.\\n     */\\n    function getReferrerFromReferralCode(bytes calldata referralCode) external view override returns (address referrer) {\\n        (referrer,) = ECDSA.tryRecover(_getEIP712Hash(), referralCode);\\n    }\\n\\n    /**\\n     * @notice Calculate minimum required account balance for a given cover limit. Equals the maximum chargeable fee for one epoch.\\n     * @param coverLimit Cover limit.\\n     */\\n    function minRequiredAccountBalance(uint256 coverLimit) external view override returns (uint256 minRequiredAccountBalance_) {\\n        return _minRequiredAccountBalance(coverLimit);\\n    }\\n\\n    /**\\n     * @notice Returns the Uniform Resource Identifier (URI) for `policyID`.\\n     * @param policyID The policy ID.\\n     */\\n    function tokenURI(uint256 policyID) public view virtual override returns (string memory tokenURI_) {\\n        require(_exists(policyID), \\\"invalid policy\\\");\\n        string memory baseURI_ = baseURI;\\n        return string(abi.encodePacked( baseURI_, Strings.toString(policyID) ));\\n    }\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Sets the [`Registry`](./Registry) contract address.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param registry_ The address of `Registry` contract.\\n     */\\n    function setRegistry(address registry_) external override onlyGovernance {\\n        require(registry_ != address(0x0), \\\"zero address registry\\\");\\n        _registry = IRegistry(registry_);\\n\\n        require(_registry.get(\\\"riskManager\\\") != address(0x0), \\\"zero address riskmanager\\\");\\n        require(_registry.get(\\\"dai\\\") != address(0x0), \\\"zero address dai\\\");\\n        emit RegistrySet(registry_);\\n    }\\n\\n    /**\\n     * @notice Pauses or unpauses policies.\\n     * Deactivating policies are unaffected by pause.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param paused_ True to pause, false to unpause.\\n     */\\n    function setPaused(bool paused_) external override onlyGovernance {\\n        _paused = paused_;\\n        emit PauseSet(paused_);\\n    }\\n\\n    /**\\n     * @notice Sets the cooldown period. Read comments for [`cooldownPeriod()`](#cooldownperiod) for more information on the cooldown mechanic.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param cooldownPeriod_ Cooldown period in seconds.\\n     */\\n    function setCooldownPeriod(uint256 cooldownPeriod_) external override onlyGovernance {\\n        _cooldownPeriod = cooldownPeriod_;\\n        emit CooldownPeriodSet(cooldownPeriod_);\\n    }\\n\\n    /**\\n     * @notice set _maxRateNum.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param maxRateNum_ Desired maxRateNum.\\n     */\\n    function setMaxRateNum(uint256 maxRateNum_) external override onlyGovernance {\\n        _maxRateNum = maxRateNum_;\\n        emit MaxRateNumSet(maxRateNum_);\\n    }\\n\\n    /**\\n     * @notice set _maxRateDenom.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param maxRateDenom_ Desired maxRateDenom.\\n     */\\n    function setMaxRateDenom(uint256 maxRateDenom_) external override onlyGovernance {\\n        _maxRateDenom = maxRateDenom_;\\n        emit MaxRateDenomSet(maxRateDenom_);\\n    }\\n\\n    /**\\n     * @notice set _chargeCycle.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param chargeCycle_ Desired chargeCycle.\\n     */\\n    function setChargeCycle(uint256 chargeCycle_) external override onlyGovernance {\\n        _chargeCycle = chargeCycle_;\\n        emit ChargeCycleSet(chargeCycle_);\\n    }\\n\\n    /**\\n     * @notice set _referralReward\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param referralReward_ Desired referralReward.\\n    */\\n    function setReferralReward(uint256 referralReward_) external override onlyGovernance {\\n        _referralReward = referralReward_;\\n        emit ReferralRewardSet(referralReward_);\\n    }\\n\\n    /**\\n     * @notice set _isReferralOn\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param isReferralOn_ True if referral rewards active, false if not.\\n    */\\n    function setIsReferralOn(bool isReferralOn_) external override onlyGovernance {\\n        _isReferralOn = isReferralOn_;\\n        emit IsReferralOnSet(isReferralOn_);\\n    }\\n\\n    /**\\n     * @notice Sets the base URI for computing `tokenURI`.\\n     * @param baseURI_ The new base URI.\\n     */\\n    function setBaseURI(string memory baseURI_) external override onlyGovernance {\\n        baseURI = baseURI_;\\n        emit BaseURISet(baseURI_);\\n    }\\n\\n    /***************************************\\n    COVER PROMOTION ADMIN FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Set reward points for a selected address. Can only be called by the **Cover Promotion Admin** role.\\n     * @param policyholder_ The address of the policyholder to set reward points for.\\n     * @param rewardPoints_ Desired amount of reward points.\\n     */\\n    function setRewardPoints(address policyholder_, uint256 rewardPoints_) external override {\\n        require(msg.sender == _registry.get(\\\"coverPromotionAdmin\\\"), \\\"not cover promotion admin\\\");\\n        _rewardPointsOf[policyholder_] = rewardPoints_;\\n        emit RewardPointsSet(policyholder_, rewardPoints_);\\n    }\\n\\n    /***************************************\\n    PREMIUM COLLECTOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Charge premiums for each policy holder. Can only be called by the **Premium Collector** role.\\n     *\\n     * @dev Cheaper to load variables directly from calldata, rather than adding an additional operation of copying to memory.\\n     * @param holders Array of addresses of the policyholders to charge.\\n     * @param premiums Array of premium amounts (in **USD** to 18 decimal places) to charge each policyholder.\\n     */\\n    function chargePremiums(\\n        address[] calldata holders,\\n        uint256[] calldata premiums\\n    ) external override whileUnpaused {\\n        uint256 count = holders.length;\\n        require(msg.sender == _registry.get(\\\"premiumCollector\\\"), \\\"not premium collector\\\");\\n        require(count == premiums.length, \\\"length mismatch\\\");\\n        require(count <= policyCount(), \\\"policy count exceeded\\\");\\n        uint256 amountToPayPremiumPool = 0;\\n\\n        for (uint256 i = 0; i < count; i++) {\\n            // Skip computation if the user has withdrawn entire account balance\\n            // We use _preDeactivateCoverLimitOf mapping here to circumvent the following edge case: A user should not be able to deactivate their policy just prior to the chargePremiums() tranasction, and then avoid the premium for the current epoch.\\n            // There is another edge case introduced here however: the premium collector can charge a deactivated account more than once. We are trusting that the premium collector does not do this.\\n\\n            uint256 preDeactivateCoverLimit = _preDeactivateCoverLimitOf[_policyOf[holders[i]]];\\n            if ( preDeactivateCoverLimit == 0) continue;\\n\\n            uint256 premium = premiums[i];\\n            if (premiums[i] > _minRequiredAccountBalance(preDeactivateCoverLimit)) {\\n                premium = _minRequiredAccountBalance(preDeactivateCoverLimit);\\n            }\\n\\n            // If policyholder's account can pay for premium charged in full\\n            if (_accountBalanceOf[holders[i]] + _rewardPointsOf[holders[i]] >= premium) {\\n\\n                // If reward points can pay for premium charged in full\\n                if (_rewardPointsOf[holders[i]] >= premium) {\\n                    _rewardPointsOf[holders[i]] -= premium;\\n                } else {\\n                    uint256 amountDeductedFromSoteriaAccount = premium - _rewardPointsOf[holders[i]];\\n                    amountToPayPremiumPool += amountDeductedFromSoteriaAccount;\\n                    _accountBalanceOf[holders[i]] -= amountDeductedFromSoteriaAccount;\\n                    _rewardPointsOf[holders[i]] = 0;\\n                }\\n                emit PremiumCharged(holders[i], premium);\\n            } else {\\n                uint256 partialPremium = _accountBalanceOf[holders[i]] + _rewardPointsOf[holders[i]];\\n                amountToPayPremiumPool += _accountBalanceOf[holders[i]];\\n                _accountBalanceOf[holders[i]] = 0;\\n                _rewardPointsOf[holders[i]] = 0;\\n                _deactivatePolicy(holders[i]);\\n                emit PremiumPartiallyCharged(\\n                    holders[i],\\n                    premium,\\n                    partialPremium\\n                );\\n            }\\n        }\\n\\n        // single DAI transfer to the premium pool\\n        SafeERC20.safeTransfer(_getAsset(), _registry.get(\\\"premiumPool\\\"), amountToPayPremiumPool);\\n    }\\n\\n    /***************************************\\n    INTERNAL FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Returns true if there is sufficient capacity to update a policy's cover limit, false if not.\\n     * @param existingTotalCover_ The current cover limit, 0 if policy has not previously been activated.\\n     * @param newTotalCover_  The new cover limit requested.\\n     * @return acceptable True there is sufficient capacity for the requested new cover limit, false otherwise.\\n     */\\n    function _canPurchaseNewCover(\\n        uint256 existingTotalCover_,\\n        uint256 newTotalCover_\\n    ) internal view returns (bool acceptable) {\\n        if (newTotalCover_ <= existingTotalCover_) return true; // Return if user is lowering cover limit\\n        uint256 changeInTotalCover = newTotalCover_ - existingTotalCover_; // This will revert if newTotalCover_ < existingTotalCover_\\n        if (changeInTotalCover < availableCoverCapacity()) return true;\\n        else return false;\\n    }\\n\\n    /**\\n     * @notice Deposits funds into the policyholder's account balance.\\n     * @param from The address which is funding the deposit.\\n     * @param policyholder The policyholder address.\\n     * @param amount The deposit amount in **USD** to 18 decimal places.\\n     */\\n    function _deposit(\\n        address from,\\n        address policyholder,\\n        uint256 amount\\n    ) internal whileUnpaused {\\n        SafeERC20.safeTransferFrom(_getAsset(), from, address(this), amount);\\n        _accountBalanceOf[policyholder] += amount;\\n        emit DepositMade(from, policyholder, amount);\\n    }\\n\\n    /**\\n     * @notice Withdraw funds from policyholder's account to the policyholder.\\n     * @param policyholder The policyholder address.\\n     * @param amount The amount to withdraw in **USD** to 18 decimal places.\\n     */\\n    function _withdraw(\\n        address policyholder,\\n        uint256 amount\\n    ) internal whileUnpaused {\\n        SafeERC20.safeTransfer(_getAsset(), policyholder, amount);\\n        _accountBalanceOf[policyholder] -= amount;\\n        emit WithdrawMade(policyholder, amount);\\n    }\\n\\n    /**\\n     * @notice Deactivate the policy.\\n     * @param policyholder The policyholder address.\\n     */\\n    function _deactivatePolicy(address policyholder) internal {\\n        _startCooldown(policyholder);\\n        uint256 policyID = _policyOf[policyholder];\\n        _updateActiveCoverLimit(_coverLimitOf[policyID], 0);\\n        _coverLimitOf[policyID] = 0;\\n        emit PolicyDeactivated(policyID);\\n    }\\n\\n    /**\\n     * @notice Updates the Risk Manager on the current total cover limit purchased by policyholders.\\n     * @param currentCoverLimit The current policyholder cover limit (0 if activating policy).\\n     * @param newCoverLimit The new policyholder cover limit.\\n     */\\n    function _updateActiveCoverLimit(\\n        uint256 currentCoverLimit,\\n        uint256 newCoverLimit\\n    ) internal {\\n        IRiskManager(_registry.get(\\\"riskManager\\\"))\\n            .updateActiveCoverLimitForStrategy(\\n                address(this),\\n                currentCoverLimit,\\n                newCoverLimit\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculate minimum required account balance for a given cover limit. Equals the maximum chargeable fee for one epoch.\\n     * @param coverLimit Cover limit.\\n     */\\n    function _minRequiredAccountBalance(uint256 coverLimit) internal view returns (uint256 minRequiredAccountBalance) {\\n        minRequiredAccountBalance = (_maxRateNum * _chargeCycle * coverLimit) / _maxRateDenom;\\n    }\\n\\n    /**\\n     * @notice Override _beforeTokenTransfer hook from ERC721 standard to ensure policies are non-transferable, and only one can be minted per user.\\n     * @dev This hook is called on mint, transfer and burn.\\n     * @param from sending address.\\n     * @param to receiving address.\\n     * @param tokenId tokenId.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n        require(from == address(0), \\\"only minting permitted\\\");\\n    }\\n\\n    /**\\n     * @notice Starts the cooldown period for the policyholder.\\n     * @param policyholder Policyholder address.\\n     */\\n    function _startCooldown(address policyholder) internal {\\n        // solhint-disable-next-line not-rely-on-time\\n        _cooldownStart[policyholder] = block.timestamp;\\n        emit CooldownStarted(policyholder, _cooldownStart[policyholder]);\\n    }\\n\\n    /**\\n     * @notice Exits the cooldown period for a policyholder.\\n     * @param policyholder Policyholder address.\\n     */\\n    function _exitCooldown(address policyholder) internal {\\n        _cooldownStart[policyholder] = 0;\\n        emit CooldownStopped(policyholder);\\n    }\\n\\n    /**\\n     * @notice Return true if cooldown has passed for a policyholder, false if cooldown has not started or has not passed.\\n     * @param policyholder Policyholder address.\\n     * @return True if cooldown has passed, false if cooldown has not started or has not passed.\\n     */\\n    function _hasCooldownPassed(address policyholder) internal view returns (bool) {\\n        if (_cooldownStart[policyholder] == 0) {\\n            return false;\\n        } else {\\n            // solhint-disable-next-line not-rely-on-time\\n            return block.timestamp >= _cooldownStart[policyholder] + _cooldownPeriod;\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to process a referral code\\n     * @param policyholder_ Policyholder address.\\n     * @param referralCode_ Referral code.\\n     */\\n    function _processReferralCode(\\n        address policyholder_,\\n        bytes calldata referralCode_\\n    ) internal {\\n        // Skip processing referral code, if referral campaign switched off or empty referral code argument\\n        if ( !_isReferralOn || _isEmptyReferralCode(referralCode_) ) return;\\n\\n        address referrer = ECDSA.recover(_getEIP712Hash(), referralCode_);\\n        require(referrer != policyholder_, \\\"cannot refer to self\\\");\\n        require(policyStatus(_policyOf[referrer]), \\\"referrer must be active policy holder\\\");\\n        require (!_isReferralCodeUsed[_policyOf[policyholder_]], \\\"cannot use referral code again\\\");\\n\\n        _isReferralCodeUsed[_policyOf[policyholder_]] = true;\\n        _rewardPointsOf[policyholder_] += _referralReward;\\n        _rewardPointsOf[referrer] += _referralReward;\\n\\n        emit ReferralRewardsEarned(policyholder_, _referralReward);\\n        emit ReferralRewardsEarned(referrer, _referralReward);\\n    }\\n\\n    /**\\n     * @notice Internal helper function to determine if referralCode_ is an empty bytes value\\n     * @param referralCode_ Referral code.\\n     * @return True if empty referral code, false if not.\\n     */\\n    function _isEmptyReferralCode(bytes calldata referralCode_) internal pure returns (bool) {\\n        return (keccak256(abi.encodePacked(referralCode_)) == keccak256(abi.encodePacked(\\\"\\\")));\\n    }\\n\\n    /**\\n     * @notice Internal helper function to get EIP712-compliant hash for referral code verification.\\n     */\\n    function _getEIP712Hash() internal view returns (bytes32) {\\n        bytes32 digest =\\n            ECDSA.toTypedDataHash(\\n                _domainSeparatorV4(),\\n                keccak256(\\n                    abi.encode(\\n                        _REFERRAL_TYPEHASH,\\n                        1\\n                    )\\n                )\\n            );\\n        return digest;\\n    }\\n\\n    /**\\n     * @notice Returns the underlying principal asset for `Solace Cover Product`.\\n     * @return asset The underlying asset.\\n    */\\n    function _getAsset() internal view returns (IERC20 asset) {\\n        return IERC20(_registry.get(\\\"dai\\\"));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"./../interfaces/utils/IGovernable.sol\\\";\\n\\n/**\\n * @title Governable\\n * @author solace.fi\\n * @notice Enforces access control for important functions to [**governor**](/docs/protocol/governance).\\n *\\n * Many contracts contain functionality that should only be accessible to a privileged user. The most common access control pattern is [OpenZeppelin's `Ownable`](https://docs.openzeppelin.com/contracts/4.x/access-control#ownership-and-ownable). We instead use `Governable` with a few key differences:\\n   * - Transferring the governance role is a two step process. The current governance must [`setPendingGovernance(pendingGovernance_)`](#setpendinggovernance) then the new governance must [`acceptGovernance()`](#acceptgovernance). This is to safeguard against accidentally setting ownership to the wrong address and locking yourself out of your contract.\\n * - `governance` is a constructor argument instead of `msg.sender`. This is especially useful when deploying contracts via a [`SingletonFactory`](./../interfaces/utils/ISingletonFactory).\\n * - We use `lockGovernance()` instead of `renounceOwnership()`. `renounceOwnership()` is a prerequisite for the reinitialization bug because it sets `owner = address(0x0)`. We also use the `governanceIsLocked()` flag.\\n */\\ncontract Governable is IGovernable {\\n\\n    /***************************************\\n    GLOBAL VARIABLES\\n    ***************************************/\\n\\n    // Governor.\\n    address private _governance;\\n\\n    // governance to take over.\\n    address private _pendingGovernance;\\n\\n    bool private _locked;\\n\\n    /**\\n     * @notice Constructs the governable contract.\\n     * @param governance_ The address of the [governor](/docs/protocol/governance).\\n     */\\n    constructor(address governance_) {\\n        require(governance_ != address(0x0), \\\"zero address governance\\\");\\n        _governance = governance_;\\n        _pendingGovernance = address(0x0);\\n        _locked = false;\\n    }\\n\\n    /***************************************\\n    MODIFIERS\\n    ***************************************/\\n\\n    // can only be called by governor\\n    // can only be called while unlocked\\n    modifier onlyGovernance() {\\n        require(!_locked, \\\"governance locked\\\");\\n        require(msg.sender == _governance, \\\"!governance\\\");\\n        _;\\n    }\\n\\n    // can only be called by pending governor\\n    // can only be called while unlocked\\n    modifier onlyPendingGovernance() {\\n        require(!_locked, \\\"governance locked\\\");\\n        require(msg.sender == _pendingGovernance, \\\"!pending governance\\\");\\n        _;\\n    }\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Address of the current governor.\\n    function governance() public view override returns (address) {\\n        return _governance;\\n    }\\n\\n    /// @notice Address of the governor to take over.\\n    function pendingGovernance() external view override returns (address) {\\n        return _pendingGovernance;\\n    }\\n\\n    /// @notice Returns true if governance is locked.\\n    function governanceIsLocked() external view override returns (bool) {\\n        return _locked;\\n    }\\n\\n    /***************************************\\n    MUTATOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Initiates transfer of the governance role to a new governor.\\n     * Transfer is not complete until the new governor accepts the role.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param pendingGovernance_ The new governor.\\n     */\\n    function setPendingGovernance(address pendingGovernance_) external override onlyGovernance {\\n        _pendingGovernance = pendingGovernance_;\\n        emit GovernancePending(pendingGovernance_);\\n    }\\n\\n    /**\\n     * @notice Accepts the governance role.\\n     * Can only be called by the pending governor.\\n     */\\n    function acceptGovernance() external override onlyPendingGovernance {\\n        // sanity check against transferring governance to the zero address\\n        // if someone figures out how to sign transactions from the zero address\\n        // consider the entirety of ethereum to be rekt\\n        require(_pendingGovernance != address(0x0), \\\"zero governance\\\");\\n        address oldGovernance = _governance;\\n        _governance = _pendingGovernance;\\n        _pendingGovernance = address(0x0);\\n        emit GovernanceTransferred(oldGovernance, _governance);\\n    }\\n\\n    /**\\n     * @notice Permanently locks this contract's governance role and any of its functions that require the role.\\n     * This action cannot be reversed.\\n     * Before you call it, ask yourself:\\n     *   - Is the contract self-sustaining?\\n     *   - Is there a chance you will need governance privileges in the future?\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     */\\n    function lockGovernance() external override onlyGovernance {\\n        _locked = true;\\n        // intentionally not using address(0x0), see re-initialization exploit\\n        _governance = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n        _pendingGovernance = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n        emit GovernanceTransferred(msg.sender, address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\\n        emit GovernanceLocked();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/utils/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n\\n/**\\n * @title IRegistry\\n * @author solace.fi\\n * @notice Tracks the contracts of the Solaverse.\\n *\\n * [**Governance**](/docs/protocol/governance) can set the contract addresses and anyone can look them up.\\n *\\n * A key is a unique identifier for each contract. Use [`get(key)`](#get) or [`tryGet(key)`](#tryget) to get the address of the contract. Enumerate the keys with [`length()`](#length) and [`getKey(index)`](#getkey).\\n */\\ninterface IRegistry {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a record is set.\\n    event RecordSet(string indexed key, address indexed value);\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice The number of unique keys.\\n    function length() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the `value` of a given `key`.\\n     * Reverts if the key is not in the mapping.\\n     * @param key The key to query.\\n     * @param value The value of the key.\\n     */\\n    function get(string calldata key) external view returns (address value);\\n\\n    /**\\n     * @notice Gets the `value` of a given `key`.\\n     * Fails gracefully if the key is not in the mapping.\\n     * @param key The key to query.\\n     * @param success True if the key was found, false otherwise.\\n     * @param value The value of the key or zero if it was not found.\\n     */\\n    function tryGet(string calldata key) external view returns (bool success, address value);\\n\\n    /**\\n     * @notice Gets the `key` of a given `index`.\\n     * @dev Iterable [1,length].\\n     * @param index The index to query.\\n     * @return key The key at that index.\\n     */\\n    function getKey(uint256 index) external view returns (string memory key);\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Sets keys and values.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param keys The keys to set.\\n     * @param values The values to set.\\n     */\\n    function set(string[] calldata keys, address[] calldata values) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/risk/IRiskManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n\\n/**\\n * @title IRiskManager\\n * @author solace.fi\\n * @notice Calculates the acceptable risk, sellable cover, and capital requirements of Solace products and capital pool.\\n *\\n * The total amount of sellable coverage is proportional to the assets in the [**risk backing capital pool**](../Vault). The max cover is split amongst products in a weighting system. [**Governance**](/docs/protocol/governance). can change these weights and with it each product's sellable cover.\\n *\\n * The minimum capital requirement is proportional to the amount of cover sold to [active policies](../PolicyManager).\\n *\\n * Solace can use leverage to sell more cover than the available capital. The amount of leverage is stored as [`partialReservesFactor`](#partialreservesfactor) and is settable by [**governance**](/docs/protocol/governance).\\n */\\ninterface IRiskManager {\\n\\n    /***************************************\\n    TYPE DEFINITIONS\\n    ***************************************/\\n\\n    enum StrategyStatus {\\n       INACTIVE,\\n       ACTIVE\\n    }\\n\\n    struct Strategy {\\n        uint256 id;\\n        uint32 weight;\\n        StrategyStatus status;\\n        uint256 timestamp;\\n    }\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when new strategy is created.\\n    event StrategyAdded(address strategy);\\n\\n    /// @notice Emitted when strategy status is updated.\\n    event StrategyStatusUpdated(address strategy, uint8 status);\\n\\n    /// @notice Emitted when strategy's allocation weight is increased.\\n    event RiskStrategyWeightAllocationIncreased(address strategy, uint32 weight);\\n\\n    /// @notice Emitted when strategy's allocation weight is decreased.\\n    event RiskStrategyWeightAllocationDecreased(address strategy, uint32 weight);\\n\\n    /// @notice Emitted when strategy's allocation weight is set.\\n    event RiskStrategyWeightAllocationSet(address strategy, uint32 weight);\\n\\n    /// @notice Emitted when the partial reserves factor is set.\\n    event PartialReservesFactorSet(uint16 partialReservesFactor);\\n\\n    /// @notice Emitted when the cover limit amount of the strategy is updated.\\n    event ActiveCoverLimitUpdated(address strategy, uint256 oldCoverLimit, uint256 newCoverLimit);\\n\\n    /// @notice Emitted when the cover limit updater is set.\\n    event CoverLimitUpdaterAdded(address updater);\\n\\n    /// @notice Emitted when the cover limit updater is removed.\\n    event CoverLimitUpdaterDeleted(address updater);\\n\\n    /***************************************\\n    RISK MANAGER MUTUTATOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Adds a new `Risk Strategy` to the `Risk Manager`. The community votes the strategy for coverage weight allocation.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param strategy_ The address of the risk strategy.\\n     * @return index The index of the risk strategy.\\n    */\\n    function addRiskStrategy(address strategy_) external returns (uint256 index);\\n\\n    /**\\n     * @notice Sets the weight of the `Risk Strategy`.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param strategy_ The address of the risk strategy.\\n     * @param weight_ The value to set.\\n    */\\n    function setWeightAllocation(address strategy_, uint32 weight_) external;\\n\\n    /**\\n     * @notice Sets the status of the `Risk Strategy`.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param strategy_ The address of the risk strategy.\\n     * @param status_ The status to set.\\n    */\\n    function setStrategyStatus(address strategy_, uint8 status_) external;\\n\\n   /**\\n     * @notice Updates the active cover limit amount for the given strategy. \\n     * This function is only called by valid requesters when a new policy is bought or updated.\\n     * @dev The policy manager and soteria will call this function for now.\\n     * @param strategy The strategy address to add cover limit.\\n     * @param currentCoverLimit The current cover limit amount of the strategy's product.\\n     * @param newCoverLimit The new cover limit amount of the strategy's product.\\n    */\\n    function updateActiveCoverLimitForStrategy(address strategy, uint256 currentCoverLimit, uint256 newCoverLimit) external;\\n\\n    /**\\n     * @notice Adds new address to allow updating cover limit amounts.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param updater The address that can update cover limit.\\n    */\\n    function addCoverLimitUpdater(address updater) external ;\\n\\n    /**\\n     * @notice Removes the cover limit updater.\\n     * @param updater The address of updater to remove.\\n    */\\n    function removeCoverLimitUpdater(address updater) external;\\n\\n    /***************************************\\n    RISK MANAGER VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Checks is an address is an active strategy.\\n     * @param strategy_ The risk strategy.\\n     * @return status True if the strategy is active.\\n    */\\n    function strategyIsActive(address strategy_) external view returns (bool status);\\n\\n     /**\\n      * @notice Return the strategy at an index.\\n      * @dev Enumerable `[1, numStrategies]`.\\n      * @param index_ Index to query.\\n      * @return strategy The product address.\\n    */\\n    function strategyAt(uint256 index_) external view returns (address strategy);\\n\\n    /**\\n     * @notice Returns the number of registered strategies..\\n     * @return count The number of strategies.\\n    */\\n    function numStrategies() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Returns the risk strategy information.\\n     * @param strategy_ The risk strategy.\\n     * @return id The id of the risk strategy.\\n     * @return weight The risk strategy weight allocation.\\n     * @return status The status of risk strategy.\\n     * @return timestamp The added time of the risk strategy.\\n     *\\n    */\\n    function strategyInfo(address strategy_) external view returns (uint256 id, uint32 weight, StrategyStatus status, uint256 timestamp);\\n\\n    /**\\n     * @notice Returns the allocated weight for the risk strategy.\\n     * @param strategy_ The risk strategy.\\n     * @return weight The risk strategy weight allocation.\\n    */\\n    function weightPerStrategy(address strategy_) external view returns (uint32 weight);\\n\\n    /**\\n     * @notice The maximum amount of cover for given strategy can sell.\\n     * @return cover The max amount of cover in wei.\\n     */\\n    function maxCoverPerStrategy(address strategy_) external view returns (uint256 cover);\\n\\n    /**\\n     * @notice Returns the current amount covered (in wei).\\n     * @return amount The covered amount (in wei).\\n    */\\n    function activeCoverLimit() external view returns (uint256 amount);\\n\\n    /**\\n     * @notice Returns the current amount covered (in wei).\\n     * @param riskStrategy The risk strategy address.\\n     * @return amount The covered amount (in wei).\\n    */\\n    function activeCoverLimitPerStrategy(address riskStrategy) external view returns (uint256 amount);\\n\\n    /***************************************\\n    MAX COVER VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice The maximum amount of cover that Solace as a whole can sell.\\n     * @return cover The max amount of cover in wei.\\n     */\\n    function maxCover() external view returns (uint256 cover);\\n\\n    /**\\n     * @notice Returns the sum of allocation weights for all strategies.\\n     * @return sum WeightSum.\\n     */\\n    function weightSum() external view returns (uint32 sum);\\n\\n    /***************************************\\n    MIN CAPITAL VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice The minimum amount of capital required to safely cover all policies.\\n     * @return mcr The minimum capital requirement.\\n     */\\n    function minCapitalRequirement() external view returns (uint256 mcr);\\n\\n    /**\\n     * @notice The minimum amount of capital required to safely cover all policies.\\n     * @param strategy_ The risk strategy.\\n     * @return mcr The minimum capital requirement.\\n     */\\n    function minCapitalRequirementPerStrategy(address strategy_) external view returns (uint256 mcr);\\n\\n    /**\\n     * @notice Multiplier for minimum capital requirement.\\n     * @return factor Partial reserves factor in BPS.\\n     */\\n    function partialReservesFactor() external view returns (uint16 factor);\\n\\n    /**\\n     * @notice Sets the partial reserves factor.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param partialReservesFactor_ New partial reserves factor in BPS.\\n     */\\n    function setPartialReservesFactor(uint16 partialReservesFactor_) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/products/ISolaceCoverProduct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ISolaceCoverProduct {\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a new Policy is created.\\n    event PolicyCreated(uint256 policyID);\\n\\n    /// @notice Emitted when a Policy is updated.\\n    event PolicyUpdated(uint256 policyID);\\n\\n    /// @notice Emitted when a Policy is deactivated.\\n    event PolicyDeactivated(uint256 policyID);\\n\\n    /// @notice Emitted when Registry address is updated.\\n    event RegistrySet(address registry);\\n\\n    /// @notice Emitted when pause is set.\\n    event PauseSet(bool pause);\\n\\n    /// @notice Emitted when a user enters cooldown mode.\\n    event CooldownStarted(address policyholder, uint256 startTime);\\n\\n    /// @notice Emitted when a user leaves cooldown mode.\\n    event CooldownStopped(address policyholder);\\n\\n    /// @notice Emitted when the cooldown period is set.\\n    event CooldownPeriodSet(uint256 cooldownPeriod);\\n\\n    /// @notice Emitted when a deposit is made.\\n    event DepositMade(\\n        address from,\\n        address policyholder,\\n        uint256 amount\\n    );\\n\\n    /// @notice Emitted when a withdraw is made.\\n    event WithdrawMade(address policyholder, uint256 amount);\\n\\n    /// @notice Emitted when premium is charged.\\n    event PremiumCharged(address policyholder, uint256 amount);\\n\\n    /// @notice Emitted when premium is partially charged.\\n    event PremiumPartiallyCharged(\\n        address policyholder,\\n        uint256 actualPremium,\\n        uint256 chargedPremium\\n    );\\n\\n    /// @notice Emitted when policy manager cover amount for soteria is updated.\\n    event PolicyManagerUpdated(uint256 activeCoverLimit);\\n\\n    /// @notice Emitted when maxRateNum is set.\\n    event MaxRateNumSet(uint256 maxRateNum);\\n\\n    /// @notice Emitted when maxRateDenom is set.\\n    event MaxRateDenomSet(uint256 maxRateDenom);\\n\\n    /// @notice Emitted when chargeCycle is set.\\n    event ChargeCycleSet(uint256 chargeCycle);\\n\\n    /// @notice Emitted when reward points are set.\\n    event RewardPointsSet(address policyholder, uint256 amountGifted);\\n\\n    /// @notice Emitted when isReferralOn is set\\n    event IsReferralOnSet(bool isReferralOn);\\n\\n    /// @notice Emitted when referralReward is set.\\n    event ReferralRewardSet(uint256 referralReward);\\n\\n    /// @notice Emitted when referral rewards are earned;\\n    event ReferralRewardsEarned(\\n        address rewardEarner,\\n        uint256 rewardPointsEarned\\n    );\\n\\n    /// @notice Emitted when baseURI is set\\n    event BaseURISet(string baseURI);\\n\\n    /***************************************\\n    POLICY FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Activates policy for `policyholder_`\\n     * @param policyholder_ The address of the intended policyholder.\\n     * @param coverLimit_ The maximum value to cover in **USD**.\\n     * @param amount_ The deposit amount in **USD** to fund the policyholder's account.\\n     * @param referralCode_ The referral code.\\n     * @return policyID The ID of the newly minted policy.\\n     */\\n    function activatePolicy(\\n        address policyholder_,\\n        uint256 coverLimit_,\\n        uint256 amount_,\\n        bytes calldata referralCode_\\n    ) external returns (uint256 policyID);\\n\\n    /**\\n     * @notice Updates the cover limit of a user's policy.\\n     *\\n     * This will reset the cooldown.\\n     * @param newCoverLimit_ The new maximum value to cover in **USD**.\\n     * @param referralCode_ The referral code.\\n     */\\n    function updateCoverLimit(\\n        uint256 newCoverLimit_, \\n        bytes calldata referralCode_\\n    ) external;\\n\\n    /**\\n     * @notice Deposits funds into `policyholder`'s account.\\n     * @param policyholder The policyholder.\\n     * @param amount The amount to deposit in **USD**.\\n     */\\n    function deposit(\\n        address policyholder,\\n        uint256 amount\\n    ) external;\\n\\n\\n    /**\\n     * @notice Withdraw funds from user's account.\\n     *\\n     * @notice If cooldown has passed, the user will withdraw their entire account balance. \\n     * @notice If cooldown has not started, or has not passed, the user will not be able to withdraw their entire account. \\n     * @notice If cooldown has not passed, [`withdraw()`](#withdraw) will leave a minimum required account balance (one epoch's fee) in the user's account.\\n     */\\n    function withdraw() external;\\n\\n    /**\\n     * @notice Deactivate a user's policy.\\n     * \\n     * This will set a user's cover limit to 0, and begin the cooldown timer. Read comments for [`withdraw()`](#withdraw) for cooldown mechanic details.\\n     */\\n    function deactivatePolicy() external;\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Returns the policyholder's account account balance in **USD**.\\n     * @param policyholder The policyholder address.\\n     * @return balance The policyholder's account balance in **USD**.\\n     */\\n    function accountBalanceOf(address policyholder) external view returns (uint256 balance);\\n\\n    /**\\n     * @notice The maximum amount of cover that can be sold in **USD** to 18 decimals places.\\n     * @return cover The max amount of cover.\\n     */\\n    function maxCover() external view returns (uint256 cover);\\n\\n    /**\\n     * @notice Returns the active cover limit in **USD** to 18 decimal places. In other words, the total cover that has been sold at the current time.\\n     * @return amount The active cover limit.\\n     */\\n    function activeCoverLimit() external view returns (uint256 amount);\\n\\n    /**\\n     * @notice Determine the available remaining capacity for new cover.\\n     * @return availableCoverCapacity_ The amount of available remaining capacity for new cover.\\n     */\\n    function availableCoverCapacity() external view returns (uint256 availableCoverCapacity_);\\n\\n    /**\\n     * @notice Get the reward points that a policyholder has in **USD** to 18 decimal places.\\n     * @param policyholder_ The policyholder address.\\n     * @return rewardPoints_ The reward points for the policyholder.\\n     */\\n    function rewardPointsOf(address policyholder_) external view returns (uint256 rewardPoints_);\\n\\n    /**\\n     * @notice Gets the policyholder's policy ID.\\n     * @param policyholder_ The address of the policyholder.\\n     * @return policyID The policy ID.\\n     */\\n    function policyOf(address policyholder_) external view returns (uint256 policyID);\\n\\n    /**\\n     * @notice Returns true if the policy is active, false if inactive\\n     * @param policyID_ The policy ID.\\n     * @return status True if policy is active. False otherwise.\\n     */\\n    function policyStatus(uint256 policyID_) external view returns (bool status);\\n\\n    /**\\n     * @notice Returns  [`Registry`](./Registry) contract address.\\n     * @return registry_ The `Registry` address.\\n     */\\n    function registry() external view returns (address registry_);\\n\\n    /**\\n     * @notice Returns [`RiskManager`](./RiskManager) contract address.\\n     * @return riskManager_ The `RiskManager` address.\\n     */\\n    function riskManager() external view returns (address riskManager_);\\n\\n    /**\\n     * @notice Returns true if the product is paused, false if not.\\n     * @return status True if product is paused.\\n     */\\n    function paused() external view returns (bool status);\\n\\n    /**\\n     * @notice Gets the policy count (amount of policies that have been purchased, includes inactive policies).\\n     * @return count The policy count.\\n     */\\n    function policyCount() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Returns the max rate numerator.\\n     * @return maxRateNum_ the max rate numerator.\\n     */\\n    function maxRateNum() external view returns (uint256 maxRateNum_);\\n\\n    /**\\n     * @notice Returns the max rate denominator.\\n     * @return maxRateDenom_ the max rate denominator.\\n     */\\n    function maxRateDenom() external view returns (uint256 maxRateDenom_);\\n\\n    /**\\n     * @notice Gets the charge cycle duration.\\n     * @return chargeCycle_ the charge cycle duration in seconds.\\n     */\\n    function chargeCycle() external view returns (uint256 chargeCycle_);\\n\\n    /**\\n     * @notice Gets cover limit for a given policy ID.\\n     * @param policyID_ The policy ID.\\n     * @return amount The cover limit for given policy ID.\\n     */\\n    function coverLimitOf(uint256 policyID_) external view returns (uint256 amount);\\n\\n    /**\\n     * @notice Gets the cooldown period.\\n     *\\n     * Cooldown timer is started by the user calling deactivatePolicy().\\n     * Before the cooldown has started or has passed, withdrawing funds will leave a minimim required account balance in the user's account. \\n     * Only after the cooldown has passed, is a user able to withdraw their entire account balance.\\n     * @return cooldownPeriod_ The cooldown period in seconds.\\n     */\\n    function cooldownPeriod() external view returns (uint256 cooldownPeriod_);\\n\\n    /**\\n     * @notice The Unix timestamp that a policyholder's cooldown started. If cooldown has not started or has been reset, will return 0.\\n     * @param policyholder_ The policyholder address\\n     * @return cooldownStart_ The cooldown period start expressed as Unix timestamp\\n     */\\n    function cooldownStart(address policyholder_) external view returns (uint256 cooldownStart_);\\n\\n    /**\\n     * @notice Gets the referral reward\\n     * @return referralReward_ The referral reward\\n     */\\n    function referralReward() external view returns (uint256 referralReward_);\\n\\n    /**\\n     * @notice Returns true if referral rewards are active, false if not.\\n     * @return isReferralOn_ True if referral rewards are active, false if not.\\n     */\\n    function isReferralOn() external view returns (bool isReferralOn_);\\n\\n    /**\\n     * @notice True if a policyholder has previously used a valid referral code, false if not\\n     * \\n     * A policyholder can only use a referral code once. Afterwards a policyholder is ineligible to receive further rewards from additional referral codes.\\n     * @return isReferralCodeUsed_ True if the policyholder has previously used a valid referral code, false if not\\n     */\\n    function isReferralCodeUsed(address policyholder) external view returns (bool isReferralCodeUsed_);\\n\\n    /**\\n     * @notice Returns true if valid referral code, false otherwise.\\n     * @param referralCode The referral code.\\n     */\\n    function isReferralCodeValid(bytes calldata referralCode) external view returns (bool);\\n\\n    /**\\n     * @notice Get referrer from referral code, returns 0 address if invalid referral code.\\n     * @param referralCode The referral code.\\n     * @return referrer The referrer address, returns 0 address if invalid referral code.\\n     */\\n    function getReferrerFromReferralCode(bytes calldata referralCode) external view returns (address referrer);\\n    /**\\n     * @notice Calculate minimum required account balance for a given cover limit. Equals the maximum chargeable fee for one epoch.\\n     * @param coverLimit Cover limit.\\n     */\\n    function minRequiredAccountBalance(uint256 coverLimit) external view returns (uint256 minRequiredAccountBalance_);\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Sets the [`Registry`](./Registry) contract address.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param registry_ The address of `Registry` contract.\\n     */\\n    function setRegistry(address registry_) external;\\n\\n    /**\\n     * @notice Pauses or unpauses policies.\\n     * Deactivating policies are unaffected by pause.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param paused_ True to pause, false to unpause.\\n     */\\n    function setPaused(bool paused_) external;\\n\\n    /**\\n     * @notice Sets the cooldown period. Read comments for [`cooldownPeriod()`](#cooldownPeriod) for more information on the cooldown mechanic.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param cooldownPeriod_ Cooldown period in seconds.\\n     */\\n    function setCooldownPeriod(uint256 cooldownPeriod_) external;\\n\\n    /**\\n     * @notice set _maxRateNum.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param maxRateNum_ Desired maxRateNum.\\n     */\\n    function setMaxRateNum(uint256 maxRateNum_) external;\\n\\n    /**\\n     * @notice set _maxRateDenom.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param maxRateDenom_ Desired maxRateDenom.\\n     */\\n    function setMaxRateDenom(uint256 maxRateDenom_) external;\\n\\n    /**\\n     * @notice set _chargeCycle.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param chargeCycle_ Desired chargeCycle.\\n     */\\n    function setChargeCycle(uint256 chargeCycle_) external;\\n\\n    /**\\n     * @notice set _referralReward\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param referralReward_ Desired referralReward.\\n    */\\n    function setReferralReward(uint256 referralReward_) external;\\n\\n    /**\\n     * @notice set _isReferralOn\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param isReferralOn_ Desired state of referral campaign.\\n    */\\n    function setIsReferralOn(bool isReferralOn_) external;\\n\\n    /**\\n     * @notice Sets the base URI for computing `tokenURI`.\\n     * @param baseURI_ The new base URI.\\n     */\\n    function setBaseURI(string memory baseURI_) external;\\n\\n    /***************************************\\n    COVER PROMOTION ADMIN FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Enables cover promotion admin to set reward points for a selected address.\\n     * \\n     * Can only be called by the **Cover Promotion Admin** role.\\n     * @param policyholder_ The address of the policyholder to set reward points for.\\n     * @param rewardPoints_ Desired amount of reward points.\\n     */\\n    function setRewardPoints(\\n        address policyholder_, \\n        uint256 rewardPoints_\\n    ) external;\\n\\n    /***************************************\\n    PREMIUM COLLECTOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Charge premiums for each policy holder.\\n     *\\n     * Can only be called by the **Premium Collector** role.\\n     * @dev Cheaper to load variables directly from calldata, rather than adding an additional operation of copying to memory.\\n     * @param holders Array of addresses of the policyholders to charge.\\n     * @param premiums Array of premium amounts (in **USD** to 18 decimal places) to charge each policyholder.\\n     */\\n    function chargePremiums(\\n        address[] calldata holders,\\n        uint256[] calldata premiums\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/utils/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title IGovernable\\n * @author solace.fi\\n * @notice Enforces access control for important functions to [**governor**](/docs/protocol/governance).\\n *\\n * Many contracts contain functionality that should only be accessible to a privileged user. The most common access control pattern is [OpenZeppelin's `Ownable`](https://docs.openzeppelin.com/contracts/4.x/access-control#ownership-and-ownable). We instead use `Governable` with a few key differences:\\n * - Transferring the governance role is a two step process. The current governance must [`setPendingGovernance(pendingGovernance_)`](#setpendinggovernance) then the new governance must [`acceptGovernance()`](#acceptgovernance). This is to safeguard against accidentally setting ownership to the wrong address and locking yourself out of your contract.\\n * - `governance` is a constructor argument instead of `msg.sender`. This is especially useful when deploying contracts via a [`SingletonFactory`](./ISingletonFactory).\\n * - We use `lockGovernance()` instead of `renounceOwnership()`. `renounceOwnership()` is a prerequisite for the reinitialization bug because it sets `owner = address(0x0)`. We also use the `governanceIsLocked()` flag.\\n */\\ninterface IGovernable {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when pending Governance is set.\\n    event GovernancePending(address pendingGovernance);\\n    /// @notice Emitted when Governance is set.\\n    event GovernanceTransferred(address oldGovernance, address newGovernance);\\n    /// @notice Emitted when Governance is locked.\\n    event GovernanceLocked();\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Address of the current governor.\\n    function governance() external view returns (address);\\n\\n    /// @notice Address of the governor to take over.\\n    function pendingGovernance() external view returns (address);\\n\\n    /// @notice Returns true if governance is locked.\\n    function governanceIsLocked() external view returns (bool);\\n\\n    /***************************************\\n    MUTATORS\\n    ***************************************/\\n\\n    /**\\n     * @notice Initiates transfer of the governance role to a new governor.\\n     * Transfer is not complete until the new governor accepts the role.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param pendingGovernance_ The new governor.\\n     */\\n    function setPendingGovernance(address pendingGovernance_) external;\\n\\n    /**\\n     * @notice Accepts the governance role.\\n     * Can only be called by the new governor.\\n     */\\n    function acceptGovernance() external;\\n\\n    /**\\n     * @notice Permanently locks this contract's governance role and any of its functions that require the role.\\n     * This action cannot be reversed.\\n     * Before you call it, ask yourself:\\n     *   - Is the contract self-sustaining?\\n     *   - Is there a chance you will need governance privileges in the future?\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     */\\n    function lockGovernance() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registry_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"domain_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"BaseURISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chargeCycle\",\"type\":\"uint256\"}],\"name\":\"ChargeCycleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cooldownPeriod\",\"type\":\"uint256\"}],\"name\":\"CooldownPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"CooldownStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"}],\"name\":\"CooldownStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"GovernanceLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingGovernance\",\"type\":\"address\"}],\"name\":\"GovernancePending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isReferralOn\",\"type\":\"bool\"}],\"name\":\"IsReferralOnSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxRateDenom\",\"type\":\"uint256\"}],\"name\":\"MaxRateDenomSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxRateNum\",\"type\":\"uint256\"}],\"name\":\"MaxRateNumSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"pause\",\"type\":\"bool\"}],\"name\":\"PauseSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"name\":\"PolicyCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"name\":\"PolicyDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"activeCoverLimit\",\"type\":\"uint256\"}],\"name\":\"PolicyManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"name\":\"PolicyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PremiumCharged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualPremium\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chargedPremium\",\"type\":\"uint256\"}],\"name\":\"PremiumPartiallyCharged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralReward\",\"type\":\"uint256\"}],\"name\":\"ReferralRewardSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardEarner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPointsEarned\",\"type\":\"uint256\"}],\"name\":\"ReferralRewardsEarned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"RegistrySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountGifted\",\"type\":\"uint256\"}],\"name\":\"RewardPointsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawMade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"}],\"name\":\"accountBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyholder_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"coverLimit_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"referralCode_\",\"type\":\"bytes\"}],\"name\":\"activatePolicy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeCoverLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableCoverCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"availableCoverCapacity_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chargeCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chargeCycle_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"premiums\",\"type\":\"uint256[]\"}],\"name\":\"chargePremiums\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cooldownPeriod_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyholder_\",\"type\":\"address\"}],\"name\":\"cooldownStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cooldownStart_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID_\",\"type\":\"uint256\"}],\"name\":\"coverLimitOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivatePolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"referralCode\",\"type\":\"bytes\"}],\"name\":\"getReferrerFromReferralCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceIsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"}],\"name\":\"isReferralCodeUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isReferralCodeUsed_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"referralCode\",\"type\":\"bytes\"}],\"name\":\"isReferralCodeValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReferralOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isReferralOn_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxCover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cover\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRateDenom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxRateDenom_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRateNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxRateNum_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverLimit\",\"type\":\"uint256\"}],\"name\":\"minRequiredAccountBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minRequiredAccountBalance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyholder_\",\"type\":\"address\"}],\"name\":\"policyOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID_\",\"type\":\"uint256\"}],\"name\":\"policyStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referralReward_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"registry_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyholder_\",\"type\":\"address\"}],\"name\":\"rewardPointsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardPoints_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riskManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"riskManager_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chargeCycle_\",\"type\":\"uint256\"}],\"name\":\"setChargeCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cooldownPeriod_\",\"type\":\"uint256\"}],\"name\":\"setCooldownPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isReferralOn_\",\"type\":\"bool\"}],\"name\":\"setIsReferralOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxRateDenom_\",\"type\":\"uint256\"}],\"name\":\"setMaxRateDenom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxRateNum_\",\"type\":\"uint256\"}],\"name\":\"setMaxRateNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingGovernance_\",\"type\":\"address\"}],\"name\":\"setPendingGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"referralReward_\",\"type\":\"uint256\"}],\"name\":\"setReferralReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry_\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyholder_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardPoints_\",\"type\":\"uint256\"}],\"name\":\"setRewardPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tokenURI_\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCoverLimit_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"referralCode_\",\"type\":\"bytes\"}],\"name\":\"updateCoverLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SolaceCoverProduct", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000501ace0e8d16b92236763e2ded7ae3bc2dffa276000000000000000000000000501ace0f576fc4ef9c0380aa46a578ea96b85776000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001c536f6c6163652e66692d536f6c616365436f76657250726f647563740000000000000000000000000000000000000000000000000000000000000000000000013100000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}