{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma experimental ABIEncoderV2;\r\npragma solidity 0.6.11;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  //not actually in AggregatorV3Interface but implemented by said contracts\r\n  function latestTimestamp() external view returns (uint256);\r\n}\r\n\r\ncontract BaseMath {\r\n    uint constant public DECIMAL_PRECISION = 1e18;\r\n}\r\n\r\n\r\ncontract CheckContract {\r\n    /**\r\n     * Check that the account is an already deployed non-destroyed contract.\r\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\r\n     */\r\n    function checkContract(address _account) internal view {\r\n        require(_account != address(0), \"Account cannot be zero address\");\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(_account) }\r\n        require(size > 0, \"Account code size cannot be zero\");\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    \r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC2612 {\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(address owner, address spender, uint256 amount, \r\n                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    \r\n    /**\r\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     *\r\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to \r\n     * a value in the near future. The deadline argument can be set to uint(-1) to \r\n     * create Permits that effectively never expire.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n    \r\n    function version() external view returns (string memory);\r\n    function permitTypeHash() external view returns (bytes32);\r\n    function domainSeparator() external view returns (bytes32);\r\n}\r\n\r\n\r\ninterface ITellor {\r\n    /**\r\n     * @dev Helps initialize a dispute by assigning it a disputeId\r\n     * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\r\n     * invalidated value information to POS voting\r\n     * @param _requestId being disputed\r\n     * @param _timestamp being disputed\r\n     * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\r\n     * requires 5 miners to submit a value.\r\n     */\r\n    function beginDispute(\r\n        uint256 _requestId,\r\n        uint256 _timestamp,\r\n        uint256 _minerIndex\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows token holders to vote\r\n     * @param _disputeId is the dispute id\r\n     * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\r\n     */\r\n    function vote(uint256 _disputeId, bool _supportsDispute) external;\r\n\r\n    /**\r\n     * @dev tallies the votes.\r\n     * @param _disputeId is the dispute id\r\n     */\r\n    function tallyVotes(uint256 _disputeId) external;\r\n\r\n    /**\r\n     * @dev Allows for a fork to be proposed\r\n     * @param _propNewTellorAddress address for new proposed Tellor\r\n     */\r\n    function proposeFork(address _propNewTellorAddress) external;\r\n\r\n    /**\r\n     * @dev Add tip to Request value from oracle\r\n     * @param _requestId being requested to be mined\r\n     * @param _tip amount the requester is willing to pay to be get on queue. Miners\r\n     * mine the onDeckQueryHash, or the api with the highest payout pool\r\n     */\r\n    function addTip(uint256 _requestId, uint256 _tip) external;\r\n\r\n    /**\r\n     * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\r\n     * @param _nonce uint submitted by miner\r\n     * @param _requestId the apiId being mined\r\n     * @param _value of api query\r\n     *\r\n     */\r\n    function submitMiningSolution(\r\n        string calldata _nonce,\r\n        uint256 _requestId,\r\n        uint256 _value\r\n    ) external;\r\n\r\n    /**\r\n     * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\r\n     * @param _nonce uint submitted by miner\r\n     * @param _requestId is the array of the 5 PSR's being mined\r\n     * @param _value is an array of 5 values\r\n     */\r\n    function submitMiningSolution(\r\n        string calldata _nonce,\r\n        uint256[5] calldata _requestId,\r\n        uint256[5] calldata _value\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows the current owner to propose transfer control of the contract to a\r\n     * newOwner and the ownership is pending until the new owner calls the claimOwnership\r\n     * function\r\n     * @param _pendingOwner The address to transfer ownership to.\r\n     */\r\n    function proposeOwnership(address payable _pendingOwner) external;\r\n\r\n    /**\r\n     * @dev Allows the new owner to claim control of the contract\r\n     */\r\n    function claimOwnership() external;\r\n\r\n    /**\r\n     * @dev This function allows miners to deposit their stake.\r\n     */\r\n    function depositStake() external;\r\n\r\n    /**\r\n     * @dev This function allows stakers to request to withdraw their stake (no longer stake)\r\n     * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\r\n     * can withdraw the stake\r\n     */\r\n    function requestStakingWithdraw() external;\r\n\r\n    /**\r\n     * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\r\n     */\r\n    function withdrawStake() external;\r\n\r\n    /**\r\n     * @dev This function approves a _spender an _amount of tokens to use\r\n     * @param _spender address\r\n     * @param _amount amount the spender is being approved for\r\n     * @return true if spender appproved successfully\r\n     */\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Allows for a transfer of tokens to _to\r\n     * @param _to The address to send tokens to\r\n     * @param _amount The amount of tokens to send\r\n     * @return true if transfer is successful\r\n     */\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sends _amount tokens to _to from _from on the condition it\r\n     * is approved by _from\r\n     * @param _from The address holding the tokens being transferred\r\n     * @param _to The address of the recipient\r\n     * @param _amount The amount of tokens to be transferred\r\n     * @return True if the transfer was successful\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Allows users to access the token's name\r\n     */\r\n    function name() external pure returns (string memory);\r\n\r\n    /**\r\n     * @dev Allows users to access the token's symbol\r\n     */\r\n    function symbol() external pure returns (string memory);\r\n\r\n    /**\r\n     * @dev Allows users to access the number of decimals\r\n     */\r\n    function decimals() external pure returns (uint8);\r\n\r\n    /**\r\n     * @dev Getter for the current variables that include the 5 requests Id's\r\n     * @return _challenge _requestIds _difficultky _tip the challenge, 5 requestsId, difficulty and tip\r\n     */\r\n    function getNewCurrentVariables()\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 _challenge,\r\n            uint256[5] memory _requestIds,\r\n            uint256 _difficutly,\r\n            uint256 _tip\r\n        );\r\n\r\n    /**\r\n     * @dev Getter for the top tipped 5 requests Id's\r\n     * @return _requestIds the 5 requestsId\r\n     */\r\n    function getTopRequestIDs()\r\n        external\r\n        view\r\n        returns (uint256[5] memory _requestIds);\r\n\r\n    /**\r\n     * @dev Getter for the 5 requests Id's next in line to get mined\r\n     * @return idsOnDeck tipsOnDeck  the 5 requestsId\r\n     */\r\n    function getNewVariablesOnDeck()\r\n        external\r\n        view\r\n        returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck);\r\n\r\n    /**\r\n     * @dev Updates the Tellor address after a proposed fork has\r\n     * passed the vote and day has gone by without a dispute\r\n     * @param _disputeId the disputeId for the proposed fork\r\n     */\r\n    function updateTellor(uint256 _disputeId) external;\r\n\r\n    /**\r\n     * @dev Allows disputer to unlock the dispute fee\r\n     * @param _disputeId to unlock fee from\r\n     */\r\n    function unlockDisputeFee(uint256 _disputeId) external;\r\n\r\n    /**\r\n     * @param _user address\r\n     * @param _spender address\r\n     * @return Returns the remaining allowance of tokens granted to the _spender from the _user\r\n     */\r\n    function allowance(address _user, address _spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev This function returns whether or not a given user is allowed to trade a given amount\r\n     * @param _user address\r\n     * @param _amount uint of amount\r\n     * @return true if the user is alloed to trade the amount specified\r\n     */\r\n    function allowedToTrade(address _user, uint256 _amount)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Gets balance of owner specified\r\n     * @param _user is the owner address used to look up the balance\r\n     * @return Returns the balance associated with the passed in _user\r\n     */\r\n    function balanceOf(address _user) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Queries the balance of _user at a specific _blockNumber\r\n     * @param _user The address from which the balance will be retrieved\r\n     * @param _blockNumber The block number when the balance is queried\r\n     * @return The balance at _blockNumber\r\n     */\r\n    function balanceOfAt(address _user, uint256 _blockNumber)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev This function tells you if a given challenge has been completed by a given miner\r\n     * @param _challenge the challenge to search for\r\n     * @param _miner address that you want to know if they solved the challenge\r\n     * @return true if the _miner address provided solved the\r\n     */\r\n    function didMine(bytes32 _challenge, address _miner)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Checks if an address voted in a given dispute\r\n     * @param _disputeId to look up\r\n     * @param _address to look up\r\n     * @return bool of whether or not party voted\r\n     */\r\n    function didVote(uint256 _disputeId, address _address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev allows Tellor to read data from the addressVars mapping\r\n     * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\r\n     * These are examples of how the variables are saved within other functions:\r\n     * addressVars[keccak256(\"_owner\")]\r\n     * addressVars[keccak256(\"tellorContract\")]\r\n     * return address\r\n     */\r\n    function getAddressVars(bytes32 _data) external view returns (address);\r\n\r\n    /**\r\n     * @dev Gets all dispute variables\r\n     * @param _disputeId to look up\r\n     * @return bytes32 hash of dispute\r\n     * @return bool executed where true if it has been voted on\r\n     * @return bool disputeVotePassed\r\n     * @return bool isPropFork true if the dispute is a proposed fork\r\n     * @return address of reportedMiner\r\n     * @return address of reportingParty\r\n     * @return address of proposedForkAddress\r\n     *    uint of requestId\r\n     *    uint of timestamp\r\n     *    uint of value\r\n     *    uint of minExecutionDate\r\n     *    uint of numberOfVotes\r\n     *    uint of blocknumber\r\n     *    uint of minerSlot\r\n     *    uint of quorum\r\n     *    uint of fee\r\n     * @return int count of the current tally\r\n     */\r\n    function getAllDisputeVars(uint256 _disputeId)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32,\r\n            bool,\r\n            bool,\r\n            bool,\r\n            address,\r\n            address,\r\n            address,\r\n            uint256[9] memory,\r\n            int256\r\n        );\r\n\r\n    /**\r\n     * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\r\n     * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\r\n     */\r\n    function getCurrentVariables()\r\n        external\r\n        view\r\n        returns (\r\n            bytes32,\r\n            uint256,\r\n            uint256,\r\n            string memory,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    /**\r\n     * @dev Checks if a given hash of miner,requestId has been disputed\r\n     * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\r\n     * @return uint disputeId\r\n     */\r\n    function getDisputeIdByDisputeHash(bytes32 _hash)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\r\n     * @param _disputeId is the dispute id;\r\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n     * the variables/strings used to save the data in the mapping. The variables names are\r\n     * commented out under the disputeUintVars under the Dispute struct\r\n     * @return uint value for the bytes32 data submitted\r\n     */\r\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Gets the a value for the latest timestamp available\r\n     * @return value for timestamp of last proof of work submited\r\n     * @return true if the is a timestamp for the lastNewValue\r\n     */\r\n    function getLastNewValue() external view returns (uint256, bool);\r\n\r\n    /**\r\n     * @dev Gets the a value for the latest timestamp available\r\n     * @param _requestId being requested\r\n     * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\r\n     */\r\n    function getLastNewValueById(uint256 _requestId)\r\n        external\r\n        view\r\n        returns (uint256, bool);\r\n\r\n    /**\r\n     * @dev Gets blocknumber for mined timestamp\r\n     * @param _requestId to look up\r\n     * @param _timestamp is the timestamp to look up blocknumber\r\n     * @return uint of the blocknumber which the dispute was mined\r\n     */\r\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n     * @param _requestId to look up\r\n     * @param _timestamp is the timestamp to look up miners for\r\n     * @return the 5 miners' addresses\r\n     */\r\n    function getMinersByRequestIdAndTimestamp(\r\n        uint256 _requestId,\r\n        uint256 _timestamp\r\n    ) external view returns (address[5] memory);\r\n\r\n    /**\r\n     * @dev Counts the number of values that have been submited for the request\r\n     * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\r\n     * request so far\r\n     * @param _requestId the requestId to look up\r\n     * @return uint count of the number of values received for the requestId\r\n     */\r\n    function getNewValueCountbyRequestId(uint256 _requestId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Getter function for the specified requestQ index\r\n     * @param _index to look up in the requestQ array\r\n     * @return uint of reqeuestId\r\n     */\r\n    function getRequestIdByRequestQIndex(uint256 _index)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Getter function for requestId based on timestamp\r\n     * @param _timestamp to check requestId\r\n     * @return uint of reqeuestId\r\n     */\r\n    function getRequestIdByTimestamp(uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Getter function for requestId based on the queryHash\r\n     * @param _request is the hash(of string api and granularity) to check if a request already exists\r\n     * @return uint requestId\r\n     */\r\n    function getRequestIdByQueryHash(bytes32 _request)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Getter function for the requestQ array\r\n     * @return the requestQ arrray\r\n     */\r\n    function getRequestQ() external view returns (uint256[51] memory);\r\n\r\n    /**\r\n     * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\r\n     * for the requestId specified\r\n     * @param _requestId to look up\r\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n     * the variables/strings used to save the data in the mapping. The variables names are\r\n     * commented out under the apiUintVars under the requestDetails struct\r\n     * @return uint value of the apiUintVars specified in _data for the requestId specified\r\n     */\r\n    function getRequestUintVars(uint256 _requestId, bytes32 _data)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Gets the API struct variables that are not mappings\r\n     * @param _requestId to look up\r\n     * @return string of api to query\r\n     * @return string of symbol of api to query\r\n     * @return bytes32 hash of string\r\n     * @return bytes32 of the granularity(decimal places) requested\r\n     * @return uint of index in requestQ array\r\n     * @return uint of current payout/tip for this requestId\r\n     */\r\n    function getRequestVars(uint256 _requestId)\r\n        external\r\n        view\r\n        returns (\r\n            string memory,\r\n            string memory,\r\n            bytes32,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    /**\r\n     * @dev This function allows users to retireve all information about a staker\r\n     * @param _staker address of staker inquiring about\r\n     * @return uint current state of staker\r\n     * @return uint startDate of staking\r\n     */\r\n    function getStakerInfo(address _staker)\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    /**\r\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n     * @param _requestId to look up\r\n     * @param _timestamp is the timestampt to look up miners for\r\n     * @return address[5] array of 5 addresses ofminers that mined the requestId\r\n     */\r\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (uint256[5] memory);\r\n\r\n    /**\r\n     * @dev Gets the timestamp for the value based on their index\r\n     * @param _requestID is the requestId to look up\r\n     * @param _index is the value index to look up\r\n     * @return uint timestamp\r\n     */\r\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\r\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n     * the variables/strings used to save the data in the mapping. The variables names are\r\n     * commented out under the uintVars under the TellorStorageStruct struct\r\n     * This is an example of how data is saved into the mapping within other functions:\r\n     * self.uintVars[keccak256(\"stakerCount\")]\r\n     * @return uint of specified variable\r\n     */\r\n    function getUintVar(bytes32 _data) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\r\n     * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\r\n     */\r\n    function getVariablesOnDeck()\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            string memory\r\n        );\r\n\r\n    /**\r\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n     * @param _requestId to look up\r\n     * @param _timestamp is the timestamp to look up miners for\r\n     * @return bool true if requestId/timestamp is under dispute\r\n     */\r\n    function isInDispute(uint256 _requestId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Retreive value from oracle based on timestamp\r\n     * @param _requestId being requested\r\n     * @param _timestamp to retreive data/value from\r\n     * @return value for timestamp submitted\r\n     */\r\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Getter for the total_supply of oracle tokens\r\n     * @return uint total supply\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n\r\nlibrary LiquityMath {\r\n    using SafeMath for uint;\r\n\r\n    uint internal constant DECIMAL_PRECISION = 1e18;\r\n\r\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\r\n     *\r\n     * - Making it \u201ctoo high\u201d could lead to overflows.\r\n     * - Making it \u201ctoo low\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division. \r\n     *\r\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\r\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\r\n     *\r\n     */\r\n    uint internal constant NICR_PRECISION = 1e20;\r\n\r\n    function _min(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a < _b) ? _a : _b;\r\n    }\r\n\r\n    function _max(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a >= _b) ? _a : _b;\r\n    }\r\n\r\n    /* \r\n    * Multiply two decimal numbers and use normal rounding rules:\r\n    * -round product up if 19'th mantissa digit >= 5\r\n    * -round product down if 19'th mantissa digit < 5\r\n    *\r\n    * Used only inside the exponentiation, _decPow().\r\n    */\r\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\r\n        uint prod_xy = x.mul(y);\r\n\r\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\r\n    }\r\n\r\n    /* \r\n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\r\n    * \r\n    * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity. \r\n    * \r\n    * Called by two functions that represent time in units of minutes:\r\n    * 1) TroveManager._calcDecayedBaseRate\r\n    * 2) CommunityIssuance._getCumulativeIssuanceFraction \r\n    * \r\n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\r\n    * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\r\n    * \r\n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\r\n    * negligibly different from just passing the cap, since: \r\n    *\r\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\r\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\r\n    */\r\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\r\n       \r\n        if (_minutes > 525600000) {_minutes = 525600000;}  // cap to avoid overflow\r\n    \r\n        if (_minutes == 0) {return DECIMAL_PRECISION;}\r\n\r\n        uint y = DECIMAL_PRECISION;\r\n        uint x = _base;\r\n        uint n = _minutes;\r\n\r\n        // Exponentiation-by-squaring\r\n        while (n > 1) {\r\n            if (n % 2 == 0) {\r\n                x = decMul(x, x);\r\n                n = n.div(2);\r\n            } else { // if (n % 2 != 0)\r\n                y = decMul(x, y);\r\n                x = decMul(x, x);\r\n                n = (n.sub(1)).div(2);\r\n            }\r\n        }\r\n\r\n        return decMul(x, y);\r\n  }\r\n\r\n    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\r\n    }\r\n\r\n    function _computeNominalCR(uint _coll, uint _debt) internal pure returns (uint) {\r\n        if (_debt > 0) {\r\n            return _coll.mul(NICR_PRECISION).div(_debt);\r\n        }\r\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\r\n        else { // if (_debt == 0)\r\n            return 2**256 - 1;\r\n        }\r\n    }\r\n\r\n    function _computeCR(uint _coll, uint _debt, uint _price) internal pure returns (uint) {\r\n        if (_debt > 0) {\r\n            uint newCollRatio = _coll.mul(_price).div(_debt);\r\n\r\n            return newCollRatio;\r\n        }\r\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\r\n        else { // if (_debt == 0)\r\n            return 2**256 - 1; \r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary LiquitySafeMath128 {\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        uint128 c = a + b;\r\n        require(c >= a, \"LiquitySafeMath128: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n   \r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        require(b <= a, \"LiquitySafeMath128: subtraction overflow\");\r\n        uint128 c = a - b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     *\r\n     * NOTE: This function is not safe, as it doesn\u2019t check owner is calling it.\r\n     * Make sure you check it before calling it.\r\n     */\r\n    function _renounceOwnership() internal {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n}\r\n\r\ninterface IBorrowerOperations {\r\n\r\n    // --- Events ---\r\n\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event RUBCAddressChanged(address _rubcAddress);\r\n    event RBSTStakingAddressChanged(address _rbstStakingAddress);\r\n\r\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\r\n    event RUBCBorrowingFeePaid(address indexed _borrower, uint _RUBCFee);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses(\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress,\r\n        address _defaultPoolAddress,\r\n        address _stabilityPoolAddress,\r\n        address _gasPoolAddress,\r\n        address _collSurplusPoolAddress,\r\n        address _priceFeedAddress,\r\n        address _sortedTrovesAddress,\r\n        address _rubcAddress,\r\n        address _rbstStakingAddress\r\n    ) external;\r\n\r\n    function openTrove(uint _maxFee, uint _RUBCAmount, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function addColl(address _upperHint, address _lowerHint) external payable;\r\n\r\n    function moveETHGainToTrove(address _user, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function withdrawColl(uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function withdrawRUBC(uint _maxFee, uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function repayRUBC(uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function closeTrove() external;\r\n\r\n    function adjustTrove(uint _maxFee, uint _collWithdrawal, uint _debtChange, bool isDebtIncrease, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function claimCollateral() external;\r\n\r\n    function getCompositeDebt(uint _debt) external pure returns (uint);\r\n}\r\n\r\ninterface ICollSurplusPool {\r\n\r\n    // --- Events ---\r\n    \r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n\r\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Contract setters ---\r\n\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress\r\n    ) external;\r\n\r\n    function getETH() external view returns (uint);\r\n\r\n    function getCollateral(address _account) external view returns (uint);\r\n\r\n    function accountSurplus(address _account, uint _amount) external;\r\n\r\n    function claimColl(address _account) external;\r\n}\r\n\r\ninterface ICommunityIssuance { \r\n    \r\n    // --- Events ---\r\n    \r\n    event RBSTAddressSet(address _rbstAddress);\r\n    event StabilityPoolAddressSet(address _stabilityPoolAddress);\r\n    event TotalRBSTIssuedUpdated(uint _totalRBSTIssued);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses(address _rbstAddress, address _stabilityPoolAddress) external;\r\n\r\n    function issueRBST() external returns (uint);\r\n\r\n    function sendRBST(address _account, uint _RBSTamount) external;\r\n}\r\n\r\ninterface ILockupContractFactory {\r\n    \r\n    // --- Events ---\r\n\r\n    event RBSTAddressSet(address _rbstAddress);\r\n    event LockupContractDeployedThroughFactory(address _lockupContractAddress, address _beneficiary, uint _unlockTime, address _deployer);\r\n\r\n    // --- Functions ---\r\n\r\n    function setRBSTAddress(address _rbstAddress) external;\r\n\r\n    function deployLockupContract(address _beneficiary, uint _unlockTime) external;\r\n\r\n    function isRegisteredLockup(address _addr) external view returns (bool);\r\n}\r\n\r\n// Common interface for the Pools.\r\ninterface IPool {\r\n    \r\n    // --- Events ---\r\n    \r\n    event ETHBalanceUpdated(uint _newBalance);\r\n    event RUBCBalanceUpdated(uint _newBalance);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n    \r\n    function getETH() external view returns (uint);\r\n\r\n    function getRUBCDebt() external view returns (uint);\r\n\r\n    function increaseRUBCDebt(uint _amount) external;\r\n\r\n    function decreaseRUBCDebt(uint _amount) external;\r\n}\r\n\r\ninterface IPriceFeed {\r\n\r\n    // --- Events ---\r\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\r\n   \r\n    // --- Function ---\r\n    function fetchPrice() external returns (uint);\r\n\r\n    function fetchRUBPriceFeedUpdateTimestamp() external returns(uint256);\r\n}\r\n\r\ninterface IRBST is IERC20, IERC2612 { \r\n   \r\n    // --- Events ---\r\n    \r\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\r\n    event RBSTStakingAddressSet(address _rbstStakingAddress);\r\n    event LockupContractFactoryAddressSet(address _lockupContractFactoryAddress);\r\n\r\n    // --- Functions ---\r\n    \r\n    function sendToRBSTStaking(address _sender, uint256 _amount) external;\r\n\r\n    function getDeploymentStartTime() external view returns (uint256);\r\n\r\n    function getLpRewardsEntitlement() external view returns (uint256);\r\n}\r\n\r\ninterface IRBSTStaking {\r\n\r\n    // --- Events --\r\n    \r\n    event RBSTAddressSet(address _rbstAddress);\r\n    event RUBCAddressSet(address _rubcAddress);\r\n    event TroveManagerAddressSet(address _troveManager);\r\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\r\n    event ActivePoolAddressSet(address _activePoolAddress);\r\n\r\n    event StakeChanged(address indexed staker, uint newStake);\r\n    event StakingGainsWithdrawn(address indexed staker, uint RUBCGain, uint ETHGain);\r\n    event F_ETHUpdated(uint _F_ETH);\r\n    event F_RUBCUpdated(uint _F_RUBC);\r\n    event TotalRBSTStakedUpdated(uint _totalRBSTStaked);\r\n    event EtherSent(address _account, uint _amount);\r\n    event StakerSnapshotsUpdated(address _staker, uint _F_ETH, uint _F_RUBC);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses\r\n    (\r\n        address _rbstAddress,\r\n        address _rubcAddress,\r\n        address _troveManagerAddress, \r\n        address _borrowerOperationsAddress,\r\n        address _activePoolAddress\r\n    )  external;\r\n\r\n    function stake(uint _RBSTamount) external;\r\n\r\n    function unstake(uint _RBSTamount) external;\r\n\r\n    function increaseF_ETH(uint _ETHFee) external; \r\n\r\n    function increaseF_RUBC(uint _RBSTFee) external;  \r\n\r\n    function getPendingETHGain(address _user) external view returns (uint);\r\n\r\n    function getPendingRUBCGain(address _user) external view returns (uint);\r\n}\r\n\r\ninterface IRUBC is IERC20, IERC2612 { \r\n    \r\n    // --- Events ---\r\n\r\n    event TroveManagerAddressChanged(address _troveManagerAddress);\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n\r\n    event RUBCBalanceUpdated(address _user, uint _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    function mint(address _account, uint256 _amount) external;\r\n\r\n    function burn(address _account, uint256 _amount) external;\r\n\r\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external;\r\n\r\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) external;\r\n}\r\n\r\ninterface ISortedTroves {\r\n\r\n    // --- Events ---\r\n    \r\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\r\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\r\n    event NodeAdded(address _id, uint _NICR);\r\n    event NodeRemoved(address _id);\r\n\r\n    // --- Functions ---\r\n    \r\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\r\n\r\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\r\n\r\n    function remove(address _id) external;\r\n\r\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\r\n\r\n    function contains(address _id) external view returns (bool);\r\n\r\n    function isFull() external view returns (bool);\r\n\r\n    function isEmpty() external view returns (bool);\r\n\r\n    function getSize() external view returns (uint256);\r\n\r\n    function getMaxSize() external view returns (uint256);\r\n\r\n    function getFirst() external view returns (address);\r\n\r\n    function getLast() external view returns (address);\r\n\r\n    function getNext(address _id) external view returns (address);\r\n\r\n    function getPrev(address _id) external view returns (address);\r\n\r\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\r\n\r\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\r\n}\r\n\r\ninterface IStabilityPool {\r\n\r\n    // --- Events ---\r\n    \r\n    event StabilityPoolETHBalanceUpdated(uint _newBalance);\r\n    event StabilityPoolRUBCBalanceUpdated(uint _newBalance);\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event RUBCAddressChanged(address _newRUBCAddress);\r\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\r\n\r\n    event P_Updated(uint _P);\r\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\r\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\r\n    event EpochUpdated(uint128 _currentEpoch);\r\n    event ScaleUpdated(uint128 _currentScale);\r\n\r\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\r\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\r\n\r\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\r\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\r\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\r\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\r\n\r\n    event ETHGainWithdrawn(address indexed _depositor, uint _ETH, uint _RUBCLoss);\r\n    event RBSTPaidToDepositor(address indexed _depositor, uint _RBST);\r\n    event RBSTPaidToFrontEnd(address indexed _frontEnd, uint _RBST);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    /*\r\n     * Called only once on init, to set addresses of other Liquity contracts\r\n     * Callable only by owner, renounces ownership at the end\r\n     */\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress,\r\n        address _rubcAddress,\r\n        address _sortedTrovesAddress,\r\n        address _priceFeedAddress,\r\n        address _communityIssuanceAddress\r\n    ) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend is registered or zero address\r\n     * - Sender is not a registered frontend\r\n     * - _amount is not zero\r\n     * ---\r\n     * - Triggers a RBST issuance, based on time passed since the last issuance. The RBST issuance is shared between *all* depositors and front ends\r\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\r\n     * - Sends depositor's accumulated gains (RBST, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated RBST gains to the tagged front end\r\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     */\r\n    function provideToSP(uint _amount, address _frontEndTag) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - _amount is zero or there are no under collateralized troves left in the system\r\n     * - User has a non zero deposit\r\n     * ---\r\n     * - Triggers a RBST issuance, based on time passed since the last issuance. The RBST issuance is shared between *all* depositors and front ends\r\n     * - Removes the deposit's front end tag if it is a full withdrawal\r\n     * - Sends all depositor's accumulated gains (RBST, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated RBST gains to the tagged front end\r\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     *\r\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\r\n     */\r\n    function withdrawFromSP(uint _amount) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - User has a non zero deposit\r\n     * - User has an open trove\r\n     * - User has some ETH gain\r\n     * ---\r\n     * - Triggers a RBST issuance, based on time passed since the last issuance. The RBST issuance is shared between *all* depositors and front ends\r\n     * - Sends all depositor's RBST gain to  depositor\r\n     * - Sends all tagged front end's RBST gain to the tagged front end\r\n     * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\r\n     * - Leaves their compounded deposit in the Stability Pool\r\n     * - Updates snapshots for deposit and tagged front end stake\r\n     */\r\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend (sender) not already registered\r\n     * - User (sender) has no deposit\r\n     * - _kickbackRate is in the range [0, 100%]\r\n     * ---\r\n     * Front end makes a one-time selection of kickback rate upon registering\r\n     */\r\n    function registerFrontEnd(uint _kickbackRate) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Caller is TroveManager\r\n     * ---\r\n     * Cancels out the specified debt against the RUBC contained in the Stability Pool (as far as possible)\r\n     * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\r\n     * Only called by liquidation functions in the TroveManager.\r\n     */\r\n    function offset(uint _debt, uint _coll) external;\r\n\r\n    /*\r\n     * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,\r\n     * to exclude edge cases like ETH received from a self-destruct.\r\n     */\r\n    function getETH() external view returns (uint);\r\n\r\n    /*\r\n     * Returns RUBC held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\r\n     */\r\n    function getTotalRUBCDeposits() external view returns (uint);\r\n\r\n    /*\r\n     * Calculates the ETH gain earned by the deposit since its last snapshots were taken.\r\n     */\r\n    function getDepositorETHGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Calculate the RBST gain earned by a deposit since its last snapshots were taken.\r\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\r\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\r\n     * which they made their deposit.\r\n     */\r\n    function getDepositorRBSTGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the RBST gain earned by the front end.\r\n     */\r\n    function getFrontEndRBSTGain(address _frontEnd) external view returns (uint);\r\n\r\n    /*\r\n     * Return the user's compounded deposit.\r\n     */\r\n    function getCompoundedRUBCDeposit(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the front end's compounded stake.\r\n     *\r\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\r\n     */\r\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\r\n\r\n    /*\r\n     * Fallback function\r\n     * Only callable by Active Pool, it just accounts for ETH received\r\n     * receive() external payable;\r\n     */\r\n}\r\n\r\ninterface ITellorCaller {\r\n    function getTellorCurrentValue(uint256 _requestId) external view returns (bool, uint256, uint256);\r\n}\r\n\r\ncontract TellorCaller is ITellorCaller {\r\n    using SafeMath for uint256;\r\n\r\n    ITellor public tellor;\r\n\r\n    constructor (address _tellorMasterAddress) public {\r\n        tellor = ITellor(_tellorMasterAddress);\r\n    }\r\n\r\n    /*\r\n    * getTellorCurrentValue(): identical to getCurrentValue() in UsingTellor.sol\r\n    *\r\n    * @dev Allows the user to get the latest value for the requestId specified\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @return ifRetrieve bool true if it is able to retrieve a value, the value, and the value's timestamp\r\n    * @return value the value retrieved\r\n    * @return _timestampRetrieved the value's timestamp\r\n    */\r\n    function getTellorCurrentValue(uint256 _requestId)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            bool ifRetrieve,\r\n            uint256 value,\r\n            uint256 _timestampRetrieved\r\n        )\r\n    {\r\n        uint256 _count = tellor.getNewValueCountbyRequestId(_requestId);\r\n        uint256 _time =\r\n            tellor.getTimestampbyRequestIDandIndex(_requestId, _count.sub(1));\r\n        uint256 _value = tellor.retrieveData(_requestId, _time);\r\n        if (_value > 0) return (true, _value, _time);\r\n        return (false, 0, _time);\r\n    }\r\n}\r\n\r\ninterface IActivePool is IPool {\r\n    // --- Events ---\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolRUBCDebtUpdated(uint _RUBCDebt);\r\n    event ActivePoolETHBalanceUpdated(uint _ETH);\r\n\r\n    // --- Functions ---\r\n    function sendETH(address _account, uint _amount) external;\r\n}\r\n\r\ninterface IDefaultPool is IPool {\r\n    // --- Events ---\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event DefaultPoolRUBCDebtUpdated(uint _RUBCDebt);\r\n    event DefaultPoolETHBalanceUpdated(uint _ETH);\r\n\r\n    // --- Functions ---\r\n    function sendETHToActivePool(uint _amount) external;\r\n}\r\n\r\ninterface ILiquityBase {\r\n    function priceFeed() external view returns (IPriceFeed);\r\n}\r\n\r\ninterface ITroveManager is ILiquityBase {\r\n    \r\n    // --- Events ---\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event RUBCAddressChanged(address _newRUBCAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event RBSTAddressChanged(address _rbstAddress);\r\n    event RBSTStakingAddressChanged(address _rbstStakingAddress);\r\n\r\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _RUBCGasCompensation);\r\n    event Redemption(uint _attemptedRUBCAmount, uint _actualRUBCAmount, uint _ETHSent, uint _ETHFee);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\r\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\r\n    event BaseRateUpdated(uint _baseRate);\r\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\r\n    event TotalStakesUpdated(uint _newTotalStakes);\r\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\r\n    event LTermsUpdated(uint _L_ETH, uint _L_RUBCDebt);\r\n    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_RUBCDebt);\r\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _activePoolAddress,\r\n        address _defaultPoolAddress,\r\n        address _stabilityPoolAddress,\r\n        address _gasPoolAddress,\r\n        address _collSurplusPoolAddress,\r\n        address _priceFeedAddress,\r\n        address _rubcAddress,\r\n        address _sortedTrovesAddress,\r\n        address _rbstAddress,\r\n        address _rbstStakingAddress\r\n    ) external;\r\n\r\n    function stabilityPool() external view returns (IStabilityPool);\r\n    function rubc() external view returns (IRUBC);\r\n    function rbst() external view returns (IRBST);\r\n    function rbstStaking() external view returns (IRBSTStaking);\r\n\r\n    function getTroveOwnersCount() external view returns (uint);\r\n\r\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\r\n\r\n    function getNominalICR(address _borrower) external view returns (uint);\r\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\r\n\r\n    function liquidate(address _borrower) external;\r\n\r\n    function liquidateTroves(uint _n) external;\r\n\r\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\r\n\r\n    function redeemCollateral(\r\n        uint _RUBCAmount,\r\n        address _firstRedemptionHint,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR,\r\n        uint _maxIterations,\r\n        uint _maxFee\r\n    ) external; \r\n\r\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\r\n\r\n    function updateTroveRewardSnapshots(address _borrower) external;\r\n\r\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\r\n\r\n    function applyPendingRewards(address _borrower) external;\r\n\r\n    function getPendingETHReward(address _borrower) external view returns (uint);\r\n\r\n    function getPendingRUBCDebtReward(address _borrower) external view returns (uint);\r\n\r\n     function hasPendingRewards(address _borrower) external view returns (bool);\r\n\r\n    function getEntireDebtAndColl(address _borrower) external view returns (\r\n        uint debt, \r\n        uint coll, \r\n        uint pendingRUBCDebtReward, \r\n        uint pendingETHReward\r\n    );\r\n\r\n    function closeTrove(address _borrower) external;\r\n\r\n    function removeStake(address _borrower) external;\r\n\r\n    function getRedemptionRate() external view returns (uint);\r\n    function getRedemptionRateWithDecay() external view returns (uint);\r\n\r\n    function getRedemptionFeeWithDecay(uint _ETHDrawn) external view returns (uint);\r\n\r\n    function getBorrowingRate() external view returns (uint);\r\n    function getBorrowingRateWithDecay() external view returns (uint);\r\n\r\n    function getBorrowingFee(uint RUBCDebt) external view returns (uint);\r\n    function getBorrowingFeeWithDecay(uint _RUBCDebt) external view returns (uint);\r\n\r\n    function decayBaseRateFromBorrowing() external;\r\n\r\n    function getTroveStatus(address _borrower) external view returns (uint);\r\n    \r\n    function getTroveStake(address _borrower) external view returns (uint);\r\n\r\n    function getTroveDebt(address _borrower) external view returns (uint);\r\n\r\n    function getTroveColl(address _borrower) external view returns (uint);\r\n\r\n    function setTroveStatus(address _borrower, uint num) external;\r\n\r\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\r\n\r\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \r\n\r\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function getTCR(uint _price) external view returns (uint);\r\n\r\n    function checkRecoveryMode(uint _price) external view returns (bool);\r\n}\r\n\r\ncontract LiquityBase is BaseMath, ILiquityBase {\r\n    using SafeMath for uint;\r\n\r\n    uint constant public _100pct = 1000000000000000000; // 1e18 == 100%\r\n\r\n    // Minimum collateral ratio for individual troves\r\n    uint constant public MCR = 1100000000000000000; // 110%\r\n\r\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\r\n    uint constant public CCR = 1500000000000000000; // 150%\r\n\r\n    // Amount of RUBC to be locked in gas pool on opening troves\r\n    uint constant public RUBC_GAS_COMPENSATION = 20_000e18;\r\n\r\n    // Minimum amount of net RUBC debt a trove must have\r\n    uint constant public MIN_NET_DEBT = 100_000e18;\r\n\r\n    uint constant public PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\r\n\r\n    uint constant public BORROWING_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\r\n\r\n    IActivePool public activePool;\r\n\r\n    IDefaultPool public defaultPool;\r\n\r\n    IPriceFeed public override priceFeed;\r\n\r\n    // --- Gas compensation functions ---\r\n\r\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\r\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\r\n        return _debt.add(RUBC_GAS_COMPENSATION);\r\n    }\r\n\r\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\r\n        return _debt.sub(RUBC_GAS_COMPENSATION);\r\n    }\r\n\r\n    // Return the amount of ETH to be drawn from a trove's collateral and sent as gas compensation.\r\n    function _getCollGasCompensation(uint _entireColl) internal pure returns (uint) {\r\n        return _entireColl / PERCENT_DIVISOR;\r\n    }\r\n\r\n    function getEntireSystemColl() public view returns (uint entireSystemColl) {\r\n        uint activeColl = activePool.getETH();\r\n        uint liquidatedColl = defaultPool.getETH();\r\n\r\n        return activeColl.add(liquidatedColl);\r\n    }\r\n\r\n    function getEntireSystemDebt() public view returns (uint entireSystemDebt) {\r\n        uint activeDebt = activePool.getRUBCDebt();\r\n        uint closedDebt = defaultPool.getRUBCDebt();\r\n\r\n        return activeDebt.add(closedDebt);\r\n    }\r\n\r\n    function _getTCR(uint _price) internal view returns (uint TCR) {\r\n        uint entireSystemColl = getEntireSystemColl();\r\n        uint entireSystemDebt = getEntireSystemDebt();\r\n\r\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price);\r\n\r\n        return TCR;\r\n    }\r\n\r\n    function _checkRecoveryMode(uint _price) internal view returns (bool) {\r\n        uint TCR = _getTCR(_price);\r\n\r\n        return TCR < CCR;\r\n    }\r\n\r\n    function _requireUserAcceptsFee(uint _fee, uint _amount, uint _maxFeePercentage) internal pure {\r\n        uint feePercentage = _fee.mul(DECIMAL_PRECISION).div(_amount);\r\n        require(feePercentage <= _maxFeePercentage, \"Fee exceeded provided maximum\");\r\n    }\r\n}\r\n\r\n\r\ncontract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {\r\n    string constant public NAME = \"TroveManager\";\r\n\r\n    // --- Connected contract declarations ---\r\n\r\n    address public borrowerOperationsAddress;\r\n\r\n    IStabilityPool public override stabilityPool;\r\n\r\n    address gasPoolAddress;\r\n\r\n    ICollSurplusPool collSurplusPool;\r\n\r\n    IRUBC public override rubc;\r\n\r\n    IRBST public override rbst;\r\n\r\n    IRBSTStaking public override rbstStaking;\r\n\r\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\r\n    ISortedTroves public sortedTroves;\r\n\r\n    // --- Data structures ---\r\n\r\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\r\n    /*\r\n     * Half-life of 12h. 12h = 720 min\r\n     * (1/2) = d^720 => d = (1/2)^(1/720)\r\n     */\r\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\r\n    uint constant public REDEMPTION_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 25; // 2.5%\r\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\r\n\r\n    // amount of time from an oracle update where a redemption may take place\r\n    //uint constant public REDEMPTION_WINDOW_SECONDS = 10 minutes;\r\n    uint constant public REDEMPTION_WINDOW_SECONDS = 1 days;\r\n\r\n    // During bootsrap period redemptions are not allowed\r\n    uint constant public BOOTSTRAP_PERIOD = 10 days;\r\n\r\n    /*\r\n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\r\n    * Corresponds to (1 / ALPHA) in the white paper.\r\n    */\r\n    uint constant public BETA = 2;\r\n\r\n    uint public baseRate;\r\n\r\n    // The timestamp of the latest fee operation (redemption or new RUBC issuance)\r\n    uint public lastFeeOperationTime;\r\n\r\n    enum Status {\r\n        nonExistent,\r\n        active,\r\n        closedByOwner,\r\n        closedByLiquidation,\r\n        closedByRedemption\r\n    }\r\n\r\n    // Store the necessary data for a trove\r\n    struct Trove {\r\n        uint debt;\r\n        uint coll;\r\n        uint stake;\r\n        Status status;\r\n        uint128 arrayIndex;\r\n    }\r\n\r\n    mapping (address => Trove) public Troves;\r\n\r\n    uint public totalStakes;\r\n\r\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\r\n    uint public totalStakesSnapshot;\r\n\r\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\r\n    uint public totalCollateralSnapshot;\r\n\r\n    /*\r\n    * L_ETH and L_RUBCDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\r\n    *\r\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\r\n    * A RUBCDebt increase  of ( stake * [L_RUBCDebt - L_RUBCDebt(0)] )\r\n    *\r\n    * Where L_ETH(0) and L_RUBCDebt(0) are snapshots of L_ETH and L_RUBCDebt for the active Trove taken at the instant the stake was made\r\n    */\r\n    uint public L_ETH;\r\n    uint public L_RUBCDebt;\r\n\r\n    // Map addresses with active troves to their RewardSnapshot\r\n    mapping (address => RewardSnapshot) public rewardSnapshots;\r\n\r\n    // Object containing the ETH and RUBC snapshots for a given active trove\r\n    struct RewardSnapshot { uint ETH; uint RUBCDebt;}\r\n\r\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\r\n    address[] public TroveOwners;\r\n\r\n    // Error trackers for the trove redistribution calculation\r\n    uint public lastETHError_Redistribution;\r\n    uint public lastRUBCDebtError_Redistribution;\r\n\r\n    /*\r\n    * --- Variable container structs for liquidations ---\r\n    *\r\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\r\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\r\n    **/\r\n\r\n    struct LocalVariables_OuterLiquidationFunction {\r\n        uint price;\r\n        uint RUBCInStabPool;\r\n        bool recoveryModeAtStart;\r\n        uint liquidatedDebt;\r\n        uint liquidatedColl;\r\n    }\r\n\r\n    struct LocalVariables_InnerSingleLiquidateFunction {\r\n        uint collToLiquidate;\r\n        uint pendingDebtReward;\r\n        uint pendingCollReward;\r\n    }\r\n\r\n    struct LocalVariables_LiquidationSequence {\r\n        uint remainingRUBCInStabPool;\r\n        uint i;\r\n        uint ICR;\r\n        address user;\r\n        bool backToNormalMode;\r\n        uint entireSystemDebt;\r\n        uint entireSystemColl;\r\n    }\r\n\r\n    struct LiquidationValues {\r\n        uint entireTroveDebt;\r\n        uint entireTroveColl;\r\n        uint collGasCompensation;\r\n        uint RUBCGasCompensation;\r\n        uint debtToOffset;\r\n        uint collToSendToSP;\r\n        uint debtToRedistribute;\r\n        uint collToRedistribute;\r\n        uint collSurplus;\r\n    }\r\n\r\n    struct LiquidationTotals {\r\n        uint totalCollInSequence;\r\n        uint totalDebtInSequence;\r\n        uint totalCollGasCompensation;\r\n        uint totalRUBCGasCompensation;\r\n        uint totalDebtToOffset;\r\n        uint totalCollToSendToSP;\r\n        uint totalDebtToRedistribute;\r\n        uint totalCollToRedistribute;\r\n        uint totalCollSurplus;\r\n    }\r\n\r\n    struct ContractsCache {\r\n        IActivePool activePool;\r\n        IDefaultPool defaultPool;\r\n        IRUBC rubc;\r\n        IRBSTStaking rbstStaking;\r\n        ISortedTroves sortedTroves;\r\n        ICollSurplusPool collSurplusPool;\r\n        address gasPoolAddress;\r\n    }\r\n    // --- Variable container structs for redemptions ---\r\n\r\n    struct RedemptionTotals {\r\n        uint remainingRUBC;\r\n        uint totalRUBCToRedeem;\r\n        uint totalETHDrawn;\r\n        uint ETHFee;\r\n        uint ETHToSendToRedeemer;\r\n        uint decayedBaseRate;\r\n        uint price;\r\n        uint totalRUBCSupplyAtStart;\r\n    }\r\n\r\n    struct SingleRedemptionValues {\r\n        uint RUBCLot;\r\n        uint ETHLot;\r\n        bool cancelledPartial;\r\n    }\r\n\r\n    // --- Events ---\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event RUBCAddressChanged(address _newRUBCAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event RBSTAddressChanged(address _rbstAddress);\r\n    event RBSTStakingAddressChanged(address _rbstStakingAddress);\r\n\r\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _RUBCGasCompensation);\r\n    event Redemption(uint _attemptedRUBCAmount, uint _actualRUBCAmount, uint _ETHSent, uint _ETHFee);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\r\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\r\n    event BaseRateUpdated(uint _baseRate);\r\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\r\n    event TotalStakesUpdated(uint _newTotalStakes);\r\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\r\n    event LTermsUpdated(uint _L_ETH, uint _L_RUBCDebt);\r\n    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_RUBCDebt);\r\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\r\n\r\n     enum TroveManagerOperation {\r\n        applyPendingRewards,\r\n        liquidateInNormalMode,\r\n        liquidateInRecoveryMode,\r\n        redeemCollateral\r\n    }\r\n\r\n\r\n    // --- Dependency setter ---\r\n\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _activePoolAddress,\r\n        address _defaultPoolAddress,\r\n        address _stabilityPoolAddress,\r\n        address _gasPoolAddress,\r\n        address _collSurplusPoolAddress,\r\n        address _priceFeedAddress,\r\n        address _rubcAddress,\r\n        address _sortedTrovesAddress,\r\n        address _rbstAddress,\r\n        address _rbstStakingAddress\r\n    )\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        checkContract(_borrowerOperationsAddress);\r\n        checkContract(_activePoolAddress);\r\n        checkContract(_defaultPoolAddress);\r\n        checkContract(_stabilityPoolAddress);\r\n        checkContract(_gasPoolAddress);\r\n        checkContract(_collSurplusPoolAddress);\r\n        checkContract(_priceFeedAddress);\r\n        checkContract(_rubcAddress);\r\n        checkContract(_sortedTrovesAddress);\r\n        checkContract(_rbstAddress);\r\n        checkContract(_rbstStakingAddress);\r\n\r\n        borrowerOperationsAddress = _borrowerOperationsAddress;\r\n        activePool = IActivePool(_activePoolAddress);\r\n        defaultPool = IDefaultPool(_defaultPoolAddress);\r\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\r\n        gasPoolAddress = _gasPoolAddress;\r\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\r\n        priceFeed = IPriceFeed(_priceFeedAddress);\r\n        rubc = IRUBC(_rubcAddress);\r\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\r\n        rbst = IRBST(_rbstAddress);\r\n        rbstStaking = IRBSTStaking(_rbstStakingAddress);\r\n\r\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\r\n        emit ActivePoolAddressChanged(_activePoolAddress);\r\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\r\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\r\n        emit GasPoolAddressChanged(_gasPoolAddress);\r\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\r\n        emit PriceFeedAddressChanged(_priceFeedAddress);\r\n        emit RUBCAddressChanged(_rubcAddress);\r\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\r\n        emit RBSTAddressChanged(_rbstAddress);\r\n        emit RBSTStakingAddressChanged(_rbstStakingAddress);\r\n\r\n        _renounceOwnership();\r\n    }\r\n\r\n    // --- Getters ---\r\n\r\n    function getTroveOwnersCount() external view override returns (uint) {\r\n        return TroveOwners.length;\r\n    }\r\n\r\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\r\n        return TroveOwners[_index];\r\n    }\r\n\r\n    // --- Trove Liquidation functions ---\r\n\r\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\r\n    function liquidate(address _borrower) external override {\r\n        _requireTroveIsActive(_borrower);\r\n\r\n        address[] memory borrowers = new address[](1);\r\n        borrowers[0] = _borrower;\r\n        batchLiquidateTroves(borrowers);\r\n    }\r\n\r\n    // --- Inner single liquidation functions ---\r\n\r\n    // Liquidate one trove, in Normal Mode.\r\n    function _liquidateNormalMode(\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        address _borrower,\r\n        uint _RUBCInStabPool\r\n    )\r\n        internal\r\n        returns (LiquidationValues memory singleLiquidation)\r\n    {\r\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\r\n\r\n        (singleLiquidation.entireTroveDebt,\r\n        singleLiquidation.entireTroveColl,\r\n        vars.pendingDebtReward,\r\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\r\n\r\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\r\n        _removeStake(_borrower);\r\n\r\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\r\n        singleLiquidation.RUBCGasCompensation = RUBC_GAS_COMPENSATION;\r\n        uint collToLiquidate = singleLiquidation.entireTroveColl.sub(singleLiquidation.collGasCompensation);\r\n\r\n        (singleLiquidation.debtToOffset,\r\n        singleLiquidation.collToSendToSP,\r\n        singleLiquidation.debtToRedistribute,\r\n        singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, collToLiquidate, _RUBCInStabPool);\r\n\r\n        _closeTrove(_borrower, Status.closedByLiquidation);\r\n        emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\r\n        emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInNormalMode);\r\n        return singleLiquidation;\r\n    }\r\n\r\n    // Liquidate one trove, in Recovery Mode.\r\n    function _liquidateRecoveryMode(\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        address _borrower,\r\n        uint _ICR,\r\n        uint _RUBCInStabPool,\r\n        uint _TCR,\r\n        uint _price\r\n    )\r\n        internal\r\n        returns (LiquidationValues memory singleLiquidation)\r\n    {\r\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\r\n        if (TroveOwners.length <= 1) {return singleLiquidation;} // don't liquidate if last trove\r\n        (singleLiquidation.entireTroveDebt,\r\n        singleLiquidation.entireTroveColl,\r\n        vars.pendingDebtReward,\r\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\r\n\r\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\r\n        singleLiquidation.RUBCGasCompensation = RUBC_GAS_COMPENSATION;\r\n        vars.collToLiquidate = singleLiquidation.entireTroveColl.sub(singleLiquidation.collGasCompensation);\r\n\r\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\r\n        if (_ICR <= _100pct) {\r\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\r\n            _removeStake(_borrower);\r\n           \r\n            singleLiquidation.debtToOffset = 0;\r\n            singleLiquidation.collToSendToSP = 0;\r\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\r\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\r\n\r\n            _closeTrove(_borrower, Status.closedByLiquidation);\r\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\r\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\r\n            \r\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\r\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\r\n             _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\r\n            _removeStake(_borrower);\r\n\r\n            (singleLiquidation.debtToOffset,\r\n            singleLiquidation.collToSendToSP,\r\n            singleLiquidation.debtToRedistribute,\r\n            singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, vars.collToLiquidate, _RUBCInStabPool);\r\n\r\n            _closeTrove(_borrower, Status.closedByLiquidation);\r\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\r\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\r\n        /*\r\n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\r\n        * and there is RUBC in the Stability Pool, only offset, with no redistribution,\r\n        * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\r\n        * The remainder due to the capped rate will be claimable as collateral surplus.\r\n        */\r\n        } else if ((_ICR >= MCR) && (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _RUBCInStabPool)) {\r\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\r\n            assert(_RUBCInStabPool != 0);\r\n\r\n            _removeStake(_borrower);\r\n            singleLiquidation = _getCappedOffsetVals(singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, _price);\r\n\r\n            _closeTrove(_borrower, Status.closedByLiquidation);\r\n            if (singleLiquidation.collSurplus > 0) {\r\n                collSurplusPool.accountSurplus(_borrower, singleLiquidation.collSurplus);\r\n            }\r\n\r\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.collToSendToSP, TroveManagerOperation.liquidateInRecoveryMode);\r\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\r\n\r\n        } else { // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _RUBCInStabPool))\r\n            LiquidationValues memory zeroVals;\r\n            return zeroVals;\r\n        }\r\n\r\n        return singleLiquidation;\r\n    }\r\n\r\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\r\n    * redistributed to active troves.\r\n    */\r\n    function _getOffsetAndRedistributionVals\r\n    (\r\n        uint _debt,\r\n        uint _coll,\r\n        uint _RUBCInStabPool\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\r\n    {\r\n        if (_RUBCInStabPool > 0) {\r\n        /*\r\n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\r\n        * between all active troves.\r\n        *\r\n        *  If the trove's debt is larger than the deposited RUBC in the Stability Pool:\r\n        *\r\n        *  - Offset an amount of the trove's debt equal to the RUBC in the Stability Pool\r\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\r\n        *\r\n        */\r\n            debtToOffset = LiquityMath._min(_debt, _RUBCInStabPool);\r\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\r\n            debtToRedistribute = _debt.sub(debtToOffset);\r\n            collToRedistribute = _coll.sub(collToSendToSP);\r\n        } else {\r\n            debtToOffset = 0;\r\n            collToSendToSP = 0;\r\n            debtToRedistribute = _debt;\r\n            collToRedistribute = _coll;\r\n        }\r\n    }\r\n\r\n    /*\r\n    *  Get its offset coll/debt and ETH gas comp, and close the trove.\r\n    */\r\n    function _getCappedOffsetVals\r\n    (\r\n        uint _entireTroveDebt,\r\n        uint _entireTroveColl,\r\n        uint _price\r\n    )\r\n        internal\r\n        pure\r\n        returns (LiquidationValues memory singleLiquidation)\r\n    {\r\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\r\n        singleLiquidation.entireTroveColl = _entireTroveColl;\r\n        uint cappedCollPortion = _entireTroveDebt.mul(MCR).div(_price);\r\n\r\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(cappedCollPortion);\r\n        singleLiquidation.RUBCGasCompensation = RUBC_GAS_COMPENSATION;\r\n\r\n        singleLiquidation.debtToOffset = _entireTroveDebt;\r\n        singleLiquidation.collToSendToSP = cappedCollPortion.sub(singleLiquidation.collGasCompensation);\r\n        singleLiquidation.collSurplus = _entireTroveColl.sub(cappedCollPortion);\r\n        singleLiquidation.debtToRedistribute = 0;\r\n        singleLiquidation.collToRedistribute = 0;\r\n    }\r\n\r\n    /*\r\n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\r\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\r\n    */\r\n    function liquidateTroves(uint _n) external override {\r\n        ContractsCache memory contractsCache = ContractsCache(\r\n            activePool,\r\n            defaultPool,\r\n            IRUBC(address(0)),\r\n            IRBSTStaking(address(0)),\r\n            sortedTroves,\r\n            ICollSurplusPool(address(0)),\r\n            address(0)\r\n        );\r\n        IStabilityPool stabilityPoolCached = stabilityPool;\r\n\r\n        LocalVariables_OuterLiquidationFunction memory vars;\r\n\r\n        LiquidationTotals memory totals;\r\n\r\n        vars.price = priceFeed.fetchPrice();\r\n        vars.RUBCInStabPool = stabilityPoolCached.getTotalRUBCDeposits();\r\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\r\n\r\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\r\n        if (vars.recoveryModeAtStart) {\r\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(contractsCache, vars.price, vars.RUBCInStabPool, _n);\r\n        } else { // if !vars.recoveryModeAtStart\r\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(contractsCache.activePool, contractsCache.defaultPool, vars.price, vars.RUBCInStabPool, _n);\r\n        }\r\n\r\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\r\n\r\n        // Move liquidated ETH and RUBC to the appropriate pools\r\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\r\n        _redistributeDebtAndColl(contractsCache.activePool, contractsCache.defaultPool, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\r\n        if (totals.totalCollSurplus > 0) {\r\n            contractsCache.activePool.sendETH(address(collSurplusPool), totals.totalCollSurplus);\r\n        }\r\n\r\n        // Update system snapshots\r\n        _updateSystemSnapshots_excludeCollRemainder(contractsCache.activePool, totals.totalCollGasCompensation);\r\n\r\n        vars.liquidatedDebt = totals.totalDebtInSequence;\r\n        vars.liquidatedColl = totals.totalCollInSequence.sub(totals.totalCollGasCompensation).sub(totals.totalCollSurplus);\r\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation, totals.totalRUBCGasCompensation);\r\n\r\n        // Send gas compensation to caller\r\n        _sendGasCompensation(contractsCache.activePool, msg.sender, totals.totalRUBCGasCompensation, totals.totalCollGasCompensation);\r\n    }\r\n\r\n    /*\r\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\r\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\r\n    */\r\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\r\n    (\r\n        ContractsCache memory _contractsCache,\r\n        uint _price,\r\n        uint _RUBCInStabPool,\r\n        uint _n\r\n    )\r\n        internal\r\n        returns(LiquidationTotals memory totals)\r\n    {\r\n        LocalVariables_LiquidationSequence memory vars;\r\n        LiquidationValues memory singleLiquidation;\r\n\r\n        vars.remainingRUBCInStabPool = _RUBCInStabPool;\r\n        vars.backToNormalMode = false;\r\n        vars.entireSystemDebt = getEntireSystemDebt();\r\n        vars.entireSystemColl = getEntireSystemColl();\r\n\r\n        vars.user = _contractsCache.sortedTroves.getLast();\r\n        address firstUser = _contractsCache.sortedTroves.getFirst();\r\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\r\n            // we need to cache it, because current user is likely going to be deleted\r\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\r\n\r\n            vars.ICR = getCurrentICR(vars.user, _price);\r\n\r\n            if (!vars.backToNormalMode) {\r\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\r\n                if (vars.ICR >= MCR && vars.remainingRUBCInStabPool == 0) { break; }\r\n\r\n                uint TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\r\n\r\n                singleLiquidation = _liquidateRecoveryMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.ICR, vars.remainingRUBCInStabPool, TCR, _price);\r\n\r\n                // Update aggregate trackers\r\n                vars.remainingRUBCInStabPool = vars.remainingRUBCInStabPool.sub(singleLiquidation.debtToOffset);\r\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\r\n                vars.entireSystemColl = vars.entireSystemColl.\r\n                    sub(singleLiquidation.collToSendToSP).\r\n                    sub(singleLiquidation.collGasCompensation).\r\n                    sub(singleLiquidation.collSurplus);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n\r\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\r\n            }\r\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\r\n                singleLiquidation = _liquidateNormalMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.remainingRUBCInStabPool);\r\n\r\n                vars.remainingRUBCInStabPool = vars.remainingRUBCInStabPool.sub(singleLiquidation.debtToOffset);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n\r\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\r\n\r\n            vars.user = nextUser;\r\n        }\r\n    }\r\n\r\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\r\n    (\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        uint _price,\r\n        uint _RUBCInStabPool,\r\n        uint _n\r\n    )\r\n        internal\r\n        returns(LiquidationTotals memory totals)\r\n    {\r\n        LocalVariables_LiquidationSequence memory vars;\r\n        LiquidationValues memory singleLiquidation;\r\n        ISortedTroves sortedTrovesCached = sortedTroves;\r\n\r\n        vars.remainingRUBCInStabPool = _RUBCInStabPool;\r\n\r\n        for (vars.i = 0; vars.i < _n; vars.i++) {\r\n            vars.user = sortedTrovesCached.getLast();\r\n            vars.ICR = getCurrentICR(vars.user, _price);\r\n\r\n            if (vars.ICR < MCR) {\r\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingRUBCInStabPool);\r\n\r\n                vars.remainingRUBCInStabPool = vars.remainingRUBCInStabPool.sub(singleLiquidation.debtToOffset);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n\r\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\r\n        }\r\n    }\r\n\r\n    /*\r\n    * Attempt to liquidate a custom list of troves provided by the caller.\r\n    */\r\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\r\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\r\n\r\n        IActivePool activePoolCached = activePool;\r\n        IDefaultPool defaultPoolCached = defaultPool;\r\n        IStabilityPool stabilityPoolCached = stabilityPool;\r\n\r\n        LocalVariables_OuterLiquidationFunction memory vars;\r\n        LiquidationTotals memory totals;\r\n\r\n        vars.price = priceFeed.fetchPrice();\r\n        vars.RUBCInStabPool = stabilityPoolCached.getTotalRUBCDeposits();\r\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\r\n\r\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\r\n        if (vars.recoveryModeAtStart) {\r\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(activePoolCached, defaultPoolCached, vars.price, vars.RUBCInStabPool, _troveArray);\r\n        } else {  //  if !vars.recoveryModeAtStart\r\n            totals = _getTotalsFromBatchLiquidate_NormalMode(activePoolCached, defaultPoolCached, vars.price, vars.RUBCInStabPool, _troveArray);\r\n        }\r\n\r\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\r\n\r\n        // Move liquidated ETH and RUBC to the appropriate pools\r\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\r\n        _redistributeDebtAndColl(activePoolCached, defaultPoolCached, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\r\n        if (totals.totalCollSurplus > 0) {\r\n            activePoolCached.sendETH(address(collSurplusPool), totals.totalCollSurplus);\r\n        }\r\n\r\n        // Update system snapshots\r\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.totalCollGasCompensation);\r\n\r\n        vars.liquidatedDebt = totals.totalDebtInSequence;\r\n        vars.liquidatedColl = totals.totalCollInSequence.sub(totals.totalCollGasCompensation).sub(totals.totalCollSurplus);\r\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation, totals.totalRUBCGasCompensation);\r\n\r\n        // Send gas compensation to caller\r\n        _sendGasCompensation(activePoolCached, msg.sender, totals.totalRUBCGasCompensation, totals.totalCollGasCompensation);\r\n    }\r\n\r\n    /*\r\n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\r\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\r\n    */\r\n    function _getTotalFromBatchLiquidate_RecoveryMode\r\n    (\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        uint _price,\r\n        uint _RUBCInStabPool,\r\n        address[] memory _troveArray\r\n    )\r\n        internal\r\n        returns(LiquidationTotals memory totals)\r\n    {\r\n        LocalVariables_LiquidationSequence memory vars;\r\n        LiquidationValues memory singleLiquidation;\r\n\r\n        vars.remainingRUBCInStabPool = _RUBCInStabPool;\r\n        vars.backToNormalMode = false;\r\n        vars.entireSystemDebt = getEntireSystemDebt();\r\n        vars.entireSystemColl = getEntireSystemColl();\r\n\r\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\r\n            vars.user = _troveArray[vars.i];\r\n            // Skip non-active troves\r\n            if (Troves[vars.user].status != Status.active) { continue; }\r\n            vars.ICR = getCurrentICR(vars.user, _price);\r\n\r\n            if (!vars.backToNormalMode) {\r\n\r\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\r\n                if (vars.ICR >= MCR && vars.remainingRUBCInStabPool == 0) { continue; }\r\n\r\n                uint TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\r\n\r\n                singleLiquidation = _liquidateRecoveryMode(_activePool, _defaultPool, vars.user, vars.ICR, vars.remainingRUBCInStabPool, TCR, _price);\r\n\r\n                // Update aggregate trackers\r\n                vars.remainingRUBCInStabPool = vars.remainingRUBCInStabPool.sub(singleLiquidation.debtToOffset);\r\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\r\n                vars.entireSystemColl = vars.entireSystemColl.\r\n                    sub(singleLiquidation.collToSendToSP).\r\n                    sub(singleLiquidation.collGasCompensation).\r\n                    sub(singleLiquidation.collSurplus);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n\r\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\r\n            }\r\n\r\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\r\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingRUBCInStabPool);\r\n                vars.remainingRUBCInStabPool = vars.remainingRUBCInStabPool.sub(singleLiquidation.debtToOffset);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n\r\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\r\n        }\r\n    }\r\n\r\n    function _getTotalsFromBatchLiquidate_NormalMode\r\n    (\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        uint _price,\r\n        uint _RUBCInStabPool,\r\n        address[] memory _troveArray\r\n    )\r\n        internal\r\n        returns(LiquidationTotals memory totals)\r\n    {\r\n        LocalVariables_LiquidationSequence memory vars;\r\n        LiquidationValues memory singleLiquidation;\r\n\r\n        vars.remainingRUBCInStabPool = _RUBCInStabPool;\r\n\r\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\r\n            vars.user = _troveArray[vars.i];\r\n            vars.ICR = getCurrentICR(vars.user, _price);\r\n\r\n            if (vars.ICR < MCR) {\r\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingRUBCInStabPool);\r\n                vars.remainingRUBCInStabPool = vars.remainingRUBCInStabPool.sub(singleLiquidation.debtToOffset);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- Liquidation helper functions ---\r\n\r\n    function _addLiquidationValuesToTotals(LiquidationTotals memory oldTotals, LiquidationValues memory singleLiquidation)\r\n    internal pure returns(LiquidationTotals memory newTotals) {\r\n\r\n        // Tally all the values with their respective running totals\r\n        newTotals.totalCollGasCompensation = oldTotals.totalCollGasCompensation.add(singleLiquidation.collGasCompensation);\r\n        newTotals.totalRUBCGasCompensation = oldTotals.totalRUBCGasCompensation.add(singleLiquidation.RUBCGasCompensation);\r\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(singleLiquidation.entireTroveDebt);\r\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence.add(singleLiquidation.entireTroveColl);\r\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(singleLiquidation.debtToOffset);\r\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP.add(singleLiquidation.collToSendToSP);\r\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(singleLiquidation.debtToRedistribute);\r\n        newTotals.totalCollToRedistribute = oldTotals.totalCollToRedistribute.add(singleLiquidation.collToRedistribute);\r\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus.add(singleLiquidation.collSurplus);\r\n\r\n        return newTotals;\r\n    }\r\n\r\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, uint _RUBC, uint _ETH) internal {\r\n        if (_RUBC > 0) {\r\n            rubc.returnFromPool(gasPoolAddress, _liquidator, _RUBC);\r\n        }\r\n\r\n        if (_ETH > 0) {\r\n            _activePool.sendETH(_liquidator, _ETH);\r\n        }\r\n    }\r\n\r\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\r\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _RUBC, uint _ETH) internal {\r\n        _defaultPool.decreaseRUBCDebt(_RUBC);\r\n        _activePool.increaseRUBCDebt(_RUBC);\r\n        _defaultPool.sendETHToActivePool(_ETH);\r\n    }\r\n\r\n    // --- Redemption functions ---\r\n\r\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for RUBC up to _maxRUBCamount\r\n    function _redeemCollateralFromTrove(\r\n        ContractsCache memory _contractsCache,\r\n        address _borrower,\r\n        uint _maxRUBCamount,\r\n        uint _price,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR\r\n    )\r\n        internal returns (SingleRedemptionValues memory singleRedemption)\r\n    {\r\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\r\n        singleRedemption.RUBCLot = LiquityMath._min(_maxRUBCamount, Troves[_borrower].debt.sub(RUBC_GAS_COMPENSATION));\r\n\r\n        // Get the ETHLot of equivalent value in USD\r\n        singleRedemption.ETHLot = singleRedemption.RUBCLot.mul(DECIMAL_PRECISION).div(_price);\r\n\r\n        // Decrease the debt and collateral of the current Trove according to the RUBC lot and corresponding ETH to send\r\n        uint newDebt = (Troves[_borrower].debt).sub(singleRedemption.RUBCLot);\r\n        uint newColl = (Troves[_borrower].coll).sub(singleRedemption.ETHLot);\r\n\r\n        if (newDebt == RUBC_GAS_COMPENSATION) {\r\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\r\n            _removeStake(_borrower);\r\n            _closeTrove(_borrower, Status.closedByRedemption);\r\n            _redeemCloseTrove(_contractsCache, _borrower, RUBC_GAS_COMPENSATION, newColl);\r\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.redeemCollateral);\r\n\r\n        } else {\r\n            uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\r\n\r\n            /*\r\n            * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\r\n            * certainly result in running out of gas. \r\n            *\r\n            * If the resultant net debt of the partial is less than the minimum, net debt we bail.\r\n            */\r\n            if (newNICR != _partialRedemptionHintNICR || _getNetDebt(newDebt) < MIN_NET_DEBT) {\r\n                singleRedemption.cancelledPartial = true;\r\n                return singleRedemption;\r\n            }\r\n\r\n            _contractsCache.sortedTroves.reInsert(_borrower, newNICR, _upperPartialRedemptionHint, _lowerPartialRedemptionHint);\r\n\r\n            Troves[_borrower].debt = newDebt;\r\n            Troves[_borrower].coll = newColl;\r\n            _updateStakeAndTotalStakes(_borrower);\r\n\r\n            emit TroveUpdated(\r\n                _borrower,\r\n                newDebt, newColl,\r\n                Troves[_borrower].stake,\r\n                TroveManagerOperation.redeemCollateral\r\n            );\r\n        }\r\n\r\n        return singleRedemption;\r\n    }\r\n\r\n    /*\r\n    * Called when a full redemption occurs, and closes the trove.\r\n    * The redeemer swaps (debt - liquidation reserve) RUBC for (debt - liquidation reserve) worth of ETH, so the RUBC liquidation reserve left corresponds to the remaining debt.\r\n    * In order to close the trove, the RUBC liquidation reserve is burned, and the corresponding debt is removed from the active pool.\r\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\r\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\r\n    */\r\n    function _redeemCloseTrove(ContractsCache memory _contractsCache, address _borrower, uint _RUBC, uint _ETH) internal {\r\n        _contractsCache.rubc.burn(gasPoolAddress, _RUBC);\r\n        // Update Active Pool RUBC, and send ETH to account\r\n        _contractsCache.activePool.decreaseRUBCDebt(_RUBC);\r\n\r\n        // send ETH from Active Pool to CollSurplus Pool\r\n        _contractsCache.collSurplusPool.accountSurplus(_borrower, _ETH);\r\n        _contractsCache.activePool.sendETH(address(_contractsCache.collSurplusPool), _ETH);\r\n    }\r\n\r\n    function _isValidFirstRedemptionHint(ISortedTroves _sortedTroves, address _firstRedemptionHint, uint _price) internal view returns (bool) {\r\n        if (_firstRedemptionHint == address(0) ||\r\n            !_sortedTroves.contains(_firstRedemptionHint) ||\r\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        address nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\r\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\r\n    }\r\n\r\n    /* Send _RUBCamount RUBC to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\r\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\r\n    *\r\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\r\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\r\n    *\r\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it\u2019s zero, it will be ignored).This makes it easier to\r\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the \u201ctopology\u201d\r\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\r\n    * costs can vary.\r\n    *\r\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\r\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\r\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\r\n    * in the sortedTroves list along with the ICR value that the hint was found for.\r\n    *\r\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\r\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\r\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining RUBC amount, which they can attempt\r\n    * to redeem later.\r\n    */\r\n    function redeemCollateral(\r\n        uint _RUBCamount,\r\n        address _firstRedemptionHint,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR,\r\n        uint _maxIterations,\r\n        uint _maxFeePercentage\r\n    )\r\n        external\r\n        override\r\n    {\r\n        ContractsCache memory contractsCache = ContractsCache(\r\n            activePool,\r\n            defaultPool,\r\n            rubc,\r\n            rbstStaking,\r\n            sortedTroves,\r\n            collSurplusPool,\r\n            gasPoolAddress\r\n        );\r\n        RedemptionTotals memory totals;\r\n\r\n        _requireValidMaxFeePercentage(_maxFeePercentage);\r\n        _requireAfterBootstrapPeriod();\r\n        {\r\n            //new scope to prevent stack too deep\r\n            IPriceFeed _priceFeed = priceFeed;\r\n            totals.price = _priceFeed.fetchPrice();\r\n            require(_priceFeed.fetchRUBPriceFeedUpdateTimestamp() < block.timestamp + REDEMPTION_WINDOW_SECONDS);\r\n        }\r\n        _requireTCRoverMCR(totals.price);\r\n        _requireAmountGreaterThanZero(_RUBCamount);\r\n        _requireRUBCBalanceCoversRedemption(contractsCache.rubc, msg.sender, _RUBCamount);\r\n\r\n        totals.totalRUBCSupplyAtStart = getEntireSystemDebt();\r\n        // Confirm redeemer's balance is less than total RUBC supply\r\n        assert(contractsCache.rubc.balanceOf(msg.sender) <= totals.totalRUBCSupplyAtStart);\r\n\r\n        totals.remainingRUBC = _RUBCamount;\r\n        address currentBorrower;\r\n\r\n        if (_isValidFirstRedemptionHint(contractsCache.sortedTroves, _firstRedemptionHint, totals.price)) {\r\n            currentBorrower = _firstRedemptionHint;\r\n        } else {\r\n            currentBorrower = contractsCache.sortedTroves.getLast();\r\n            // Find the first trove with ICR >= MCR\r\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, totals.price) < MCR) {\r\n                currentBorrower = contractsCache.sortedTroves.getPrev(currentBorrower);\r\n            }\r\n        }\r\n\r\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of RUBC is exchanged for collateral\r\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\r\n        while (currentBorrower != address(0) && totals.remainingRUBC > 0 && _maxIterations > 0) {\r\n            _maxIterations--;\r\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\r\n            address nextUserToCheck = contractsCache.sortedTroves.getPrev(currentBorrower);\r\n\r\n            _applyPendingRewards(contractsCache.activePool, contractsCache.defaultPool, currentBorrower);\r\n\r\n            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(\r\n                contractsCache,\r\n                currentBorrower,\r\n                totals.remainingRUBC,\r\n                totals.price,\r\n                _upperPartialRedemptionHint,\r\n                _lowerPartialRedemptionHint,\r\n                _partialRedemptionHintNICR\r\n            );\r\n\r\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\r\n\r\n            totals.totalRUBCToRedeem  = totals.totalRUBCToRedeem.add(singleRedemption.RUBCLot);\r\n            totals.totalETHDrawn = totals.totalETHDrawn.add(singleRedemption.ETHLot);\r\n\r\n            totals.remainingRUBC = totals.remainingRUBC.sub(singleRedemption.RUBCLot);\r\n            currentBorrower = nextUserToCheck;\r\n        }\r\n        require(totals.totalETHDrawn > 0, \"TroveManager: Unable to redeem any amount\");\r\n\r\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\r\n        // Use the saved total RUBC supply value, from before it was reduced by the redemption.\r\n        _updateBaseRateFromRedemption(totals.totalETHDrawn, totals.price, totals.totalRUBCSupplyAtStart);\r\n\r\n        // Calculate the ETH fee\r\n        totals.ETHFee = _getRedemptionFee(totals.totalETHDrawn);\r\n\r\n        _requireUserAcceptsFee(totals.ETHFee, totals.totalETHDrawn, _maxFeePercentage);\r\n\r\n        // Send the ETH fee to the RBST staking contract\r\n        contractsCache.activePool.sendETH(address(contractsCache.rbstStaking), totals.ETHFee);\r\n        contractsCache.rbstStaking.increaseF_ETH(totals.ETHFee);\r\n\r\n        totals.ETHToSendToRedeemer = totals.totalETHDrawn.sub(totals.ETHFee);\r\n\r\n        emit Redemption(_RUBCamount, totals.totalRUBCToRedeem, totals.totalETHDrawn, totals.ETHFee);\r\n\r\n        // Burn the total RUBC that is cancelled with debt, and send the redeemed ETH to msg.sender\r\n        contractsCache.rubc.burn(msg.sender, totals.totalRUBCToRedeem);\r\n        // Update Active Pool RUBC, and send ETH to account\r\n        contractsCache.activePool.decreaseRUBCDebt(totals.totalRUBCToRedeem);\r\n        contractsCache.activePool.sendETH(msg.sender, totals.ETHToSendToRedeemer);\r\n    }\r\n\r\n    // --- Helper functions ---\r\n\r\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\r\n    function getNominalICR(address _borrower) public view override returns (uint) {\r\n        (uint currentETH, uint currentRUBCDebt) = _getCurrentTroveAmounts(_borrower);\r\n\r\n        uint NICR = LiquityMath._computeNominalCR(currentETH, currentRUBCDebt);\r\n        return NICR;\r\n    }\r\n\r\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\r\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\r\n        (uint currentETH, uint currentRUBCDebt) = _getCurrentTroveAmounts(_borrower);\r\n\r\n        uint ICR = LiquityMath._computeCR(currentETH, currentRUBCDebt, _price);\r\n        return ICR;\r\n    }\r\n\r\n    function _getCurrentTroveAmounts(address _borrower) internal view returns (uint, uint) {\r\n        uint pendingETHReward = getPendingETHReward(_borrower);\r\n        uint pendingRUBCDebtReward = getPendingRUBCDebtReward(_borrower);\r\n\r\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\r\n        uint currentRUBCDebt = Troves[_borrower].debt.add(pendingRUBCDebtReward);\r\n\r\n        return (currentETH, currentRUBCDebt);\r\n    }\r\n\r\n    function applyPendingRewards(address _borrower) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\r\n    }\r\n\r\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\r\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\r\n        if (hasPendingRewards(_borrower)) {\r\n            _requireTroveIsActive(_borrower);\r\n\r\n            // Compute pending rewards\r\n            uint pendingETHReward = getPendingETHReward(_borrower);\r\n            uint pendingRUBCDebtReward = getPendingRUBCDebtReward(_borrower);\r\n\r\n            // Apply pending rewards to trove's state\r\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\r\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingRUBCDebtReward);\r\n\r\n            _updateTroveRewardSnapshots(_borrower);\r\n\r\n            // Transfer from DefaultPool to ActivePool\r\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingRUBCDebtReward, pendingETHReward);\r\n\r\n            emit TroveUpdated(\r\n                _borrower,\r\n                Troves[_borrower].debt,\r\n                Troves[_borrower].coll,\r\n                Troves[_borrower].stake,\r\n                TroveManagerOperation.applyPendingRewards\r\n            );\r\n        }\r\n    }\r\n\r\n    // Update borrower's snapshots of L_ETH and L_RUBCDebt to reflect the current values\r\n    function updateTroveRewardSnapshots(address _borrower) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n       return _updateTroveRewardSnapshots(_borrower);\r\n    }\r\n\r\n    function _updateTroveRewardSnapshots(address _borrower) internal {\r\n        rewardSnapshots[_borrower].ETH = L_ETH;\r\n        rewardSnapshots[_borrower].RUBCDebt = L_RUBCDebt;\r\n        emit TroveSnapshotsUpdated(L_ETH, L_RUBCDebt);\r\n    }\r\n\r\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\r\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\r\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\r\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\r\n\r\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\r\n\r\n        uint stake = Troves[_borrower].stake;\r\n\r\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\r\n\r\n        return pendingETHReward;\r\n    }\r\n    \r\n    // Get the borrower's pending accumulated RUBC reward, earned by their stake\r\n    function getPendingRUBCDebtReward(address _borrower) public view override returns (uint) {\r\n        uint snapshotRUBCDebt = rewardSnapshots[_borrower].RUBCDebt;\r\n        uint rewardPerUnitStaked = L_RUBCDebt.sub(snapshotRUBCDebt);\r\n\r\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\r\n\r\n        uint stake =  Troves[_borrower].stake;\r\n\r\n        uint pendingRUBCDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\r\n\r\n        return pendingRUBCDebtReward;\r\n    }\r\n\r\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\r\n        /*\r\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\r\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\r\n        * pending rewards\r\n        */\r\n        if (Troves[_borrower].status != Status.active) {return false;}\r\n       \r\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\r\n    }\r\n\r\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\r\n    function getEntireDebtAndColl(\r\n        address _borrower\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (uint debt, uint coll, uint pendingRUBCDebtReward, uint pendingETHReward)\r\n    {\r\n        debt = Troves[_borrower].debt;\r\n        coll = Troves[_borrower].coll;\r\n\r\n        pendingRUBCDebtReward = getPendingRUBCDebtReward(_borrower);\r\n        pendingETHReward = getPendingETHReward(_borrower);\r\n\r\n        debt = debt.add(pendingRUBCDebtReward);\r\n        coll = coll.add(pendingETHReward);\r\n    }\r\n\r\n    function removeStake(address _borrower) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _removeStake(_borrower);\r\n    }\r\n\r\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\r\n    function _removeStake(address _borrower) internal {\r\n        uint stake = Troves[_borrower].stake;\r\n        totalStakes = totalStakes.sub(stake);\r\n        Troves[_borrower].stake = 0;\r\n    }\r\n\r\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _updateStakeAndTotalStakes(_borrower);\r\n    }\r\n\r\n    // Update borrower's stake based on their latest collateral value\r\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\r\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\r\n        uint oldStake = Troves[_borrower].stake;\r\n        Troves[_borrower].stake = newStake;\r\n\r\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\r\n        emit TotalStakesUpdated(totalStakes);\r\n\r\n        return newStake;\r\n    }\r\n\r\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\r\n    function _computeNewStake(uint _coll) internal view returns (uint) {\r\n        uint stake;\r\n        if (totalCollateralSnapshot == 0) {\r\n            stake = _coll;\r\n        } else {\r\n            /*\r\n            * The following assert() holds true because:\r\n            * - The system always contains >= 1 trove\r\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\r\n            * rewards would\u2019ve been emptied and totalCollateralSnapshot would be zero too.\r\n            */\r\n            assert(totalStakesSnapshot > 0);\r\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\r\n        }\r\n        return stake;\r\n    }\r\n\r\n    function _redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, uint _coll) internal {\r\n        if (_debt == 0) { return; }\r\n\r\n        /*\r\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\r\n        * error correction, to keep the cumulative error low in the running totals L_ETH and L_RUBCDebt:\r\n        *\r\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\r\n        * function was called.\r\n        * 2) Calculate \"per-unit-staked\" ratios.\r\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\r\n        * 4) Store these errors for use in the next correction when this function is called.\r\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\r\n        */\r\n        uint ETHNumerator = _coll.mul(DECIMAL_PRECISION).add(lastETHError_Redistribution);\r\n        uint RUBCDebtNumerator = _debt.mul(DECIMAL_PRECISION).add(lastRUBCDebtError_Redistribution);\r\n\r\n        // Get the per-unit-staked terms\r\n        uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\r\n        uint RUBCDebtRewardPerUnitStaked = RUBCDebtNumerator.div(totalStakes);\r\n\r\n        lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\r\n        lastRUBCDebtError_Redistribution = RUBCDebtNumerator.sub(RUBCDebtRewardPerUnitStaked.mul(totalStakes));\r\n\r\n        // Add per-unit-staked terms to the running totals\r\n        L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\r\n        L_RUBCDebt = L_RUBCDebt.add(RUBCDebtRewardPerUnitStaked);\r\n\r\n        emit LTermsUpdated(L_ETH, L_RUBCDebt);\r\n\r\n        // Transfer coll and debt from ActivePool to DefaultPool\r\n        _activePool.decreaseRUBCDebt(_debt);\r\n        _defaultPool.increaseRUBCDebt(_debt);\r\n        _activePool.sendETH(address(_defaultPool), _coll);\r\n    }\r\n\r\n    function closeTrove(address _borrower) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _closeTrove(_borrower, Status.closedByOwner);\r\n    }\r\n\r\n    function _closeTrove(address _borrower, Status closedStatus) internal {\r\n        assert(closedStatus != Status.nonExistent && closedStatus != Status.active);\r\n\r\n        uint TroveOwnersArrayLength = TroveOwners.length;\r\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\r\n\r\n        Troves[_borrower].status = closedStatus;\r\n        Troves[_borrower].coll = 0;\r\n        Troves[_borrower].debt = 0;\r\n\r\n        rewardSnapshots[_borrower].ETH = 0;\r\n        rewardSnapshots[_borrower].RUBCDebt = 0;\r\n\r\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\r\n        sortedTroves.remove(_borrower);\r\n    }\r\n\r\n    /*\r\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\r\n    * Used in a liquidation sequence.\r\n    *\r\n    * The calculation excludes a portion of collateral that is in the ActivePool:\r\n    *\r\n    * the total ETH gas compensation from the liquidation sequence\r\n    *\r\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\r\n    */\r\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint _collRemainder) internal {\r\n        totalStakesSnapshot = totalStakes;\r\n\r\n        uint activeColl = _activePool.getETH();\r\n        uint liquidatedColl = defaultPool.getETH();\r\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\r\n\r\n        emit SystemSnapshotsUpdated(totalStakesSnapshot, totalCollateralSnapshot);\r\n    }\r\n\r\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\r\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _addTroveOwnerToArray(_borrower);\r\n    }\r\n\r\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\r\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum RUBC\r\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 RUBC dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\r\n\r\n        // Push the Troveowner to the array\r\n        TroveOwners.push(_borrower);\r\n\r\n        // Record the index of the new Troveowner on their Trove struct\r\n        index = uint128(TroveOwners.length.sub(1));\r\n        Troves[_borrower].arrayIndex = index;\r\n\r\n        return index;\r\n    }\r\n\r\n    /*\r\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\r\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\r\n    */\r\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\r\n        Status troveStatus = Troves[_borrower].status;\r\n        // It\u2019s set in caller function `_closeTrove`\r\n        assert(troveStatus != Status.nonExistent && troveStatus != Status.active);\r\n\r\n        uint128 index = Troves[_borrower].arrayIndex;\r\n        uint length = TroveOwnersArrayLength;\r\n        uint idxLast = length.sub(1);\r\n\r\n        assert(index <= idxLast);\r\n\r\n        address addressToMove = TroveOwners[idxLast];\r\n\r\n        TroveOwners[index] = addressToMove;\r\n        Troves[addressToMove].arrayIndex = index;\r\n        emit TroveIndexUpdated(addressToMove, index);\r\n\r\n        TroveOwners.pop();\r\n    }\r\n\r\n    // --- Recovery Mode and TCR functions ---\r\n\r\n    function getTCR(uint _price) external view override returns (uint) {\r\n        return _getTCR(_price);\r\n    }\r\n\r\n    function checkRecoveryMode(uint _price) external view override returns (bool) {\r\n        return _checkRecoveryMode(_price);\r\n    }\r\n\r\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\r\n    function _checkPotentialRecoveryMode(\r\n        uint _entireSystemColl,\r\n        uint _entireSystemDebt,\r\n        uint _price\r\n    )\r\n        internal\r\n        pure\r\n    returns (bool)\r\n    {\r\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\r\n\r\n        return TCR < CCR;\r\n    }\r\n\r\n    // --- Redemption fee functions ---\r\n\r\n    /*\r\n    * This function has two impacts on the baseRate state variable:\r\n    * 1) decays the baseRate based on time passed since last redemption or RUBC borrowing operation.\r\n    * then,\r\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\r\n    */\r\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price, uint _totalRUBCSupply) internal returns (uint) {\r\n        uint decayedBaseRate = _calcDecayedBaseRate();\r\n\r\n        /* Convert the drawn ETH back to RUBC at face value rate (1 RUBC:1 USD), in order to get\r\n        * the fraction of total supply that was redeemed at face value. */\r\n        uint redeemedRUBCFraction = _ETHDrawn.mul(_price).div(_totalRUBCSupply);\r\n\r\n        uint newBaseRate = decayedBaseRate.add(redeemedRUBCFraction.div(BETA));\r\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\r\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above\r\n        assert(newBaseRate > 0); // Base rate is always non-zero after redemption\r\n\r\n        // Update the baseRate state variable\r\n        baseRate = newBaseRate;\r\n        emit BaseRateUpdated(newBaseRate);\r\n        \r\n        _updateLastFeeOpTime();\r\n\r\n        return newBaseRate;\r\n    }\r\n\r\n    function getRedemptionRate() public view override returns (uint) {\r\n        return _calcRedemptionRate(baseRate);\r\n    }\r\n\r\n    function getRedemptionRateWithDecay() public view override returns (uint) {\r\n        return _calcRedemptionRate(_calcDecayedBaseRate());\r\n    }\r\n\r\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\r\n        return LiquityMath._min(\r\n            REDEMPTION_FEE_FLOOR.add(_baseRate),\r\n            DECIMAL_PRECISION // cap at a maximum of 100%\r\n        );\r\n    }\r\n\r\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\r\n        return _calcRedemptionFee(getRedemptionRate(), _ETHDrawn);\r\n    }\r\n\r\n    function getRedemptionFeeWithDecay(uint _ETHDrawn) external view override returns (uint) {\r\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _ETHDrawn);\r\n    }\r\n\r\n    function _calcRedemptionFee(uint _redemptionRate, uint _ETHDrawn) internal pure returns (uint) {\r\n        uint redemptionFee = _redemptionRate.mul(_ETHDrawn).div(DECIMAL_PRECISION);\r\n        require(redemptionFee < _ETHDrawn, \"TroveManager: Fee would eat up all returned collateral\");\r\n        return redemptionFee;\r\n    }\r\n\r\n    // --- Borrowing fee functions ---\r\n\r\n    function getBorrowingRate() public view override returns (uint) {\r\n        return _calcBorrowingRate(baseRate);\r\n    }\r\n\r\n    function getBorrowingRateWithDecay() public view override returns (uint) {\r\n        return _calcBorrowingRate(_calcDecayedBaseRate());\r\n    }\r\n\r\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\r\n        return LiquityMath._min(\r\n            BORROWING_FEE_FLOOR.add(_baseRate),\r\n            MAX_BORROWING_FEE\r\n        );\r\n    }\r\n\r\n    function getBorrowingFee(uint _RUBCDebt) external view override returns (uint) {\r\n        return _calcBorrowingFee(getBorrowingRate(), _RUBCDebt);\r\n    }\r\n\r\n    function getBorrowingFeeWithDecay(uint _RUBCDebt) external view override returns (uint) {\r\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _RUBCDebt);\r\n    }\r\n\r\n    function _calcBorrowingFee(uint _borrowingRate, uint _RUBCDebt) internal pure returns (uint) {\r\n        return _borrowingRate.mul(_RUBCDebt).div(DECIMAL_PRECISION);\r\n    }\r\n\r\n\r\n    // Updates the baseRate state variable based on time elapsed since the last redemption or RUBC borrowing operation.\r\n    function decayBaseRateFromBorrowing() external override {\r\n        _requireCallerIsBorrowerOperations();\r\n\r\n        uint decayedBaseRate = _calcDecayedBaseRate();\r\n        assert(decayedBaseRate <= DECIMAL_PRECISION);  // The baseRate can decay to 0\r\n\r\n        baseRate = decayedBaseRate;\r\n        emit BaseRateUpdated(decayedBaseRate);\r\n\r\n        _updateLastFeeOpTime();\r\n    }\r\n\r\n    // --- Internal fee functions ---\r\n\r\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\r\n    function _updateLastFeeOpTime() internal {\r\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\r\n\r\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\r\n            lastFeeOperationTime = block.timestamp;\r\n            emit LastFeeOpTimeUpdated(block.timestamp);\r\n        }\r\n    }\r\n\r\n    function _calcDecayedBaseRate() internal view returns (uint) {\r\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\r\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\r\n\r\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\r\n    }\r\n\r\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\r\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\r\n    }\r\n\r\n    // --- 'require' wrapper functions ---\r\n\r\n    function _requireCallerIsBorrowerOperations() internal view {\r\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\r\n    }\r\n\r\n    function _requireTroveIsActive(address _borrower) internal view {\r\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\r\n    }\r\n\r\n    function _requireRUBCBalanceCoversRedemption(IRUBC _rubc, address _redeemer, uint _amount) internal view {\r\n        require(_rubc.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's RUBC token balance\");\r\n    }\r\n\r\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\r\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\r\n    }\r\n\r\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\r\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\r\n    }\r\n\r\n    function _requireTCRoverMCR(uint _price) internal view {\r\n        require(_getTCR(_price) >= MCR, \"TroveManager: Cannot redeem when TCR < MCR\");\r\n    }\r\n\r\n    function _requireAfterBootstrapPeriod() internal view {\r\n        uint systemDeploymentTime = rbst.getDeploymentStartTime();\r\n        require(block.timestamp >= systemDeploymentTime.add(BOOTSTRAP_PERIOD), \"TroveManager: Redemptions are not allowed during bootstrap phase\");\r\n    }\r\n\r\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage) internal pure {\r\n        require(_maxFeePercentage >= REDEMPTION_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\r\n            \"Max fee percentage must be between 0.5% and 100%\");\r\n    }\r\n\r\n    // --- Trove property getters ---\r\n\r\n    function getTroveStatus(address _borrower) external view override returns (uint) {\r\n        return uint(Troves[_borrower].status);\r\n    }\r\n\r\n    function getTroveStake(address _borrower) external view override returns (uint) {\r\n        return Troves[_borrower].stake;\r\n    }\r\n\r\n    function getTroveDebt(address _borrower) external view override returns (uint) {\r\n        return Troves[_borrower].debt;\r\n    }\r\n\r\n    function getTroveColl(address _borrower) external view override returns (uint) {\r\n        return Troves[_borrower].coll;\r\n    }\r\n\r\n    // --- Trove property setters, called by BorrowerOperations ---\r\n\r\n    function setTroveStatus(address _borrower, uint _num) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n        Troves[_borrower].status = Status(_num);\r\n    }\r\n\r\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\r\n        Troves[_borrower].coll = newColl;\r\n        return newColl;\r\n    }\r\n\r\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\r\n        Troves[_borrower].coll = newColl;\r\n        return newColl;\r\n    }\r\n\r\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\r\n        Troves[_borrower].debt = newDebt;\r\n        return newDebt;\r\n    }\r\n\r\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\r\n        Troves[_borrower].debt = newDebt;\r\n        return newDebt;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n* A sorted doubly linked list with nodes sorted in descending order.\r\n*\r\n* Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\r\n* Nodes are ordered according to their current nominal individual collateral ratio (NICR),\r\n* which is like the ICR but without the price, i.e., just collateral / debt.\r\n*\r\n* The list optionally accepts insert position hints.\r\n*\r\n* NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Troves\r\n* change dynamically as liquidation events occur.\r\n*\r\n* The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Troves,\r\n* but maintains their order. A node inserted based on current NICR will maintain the correct position,\r\n* relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\r\n* Thus, Nodes remain sorted by current NICR.\r\n*\r\n* Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt\r\n* to their position.\r\n*\r\n* The list is a modification of the following audited SortedDoublyLinkedList:\r\n* https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\r\n*\r\n*\r\n* Changes made in the Liquity implementation:\r\n*\r\n* - Keys have been removed from nodes\r\n*\r\n* - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\r\n*   The list relies on the property that ordering by ICR is maintained as the ETH:USD price varies.\r\n*\r\n* - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\r\n*/\r\ncontract SortedTroves is Ownable, CheckContract, ISortedTroves {\r\n    using SafeMath for uint256;\r\n\r\n    string constant public NAME = \"SortedTroves\";\r\n\r\n    event TroveManagerAddressChanged(address _troveManagerAddress);\r\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\r\n    event NodeAdded(address _id, uint _NICR);\r\n    event NodeRemoved(address _id);\r\n\r\n    address public borrowerOperationsAddress;\r\n\r\n    ITroveManager public troveManager;\r\n\r\n    // Information for a node in the list\r\n    struct Node {\r\n        bool exists;\r\n        address nextId;                  // Id of next node (smaller NICR) in the list\r\n        address prevId;                  // Id of previous node (larger NICR) in the list\r\n    }\r\n\r\n    // Information for the list\r\n    struct Data {\r\n        address head;                        // Head of the list. Also the node in the list with the largest NICR\r\n        address tail;                        // Tail of the list. Also the node in the list with the smallest NICR\r\n        uint256 maxSize;                     // Maximum size of the list\r\n        uint256 size;                        // Current size of the list\r\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\r\n    }\r\n\r\n    Data public data;\r\n\r\n    // --- Dependency setters ---\r\n\r\n    function setParams(uint256 _size, address _troveManagerAddress, address _borrowerOperationsAddress) external override onlyOwner {\r\n        require(_size > 0, \"SortedTroves: Size can\u2019t be zero\");\r\n        checkContract(_troveManagerAddress);\r\n        checkContract(_borrowerOperationsAddress);\r\n\r\n        data.maxSize = _size;\r\n\r\n        troveManager = ITroveManager(_troveManagerAddress);\r\n        borrowerOperationsAddress = _borrowerOperationsAddress;\r\n\r\n        emit TroveManagerAddressChanged(_troveManagerAddress);\r\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\r\n\r\n        _renounceOwnership();\r\n    }\r\n\r\n    /*\r\n     * @dev Add a node to the list\r\n     * @param _id Node's id\r\n     * @param _NICR Node's NICR\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n\r\n    function insert (address _id, uint256 _NICR, address _prevId, address _nextId) external override {\r\n        ITroveManager troveManagerCached = troveManager;\r\n\r\n        _requireCallerIsBOorTroveM(troveManagerCached);\r\n        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);\r\n    }\r\n\r\n    function _insert(ITroveManager _troveManager, address _id, uint256 _NICR, address _prevId, address _nextId) internal {\r\n        // List must not be full\r\n        require(!isFull(), \"SortedTroves: List is full\");\r\n        // List must not already contain node\r\n        require(!contains(_id), \"SortedTroves: List already contains the node\");\r\n        // Node id must not be null\r\n        require(_id != address(0), \"SortedTroves: Id cannot be zero\");\r\n        // NICR must be non-zero\r\n        require(_NICR > 0, \"SortedTroves: NICR must be positive\");\r\n\r\n        address prevId = _prevId;\r\n        address nextId = _nextId;\r\n\r\n        if (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\r\n            // Sender's hint was not a valid insert position\r\n            // Use sender's hint to find a valid insert position\r\n            (prevId, nextId) = _findInsertPosition(_troveManager, _NICR, prevId, nextId);\r\n        }\r\n\r\n         data.nodes[_id].exists = true;\r\n\r\n        if (prevId == address(0) && nextId == address(0)) {\r\n            // Insert as head and tail\r\n            data.head = _id;\r\n            data.tail = _id;\r\n        } else if (prevId == address(0)) {\r\n            // Insert before `prevId` as the head\r\n            data.nodes[_id].nextId = data.head;\r\n            data.nodes[data.head].prevId = _id;\r\n            data.head = _id;\r\n        } else if (nextId == address(0)) {\r\n            // Insert after `nextId` as the tail\r\n            data.nodes[_id].prevId = data.tail;\r\n            data.nodes[data.tail].nextId = _id;\r\n            data.tail = _id;\r\n        } else {\r\n            // Insert at insert position between `prevId` and `nextId`\r\n            data.nodes[_id].nextId = nextId;\r\n            data.nodes[_id].prevId = prevId;\r\n            data.nodes[prevId].nextId = _id;\r\n            data.nodes[nextId].prevId = _id;\r\n        }\r\n\r\n        data.size = data.size.add(1);\r\n        emit NodeAdded(_id, _NICR);\r\n    }\r\n\r\n    function remove(address _id) external override {\r\n        _requireCallerIsTroveManager();\r\n        _remove(_id);\r\n    }\r\n\r\n    /*\r\n     * @dev Remove a node from the list\r\n     * @param _id Node's id\r\n     */\r\n    function _remove(address _id) internal {\r\n        // List must contain the node\r\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\r\n\r\n        if (data.size > 1) {\r\n            // List contains more than a single node\r\n            if (_id == data.head) {\r\n                // The removed node is the head\r\n                // Set head to next node\r\n                data.head = data.nodes[_id].nextId;\r\n                // Set prev pointer of new head to null\r\n                data.nodes[data.head].prevId = address(0);\r\n            } else if (_id == data.tail) {\r\n                // The removed node is the tail\r\n                // Set tail to previous node\r\n                data.tail = data.nodes[_id].prevId;\r\n                // Set next pointer of new tail to null\r\n                data.nodes[data.tail].nextId = address(0);\r\n            } else {\r\n                // The removed node is neither the head nor the tail\r\n                // Set next pointer of previous node to the next node\r\n                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;\r\n                // Set prev pointer of next node to the previous node\r\n                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;\r\n            }\r\n        } else {\r\n            // List contains a single node\r\n            // Set the head and tail to null\r\n            data.head = address(0);\r\n            data.tail = address(0);\r\n        }\r\n\r\n        delete data.nodes[_id];\r\n        data.size = data.size.sub(1);\r\n        NodeRemoved(_id);\r\n    }\r\n\r\n    /*\r\n     * @dev Re-insert the node at a new position, based on its new NICR\r\n     * @param _id Node's id\r\n     * @param _newNICR Node's new NICR\r\n     * @param _prevId Id of previous node for the new insert position\r\n     * @param _nextId Id of next node for the new insert position\r\n     */\r\n    function reInsert(address _id, uint256 _newNICR, address _prevId, address _nextId) external override {\r\n        ITroveManager troveManagerCached = troveManager;\r\n\r\n        _requireCallerIsBOorTroveM(troveManagerCached);\r\n        // List must contain the node\r\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\r\n        // NICR must be non-zero\r\n        require(_newNICR > 0, \"SortedTroves: NICR must be positive\");\r\n\r\n        // Remove node from the list\r\n        _remove(_id);\r\n\r\n        _insert(troveManagerCached, _id, _newNICR, _prevId, _nextId);\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list contains a node\r\n     */\r\n    function contains(address _id) public view override returns (bool) {\r\n        return data.nodes[_id].exists;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list is full\r\n     */\r\n    function isFull() public view override returns (bool) {\r\n        return data.size == data.maxSize;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list is empty\r\n     */\r\n    function isEmpty() public view override returns (bool) {\r\n        return data.size == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the current size of the list\r\n     */\r\n    function getSize() external view override returns (uint256) {\r\n        return data.size;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the maximum size of the list\r\n     */\r\n    function getMaxSize() external view override returns (uint256) {\r\n        return data.maxSize;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first node in the list (node with the largest NICR)\r\n     */\r\n    function getFirst() external view override returns (address) {\r\n        return data.head;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the last node in the list (node with the smallest NICR)\r\n     */\r\n    function getLast() external view override returns (address) {\r\n        return data.tail;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the next node (with a smaller NICR) in the list for a given node\r\n     * @param _id Node's id\r\n     */\r\n    function getNext(address _id) external view override returns (address) {\r\n        return data.nodes[_id].nextId;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the previous node (with a larger NICR) in the list for a given node\r\n     * @param _id Node's id\r\n     */\r\n    function getPrev(address _id) external view override returns (address) {\r\n        return data.nodes[_id].prevId;\r\n    }\r\n\r\n    /*\r\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\r\n     * @param _NICR Node's NICR\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function validInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (bool) {\r\n        return _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\r\n    }\r\n\r\n    function _validInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (bool) {\r\n        if (_prevId == address(0) && _nextId == address(0)) {\r\n            // `(null, null)` is a valid insert position if the list is empty\r\n            return isEmpty();\r\n        } else if (_prevId == address(0)) {\r\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\r\n            return data.head == _nextId && _NICR >= _troveManager.getNominalICR(_nextId);\r\n        } else if (_nextId == address(0)) {\r\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\r\n            return data.tail == _prevId && _NICR <= _troveManager.getNominalICR(_prevId);\r\n        } else {\r\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\r\n            return data.nodes[_prevId].nextId == _nextId &&\r\n                   _troveManager.getNominalICR(_prevId) >= _NICR &&\r\n                   _NICR >= _troveManager.getNominalICR(_nextId);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\r\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD\u2019s\r\n     * @param _NICR Node's NICR\r\n     * @param _startId Id of node to start descending the list from\r\n     */\r\n    function _descendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\r\n        // If `_startId` is the head, check if the insert position is before the head\r\n        if (data.head == _startId && _NICR >= _troveManager.getNominalICR(_startId)) {\r\n            return (address(0), _startId);\r\n        }\r\n\r\n        address prevId = _startId;\r\n        address nextId = data.nodes[prevId].nextId;\r\n\r\n        // Descend the list until we reach the end or until we find a valid insert position\r\n        while (prevId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\r\n            prevId = data.nodes[prevId].nextId;\r\n            nextId = data.nodes[prevId].nextId;\r\n        }\r\n\r\n        return (prevId, nextId);\r\n    }\r\n\r\n    /*\r\n     * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\r\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD\u2019s\r\n     * @param _NICR Node's NICR\r\n     * @param _startId Id of node to start ascending the list from\r\n     */\r\n    function _ascendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\r\n        // If `_startId` is the tail, check if the insert position is after the tail\r\n        if (data.tail == _startId && _NICR <= _troveManager.getNominalICR(_startId)) {\r\n            return (_startId, address(0));\r\n        }\r\n\r\n        address nextId = _startId;\r\n        address prevId = data.nodes[nextId].prevId;\r\n\r\n        // Ascend the list until we reach the end or until we find a valid insertion point\r\n        while (nextId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\r\n            nextId = data.nodes[nextId].prevId;\r\n            prevId = data.nodes[nextId].prevId;\r\n        }\r\n\r\n        return (prevId, nextId);\r\n    }\r\n\r\n    /*\r\n     * @dev Find the insert position for a new node with the given NICR\r\n     * @param _NICR Node's NICR\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (address, address) {\r\n        return _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\r\n    }\r\n\r\n    function _findInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (address, address) {\r\n        address prevId = _prevId;\r\n        address nextId = _nextId;\r\n\r\n        if (prevId != address(0)) {\r\n            if (!contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)) {\r\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\r\n                prevId = address(0);\r\n            }\r\n        }\r\n\r\n        if (nextId != address(0)) {\r\n            if (!contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)) {\r\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\r\n                nextId = address(0);\r\n            }\r\n        }\r\n\r\n        if (prevId == address(0) && nextId == address(0)) {\r\n            // No hint - descend list starting from head\r\n            return _descendList(_troveManager, _NICR, data.head);\r\n        } else if (prevId == address(0)) {\r\n            // No `prevId` for hint - ascend list starting from `nextId`\r\n            return _ascendList(_troveManager, _NICR, nextId);\r\n        } else if (nextId == address(0)) {\r\n            // No `nextId` for hint - descend list starting from `prevId`\r\n            return _descendList(_troveManager, _NICR, prevId);\r\n        } else {\r\n            // Descend list starting from `prevId`\r\n            return _descendList(_troveManager, _NICR, prevId);\r\n        }\r\n    }\r\n\r\n    // --- 'require' functions ---\r\n\r\n    function _requireCallerIsTroveManager() internal view {\r\n        require(msg.sender == address(troveManager), \"SortedTroves: Caller is not the TroveManager\");\r\n    }\r\n\r\n    function _requireCallerIsBOorTroveM(ITroveManager _troveManager) internal view {\r\n        require(msg.sender == borrowerOperationsAddress || msg.sender == address(_troveManager),\r\n                \"SortedTroves: Caller is neither BO nor TroveM\");\r\n    }\r\n}\r\n\r\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core Liquity system. */\r\ncontract MultiTroveGetter {\r\n    struct CombinedTroveData {\r\n        address owner;\r\n\r\n        uint debt;\r\n        uint coll;\r\n        uint stake;\r\n\r\n        uint snapshotETH;\r\n        uint snapshotRUBCDebt;\r\n    }\r\n\r\n    TroveManager public troveManager; // XXX Troves missing from ITroveManager?\r\n    ISortedTroves public sortedTroves;\r\n\r\n    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves) public {\r\n        troveManager = _troveManager;\r\n        sortedTroves = _sortedTroves;\r\n    }\r\n\r\n    function getMultipleSortedTroves(int _startIdx, uint _count)\r\n        external view returns (CombinedTroveData[] memory _troves)\r\n    {\r\n        uint startIdx;\r\n        bool descend;\r\n\r\n        if (_startIdx >= 0) {\r\n            startIdx = uint(_startIdx);\r\n            descend = true;\r\n        } else {\r\n            startIdx = uint(-(_startIdx + 1));\r\n            descend = false;\r\n        }\r\n\r\n        uint sortedTrovesSize = sortedTroves.getSize();\r\n\r\n        if (startIdx >= sortedTrovesSize) {\r\n            _troves = new CombinedTroveData[](0);\r\n        } else {\r\n            uint maxCount = sortedTrovesSize - startIdx;\r\n\r\n            if (_count > maxCount) {\r\n                _count = maxCount;\r\n            }\r\n\r\n            if (descend) {\r\n                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);\r\n            } else {\r\n                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getMultipleSortedTrovesFromHead(uint _startIdx, uint _count)\r\n        internal view returns (CombinedTroveData[] memory _troves)\r\n    {\r\n        address currentTroveowner = sortedTroves.getFirst();\r\n\r\n        for (uint idx = 0; idx < _startIdx; ++idx) {\r\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\r\n        }\r\n\r\n        _troves = new CombinedTroveData[](_count);\r\n\r\n        for (uint idx = 0; idx < _count; ++idx) {\r\n            _troves[idx].owner = currentTroveowner;\r\n            (\r\n                _troves[idx].debt,\r\n                _troves[idx].coll,\r\n                _troves[idx].stake,\r\n                /* status */,\r\n                /* arrayIndex */\r\n            ) = troveManager.Troves(currentTroveowner);\r\n            (\r\n                _troves[idx].snapshotETH,\r\n                _troves[idx].snapshotRUBCDebt\r\n            ) = troveManager.rewardSnapshots(currentTroveowner);\r\n\r\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\r\n        }\r\n    }\r\n\r\n    function _getMultipleSortedTrovesFromTail(uint _startIdx, uint _count)\r\n        internal view returns (CombinedTroveData[] memory _troves)\r\n    {\r\n        address currentTroveowner = sortedTroves.getLast();\r\n\r\n        for (uint idx = 0; idx < _startIdx; ++idx) {\r\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\r\n        }\r\n\r\n        _troves = new CombinedTroveData[](_count);\r\n\r\n        for (uint idx = 0; idx < _count; ++idx) {\r\n            _troves[idx].owner = currentTroveowner;\r\n            (\r\n                _troves[idx].debt,\r\n                _troves[idx].coll,\r\n                _troves[idx].stake,\r\n                /* status */,\r\n                /* arrayIndex */\r\n            ) = troveManager.Troves(currentTroveowner);\r\n            (\r\n                _troves[idx].snapshotETH,\r\n                _troves[idx].snapshotRUBCDebt\r\n            ) = troveManager.rewardSnapshots(currentTroveowner);\r\n\r\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract TroveManager\",\"name\":\"_troveManager\",\"type\":\"address\"},{\"internalType\":\"contract ISortedTroves\",\"name\":\"_sortedTroves\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_startIdx\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getMultipleSortedTroves\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshotETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshotRUBCDebt\",\"type\":\"uint256\"}],\"internalType\":\"struct MultiTroveGetter.CombinedTroveData[]\",\"name\":\"_troves\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"troveManager\",\"outputs\":[{\"internalType\":\"contract TroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MultiTroveGetter", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000110df7bc4a8ae006fdf6bca6235d05a8451813d8000000000000000000000000e5654a5d689eb5af24e0b82b0afc46c6119046c4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f758ba333d1aa6fa03e3234a1c5e39a4b2e9de896f0220bd5c63da8873dc839e"}]}