{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@boringcrypto/boring-solidity-e06e943/contracts/BoringOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\r\\n\\r\\n// P1 - P3: OK\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\\r\\n// Edited by BoringCrypto\\r\\n\\r\\n// T1 - T4: OK\\r\\ncontract BoringOwnableData {\\r\\n    // V1 - V5: OK\\r\\n    address public owner;\\r\\n    // V1 - V5: OK\\r\\n    address public pendingOwner;\\r\\n}\\r\\n\\r\\n// T1 - T4: OK\\r\\ncontract BoringOwnable is BoringOwnableData {\\r\\n    // E1: OK\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () public {\\r\\n        owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n\\r\\n    // F1 - F9: OK\\r\\n    // C1 - C21: OK\\r\\n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\\r\\n        if (direct) {\\r\\n            // Checks\\r\\n            require(newOwner != address(0) || renounce, \\\"Ownable: zero address\\\");\\r\\n\\r\\n            // Effects\\r\\n            emit OwnershipTransferred(owner, newOwner);\\r\\n            owner = newOwner;\\r\\n            pendingOwner = address(0);\\r\\n        } else {\\r\\n            // Effects\\r\\n            pendingOwner = newOwner;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // F1 - F9: OK\\r\\n    // C1 - C21: OK\\r\\n    function claimOwnership() public {\\r\\n        address _pendingOwner = pendingOwner;\\r\\n        \\r\\n        // Checks\\r\\n        require(msg.sender == _pendingOwner, \\\"Ownable: caller != pending owner\\\");\\r\\n\\r\\n        // Effects\\r\\n        emit OwnershipTransferred(owner, _pendingOwner);\\r\\n        owner = _pendingOwner;\\r\\n        pendingOwner = address(0);\\r\\n    }\\r\\n\\r\\n    // M1 - M5: OK\\r\\n    // C1 - C21: OK\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@boringcrypto/boring-solidity-e06e943/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    // EIP 2612\\r\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n}\"\r\n    },\r\n    \"@boringcrypto/boring-solidity-e06e943/contracts/libraries/BoringERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\nlibrary BoringERC20 {\\r\\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function safeName(IERC20 token) internal view returns(string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\r\\n    }\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: Transfer failed\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, to, amount));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: TransferFrom failed\\\");\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@boringcrypto/boring-solidity-e06e943/contracts/libraries/BoringMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n// a library for performing overflow-safe math, updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math)\\r\\nlibrary BoringMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {require(b == 0 || (c = a * b)/b == a, \\\"BoringMath: Mul Overflow\\\");}\\r\\n    function to128(uint256 a) internal pure returns (uint128 c) {\\r\\n        require(a <= uint128(-1), \\\"BoringMath: uint128 Overflow\\\");\\r\\n        c = uint128(a);\\r\\n    }\\r\\n    function to64(uint256 a) internal pure returns (uint64 c) {\\r\\n        require(a <= uint64(-1), \\\"BoringMath: uint64 Overflow\\\");\\r\\n        c = uint64(a);\\r\\n    }\\r\\n    function to32(uint256 a) internal pure returns (uint32 c) {\\r\\n        require(a <= uint32(-1), \\\"BoringMath: uint32 Overflow\\\");\\r\\n        c = uint32(a);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary BoringMath128 {\\r\\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n}\\r\\n\\r\\nlibrary BoringMath64 {\\r\\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n}\\r\\n\\r\\nlibrary BoringMath32 {\\r\\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\nimport \\\"@boringcrypto/boring-solidity-e06e943/contracts/libraries/BoringERC20.sol\\\";\\n\\ninterface IRewarder {\\n    using BoringERC20 for IERC20;\\n\\n    function onSaddleReward(\\n        uint256 pid,\\n        address user,\\n        address recipient,\\n        uint256 saddleAmount,\\n        uint256 newLpAmount\\n    ) external;\\n\\n    function pendingTokens(\\n        uint256 pid,\\n        address user,\\n        uint256 saddleAmount\\n    ) external view returns (IERC20[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/SimpleRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@boringcrypto/boring-solidity-e06e943/contracts/libraries/BoringERC20.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity-e06e943/contracts/libraries/BoringMath.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity-e06e943/contracts/BoringOwnable.sol\\\";\\nimport \\\"../interfaces/IRewarder.sol\\\";\\n\\ninterface IMiniChef {\\n    function lpToken(uint256 pid) external view returns (IERC20 _lpToken);\\n}\\n\\n/**\\n * @title SimpleRewarder\\n * @notice Rewarder contract that can add one additional reward token to a specific PID in MiniChef.\\n * Emission rate is controlled by the owner of this contract, independently from MiniChef's owner.\\n * @author @0xKeno @weeb_mcgee\\n */\\ncontract SimpleRewarder is IRewarder, BoringOwnable {\\n    using BoringMath for uint256;\\n    using BoringMath128 for uint128;\\n    using BoringERC20 for IERC20;\\n\\n    uint256 private constant ACC_TOKEN_PRECISION = 1e12;\\n\\n    /// @notice Info of each Rewarder user.\\n    /// `amount` LP token amount the user has provided.\\n    /// `rewardDebt` The amount of Reward Token entitled to the user.\\n    struct UserInfo {\\n        uint256 amount;\\n        uint256 rewardDebt;\\n    }\\n\\n    /// @notice Info of the rewarder pool\\n    struct PoolInfo {\\n        uint128 accToken1PerShare;\\n        uint64 lastRewardTime;\\n    }\\n\\n    /// @notice Address of the token that should be given out as rewards.\\n    IERC20 public rewardToken;\\n\\n    /// @notice Var to track the rewarder pool.\\n    PoolInfo public poolInfo;\\n\\n    /// @notice Info of each user that stakes LP tokens.\\n    mapping(address => UserInfo) public userInfo;\\n\\n    /// @notice Total emission rate of the reward token per second\\n    uint256 public rewardPerSecond;\\n    /// @notice Address of the lp token that should be incentivized\\n    IERC20 public masterLpToken;\\n    /// @notice PID in MiniChef that corresponds to masterLpToken\\n    uint256 public pid;\\n\\n    /// @notice MiniChef contract that will call this contract's callback function\\n    address public immutable MINICHEF;\\n\\n    event LogOnReward(\\n        address indexed user,\\n        uint256 indexed pid,\\n        uint256 amount,\\n        address indexed to\\n    );\\n    event LogUpdatePool(\\n        uint256 indexed pid,\\n        uint64 lastRewardTime,\\n        uint256 lpSupply,\\n        uint256 accToken1PerShare\\n    );\\n    event LogRewardPerSecond(uint256 rewardPerSecond);\\n    event LogInit(\\n        IERC20 indexed rewardToken,\\n        address owner,\\n        uint256 rewardPerSecond,\\n        IERC20 indexed masterLpToken\\n    );\\n\\n    /**\\n     * @notice Deploys this contract and sets immutable MiniChef address.\\n     */\\n    constructor(address _MINICHEF) public {\\n        MINICHEF = _MINICHEF;\\n    }\\n\\n    /**\\n     * @notice Modifier to restrict caller to be only MiniChef\\n     */\\n    modifier onlyMiniChef() {\\n        require(msg.sender == MINICHEF, \\\"Rewarder: caller is not MiniChef\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Serves as the constructor for clones, as clones can't have a regular constructor.\\n     * Initializes state variables with the given parameter.\\n     * @param data abi encoded data in format of (IERC20 rewardToken, address owner, uint256 rewardPerSecond, IERC20 masterLpToken, uint256 pid).\\n     */\\n    function init(bytes calldata data) public payable {\\n        require(rewardToken == IERC20(0), \\\"Rewarder: already initialized\\\");\\n        address _owner;\\n        (rewardToken, _owner, rewardPerSecond, masterLpToken, pid) = abi.decode(\\n            data,\\n            (IERC20, address, uint256, IERC20, uint256)\\n        );\\n        require(rewardToken != IERC20(0), \\\"Rewarder: bad rewardToken\\\");\\n        require(\\n            IMiniChef(MINICHEF).lpToken(pid) == masterLpToken,\\n            \\\"Rewarder: bad pid or masterLpToken\\\"\\n        );\\n        transferOwnership(_owner, true, false);\\n        emit LogInit(rewardToken, _owner, rewardPerSecond, masterLpToken);\\n    }\\n\\n    /**\\n     * @notice Callback function for when the user claims via the MiniChef contract.\\n     * @param _pid PID of the pool it was called for\\n     * @param _user address of the user who is claiming rewards\\n     * @param to address to send the reward token to\\n     * @param lpTokenAmount amount of total lp tokens that the user has it staked\\n     */\\n    function onSaddleReward(\\n        uint256 _pid,\\n        address _user,\\n        address to,\\n        uint256,\\n        uint256 lpTokenAmount\\n    ) external override onlyMiniChef {\\n        require(pid == _pid, \\\"Rewarder: bad pid init\\\");\\n\\n        PoolInfo memory pool = updatePool();\\n        UserInfo storage user = userInfo[_user];\\n        uint256 pending;\\n        if (user.amount > 0) {\\n            pending = (user.amount.mul(pool.accToken1PerShare) /\\n                ACC_TOKEN_PRECISION).sub(user.rewardDebt);\\n            rewardToken.safeTransfer(to, pending);\\n        }\\n        user.amount = lpTokenAmount;\\n        user.rewardDebt =\\n            lpTokenAmount.mul(pool.accToken1PerShare) /\\n            ACC_TOKEN_PRECISION;\\n        emit LogOnReward(_user, pid, pending, to);\\n    }\\n\\n    /**\\n     * @notice Sets the reward token per second to be distributed. Can only be called by the owner.\\n     * @param _rewardPerSecond The amount of reward token to be distributed per second.\\n     */\\n    function setRewardPerSecond(uint256 _rewardPerSecond) public onlyOwner {\\n        rewardPerSecond = _rewardPerSecond;\\n        emit LogRewardPerSecond(_rewardPerSecond);\\n    }\\n\\n    /**\\n     * @notice View function to see pending rewards for given address\\n     * @param _user Address of user.\\n     * @return pending reward for a given user.\\n     */\\n    function pendingToken(address _user) public view returns (uint256 pending) {\\n        PoolInfo memory pool = poolInfo;\\n        UserInfo storage user = userInfo[_user];\\n        uint256 accToken1PerShare = pool.accToken1PerShare;\\n        uint256 lpSupply = IMiniChef(MINICHEF).lpToken(pid).balanceOf(MINICHEF);\\n        if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\\n            uint256 time = block.timestamp.sub(pool.lastRewardTime);\\n            uint256 reward = time.mul(rewardPerSecond);\\n            accToken1PerShare = accToken1PerShare.add(\\n                reward.mul(ACC_TOKEN_PRECISION) / lpSupply\\n            );\\n        }\\n        pending = (user.amount.mul(accToken1PerShare) / ACC_TOKEN_PRECISION)\\n            .sub(user.rewardDebt);\\n    }\\n\\n    /**\\n     * @notice Returns pending reward tokens addresses and reward amounts for given address.\\n     * @dev Since SimpleRewarder supports only one additional reward, the returning arrays will only have one element.\\n     * @param user address of the user\\n     * @return rewardTokens array of reward tokens' addresses\\n     * @return rewardAmounts array of reward tokens' amounts\\n     */\\n    function pendingTokens(\\n        uint256,\\n        address user,\\n        uint256\\n    )\\n        external\\n        view\\n        override\\n        returns (IERC20[] memory rewardTokens, uint256[] memory rewardAmounts)\\n    {\\n        IERC20[] memory _rewardTokens = new IERC20[](1);\\n        _rewardTokens[0] = (rewardToken);\\n        uint256[] memory _rewardAmounts = new uint256[](1);\\n        _rewardAmounts[0] = pendingToken(user);\\n        return (_rewardTokens, _rewardAmounts);\\n    }\\n\\n    /**\\n     * @notice Updates the stored rate of emission per share since the last time this function was called.\\n     * @dev This is called whenever `onSaddleReward` is called to ensure the rewards are given out with the\\n     * correct emission rate.\\n     */\\n    function updatePool() public returns (PoolInfo memory pool) {\\n        pool = poolInfo;\\n        if (block.timestamp > pool.lastRewardTime) {\\n            uint256 lpSupply = IMiniChef(MINICHEF).lpToken(pid).balanceOf(\\n                MINICHEF\\n            );\\n\\n            if (lpSupply > 0) {\\n                uint256 time = block.timestamp.sub(pool.lastRewardTime);\\n                uint256 reward = time.mul(rewardPerSecond);\\n                pool.accToken1PerShare = pool.accToken1PerShare.add(\\n                    (reward.mul(ACC_TOKEN_PRECISION) / lpSupply).to128()\\n                );\\n            }\\n            pool.lastRewardTime = block.timestamp.to64();\\n            poolInfo = pool;\\n            emit LogUpdatePool(\\n                pid,\\n                pool.lastRewardTime,\\n                lpSupply,\\n                pool.accToken1PerShare\\n            );\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_MINICHEF\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerSecond\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"masterLpToken\",\"type\":\"address\"}],\"name\":\"LogInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LogOnReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerSecond\",\"type\":\"uint256\"}],\"name\":\"LogRewardPerSecond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lastRewardTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accToken1PerShare\",\"type\":\"uint256\"}],\"name\":\"LogUpdatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MINICHEF\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterLpToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokenAmount\",\"type\":\"uint256\"}],\"name\":\"onSaddleReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"accToken1PerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardTime\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerSecond\",\"type\":\"uint256\"}],\"name\":\"setRewardPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"accToken1PerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardTime\",\"type\":\"uint64\"}],\"internalType\":\"struct SimpleRewarder.PoolInfo\",\"name\":\"pool\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SimpleRewarder", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000691ef79e40d909c715be5e9e93738b3ff7d58534", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}