{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@yield-protocol/vault-v2/contracts/oracles/accumulator/AccumulatorMultiOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.6;\\n\\nimport \\\"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/contracts/math/WPow.sol\\\";\\nimport \\\"@yield-protocol/vault-interfaces/IOracle.sol\\\";\\n\\nimport \\\"../../constants/Constants.sol\\\";\\n\\n/**\\nA collection of independent Accumulator Oracles\\n\\nEach Accumulator is simple: it starts when `setSource` is called, \\nand each `get` call returns perSecondRate ^ (time in seconds since oracle creation)\\n */\\ncontract AccumulatorMultiOracle is IOracle, AccessControl, Constants {\\n    using CastBytes32Bytes6 for bytes32;\\n    using WPow for uint256;\\n\\n    struct Accumulator {\\n        /// @dev secondly rate\\n        uint256 perSecondRate;\\n        /// @dev rate accumulated so far - check `get` for details\\n        uint256 accumulated;\\n        /// @dev time when `accumulated` was last updated\\n        uint256 lastUpdated;\\n    }\\n\\n    mapping(bytes6 => mapping(bytes6 => Accumulator)) public sources;\\n\\n    event SourceSet(bytes6 indexed baseId, bytes6 indexed kind, uint256 startRate, uint256 perSecondRate);\\n    event PerSecondRateUpdated(bytes6 indexed baseId, bytes6 indexed kind, uint256 perSecondRate);\\n\\n    /**\\n    @notice Set a source\\n    @param baseId: base to set the source for\\n    @param kindId: kind of oracle (example: chi/rate)\\n    @param startRate: rate the oracle starts with\\n    @param perSecondRate: secondly rate\\n     */\\n    function setSource(\\n        bytes6 baseId,\\n        bytes6 kindId,\\n        uint256 startRate,\\n        uint256 perSecondRate\\n    ) external auth {\\n        Accumulator memory source = sources[baseId][kindId];\\n        require(source.accumulated == 0, \\\"Source is already set\\\");\\n\\n        sources[baseId][kindId] = Accumulator({\\n            perSecondRate: perSecondRate,\\n            accumulated: startRate,\\n            lastUpdated: block.timestamp\\n        });\\n        emit SourceSet(baseId, kindId, startRate, perSecondRate);\\n    }\\n\\n    /**\\n    @notice Updates accumulation rate\\n    \\n    The accumulation rate can only be updated on an up-to-date oracle: get() was called in the\\n    same block. See get() for more details\\n     */\\n    function updatePerSecondRate(\\n        bytes6 baseId,\\n        bytes6 kindId,\\n        uint256 perSecondRate\\n    ) external auth {\\n        Accumulator memory source = sources[baseId][kindId];\\n        require(source.accumulated != 0, \\\"Source not found\\\");\\n\\n        require(source.lastUpdated == block.timestamp, \\\"stale accumulator\\\");\\n        sources[baseId][kindId].perSecondRate = perSecondRate;\\n\\n        emit PerSecondRateUpdated(baseId, kindId, perSecondRate);\\n    }\\n\\n    /**\\n     * @notice Retrieve the latest stored accumulated rate.\\n     */\\n    function peek(\\n        bytes32 base,\\n        bytes32 kind,\\n        uint256\\n    ) external view virtual override returns (uint256 accumulated, uint256 updateTime) {\\n        Accumulator memory source = sources[base.b6()][kind.b6()];\\n        require(source.accumulated != 0, \\\"Source not found\\\");\\n\\n        accumulated = source.accumulated;\\n        require(accumulated > 0, \\\"Accumulated rate is zero\\\");\\n\\n        updateTime = block.timestamp;\\n    }\\n\\n    /**\\n    @notice Retrieve the latest accumulated rate from source, updating it if necessary.\\n\\n    Computes baseRate ^ (block.timestamp - creation timestamp)\\n\\n    pow() is not O(1), so the naive implementation will become slower as the time passes\\n    To workaround that, each time get() is called, we:\\n        1) compute the return value\\n        2) store the return value in `accumulated` field, update lastUpdated timestamp\\n\\n    Becase we have `accumulated`, step 1 becomes `accumulated * baseRate ^ (block.timestamp - lastUpdated)\\n     */\\n    function get(\\n        bytes32 base,\\n        bytes32 kind,\\n        uint256\\n    ) external virtual override returns (uint256 accumulated, uint256 updateTime) {\\n        Accumulator memory accumulator = sources[base.b6()][kind.b6()];\\n        require(accumulator.accumulated != 0, \\\"Source not found\\\");\\n\\n        uint256 secondsSinceLastUpdate = (block.timestamp - accumulator.lastUpdated);\\n        if (secondsSinceLastUpdate > 0) {\\n            accumulator.accumulated *= accumulator.perSecondRate.wpow(secondsSinceLastUpdate);\\n            accumulator.accumulated /= 1e18;\\n            accumulator.lastUpdated = block.timestamp;\\n\\n            sources[base.b6()][kind.b6()] = accumulator;\\n        }\\n\\n        accumulated = accumulator.accumulated;\\n        require(accumulated > 0, \\\"Accumulated rate is zero\\\");\\n        updateTime = block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes4` identifier. These are expected to be the \\n * signatures for all the functions in the contract. Special roles should be exposed\\n * in the external API and be unique:\\n *\\n * ```\\n * bytes4 public constant ROOT = 0x00000000;\\n * ```\\n *\\n * Roles represent restricted access to a function call. For that purpose, use {auth}:\\n *\\n * ```\\n * function foo() public auth {\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `ROOT`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {setRoleAdmin}.\\n *\\n * WARNING: The `ROOT` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\ncontract AccessControl {\\n    struct RoleData {\\n        mapping (address => bool) members;\\n        bytes4 adminRole;\\n    }\\n\\n    mapping (bytes4 => RoleData) private _roles;\\n\\n    bytes4 public constant ROOT = 0x00000000;\\n    bytes4 public constant ROOT4146650865 = 0x00000000; // Collision protection for ROOT, test with ROOT12007226833()\\n    bytes4 public constant LOCK = 0xFFFFFFFF;           // Used to disable further permissioning of a function\\n    bytes4 public constant LOCK8605463013 = 0xFFFFFFFF; // Collision protection for LOCK, test with LOCK10462387368()\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role\\n     *\\n     * `ROOT` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes4 indexed role, bytes4 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call.\\n     */\\n    event RoleGranted(bytes4 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes4 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Give msg.sender the ROOT role and create a LOCK role with itself as the admin role and no members. \\n     * Calling setRoleAdmin(msg.sig, LOCK) means no one can grant that msg.sig role anymore.\\n     */\\n    constructor () {\\n        _grantRole(ROOT, msg.sender);   // Grant ROOT to msg.sender\\n        _setRoleAdmin(LOCK, LOCK);      // Create the LOCK role by setting itself as its own admin, creating an independent role tree\\n    }\\n\\n    /**\\n     * @dev Each function in the contract has its own role, identified by their msg.sig signature.\\n     * ROOT can give and remove access to each function, lock any further access being granted to\\n     * a specific action, or even create other roles to delegate admin control over a function.\\n     */\\n    modifier auth() {\\n        require (_hasRole(msg.sig, msg.sender), \\\"Access denied\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allow only if the caller has been granted the admin role of `role`.\\n     */\\n    modifier admin(bytes4 role) {\\n        require (_hasRole(_getRoleAdmin(role), msg.sender), \\\"Only admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes4 role, address account) external view returns (bool) {\\n        return _hasRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes4 role) external view returns (bytes4) {\\n        return _getRoleAdmin(role);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n\\n     * If ``role``'s admin role is not `adminRole` emits a {RoleAdminChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function setRoleAdmin(bytes4 role, bytes4 adminRole) external virtual admin(role) {\\n        _setRoleAdmin(role, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes4 role, address account) external virtual admin(role) {\\n        _grantRole(role, account);\\n    }\\n\\n    \\n    /**\\n     * @dev Grants all of `role` in `roles` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\\n     */\\n    function grantRoles(bytes4[] memory roles, address account) external virtual {\\n        for (uint256 i = 0; i < roles.length; i++) {\\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \\\"Only admin\\\");\\n            _grantRole(roles[i], account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets LOCK as ``role``'s admin role. LOCK has no members, so this disables admin management of ``role``.\\n\\n     * Emits a {RoleAdminChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function lockRole(bytes4 role) external virtual admin(role) {\\n        _setRoleAdmin(role, LOCK);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes4 role, address account) external virtual admin(role) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes all of `role` in `roles` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\\n     */\\n    function revokeRoles(bytes4[] memory roles, address account) external virtual {\\n        for (uint256 i = 0; i < roles.length; i++) {\\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \\\"Only admin\\\");\\n            _revokeRole(roles[i], account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes4 role, address account) external virtual {\\n        require(account == msg.sender, \\\"Renounce only for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    function _hasRole(bytes4 role, address account) internal view returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    function _getRoleAdmin(bytes4 role) internal view returns (bytes4) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    function _setRoleAdmin(bytes4 role, bytes4 adminRole) internal virtual {\\n        if (_getRoleAdmin(role) != adminRole) {\\n            _roles[role].adminRole = adminRole;\\n            emit RoleAdminChanged(role, adminRole);\\n        }\\n    }\\n\\n    function _grantRole(bytes4 role, address account) internal {\\n        if (!_hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, msg.sender);\\n        }\\n    }\\n\\n    function _revokeRole(bytes4 role, address account) internal {\\n        if (_hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, msg.sender);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n\\nlibrary CastBytes32Bytes6 {\\n    function b6(bytes32 x) internal pure returns (bytes6 y){\\n        require (bytes32(y = bytes6(x)) == x, \\\"Cast overflow\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/math/WPow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./WMul.sol\\\";\\n\\nlibrary WPow {\\n    // Taken from https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol\\n    /// @dev $x ^ $n; $x is 18-decimals fixed point number\\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        uint256 baseUnit = 1e18;\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    z := baseUnit\\n                }\\n                default {\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    z := baseUnit\\n                }\\n                default {\\n                    z := x\\n                }\\n                let half := div(baseUnit, 2)\\n                for {\\n                    n := div(n, 2)\\n                } n {\\n                    n := div(n, 2)\\n                } {\\n                    let xx := mul(x, x)\\n                    if iszero(eq(div(xx, x), x)) {\\n                        revert(0, 0)\\n                    }\\n                    let xxRound := add(xx, half)\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n                    x := div(xxRound, baseUnit)\\n                    if mod(n, 2) {\\n                        let zx := mul(z, x)\\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\\n                            revert(0, 0)\\n                        }\\n                        let zxRound := add(zx, half)\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n                        z := div(zxRound, baseUnit)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/vault-interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOracle {\\n    /**\\n     * @notice Doesn't refresh the price, but returns the latest value available without doing any transactional operations:\\n     * @return value in wei\\n     */\\n    function peek(\\n        bytes32 base,\\n        bytes32 quote,\\n        uint256 amount\\n    ) external view returns (uint256 value, uint256 updateTime);\\n\\n    /**\\n     * @notice Does whatever work or queries will yield the most up-to-date price, and returns it.\\n     * @return value in wei\\n     */\\n    function get(\\n        bytes32 base,\\n        bytes32 quote,\\n        uint256 amount\\n    ) external returns (uint256 value, uint256 updateTime);\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/vault-v2/contracts/constants/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.6;\\n\\ncontract Constants {\\n    bytes32 constant CHI = \\\"CHI\\\";\\n    bytes32 constant RATE = \\\"RATE\\\";\\n    bytes6 constant ETH = \\\"00\\\";\\n}\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/math/WMul.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n\\nlibrary WMul {\\n    // Taken from https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol\\n    /// @dev Multiply an amount by a fixed point factor with 18 decimals, rounds down.\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x * y;\\n        unchecked { z /= 1e18; }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes6\",\"name\":\"baseId\",\"type\":\"bytes6\"},{\"indexed\":true,\"internalType\":\"bytes6\",\"name\":\"kind\",\"type\":\"bytes6\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"perSecondRate\",\"type\":\"uint256\"}],\"name\":\"PerSecondRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"newAdminRole\",\"type\":\"bytes4\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes6\",\"name\":\"baseId\",\"type\":\"bytes6\"},{\"indexed\":true,\"internalType\":\"bytes6\",\"name\":\"kind\",\"type\":\"bytes6\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"perSecondRate\",\"type\":\"uint256\"}],\"name\":\"SourceSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LOCK\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCK8605463013\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT4146650865\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"base\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"kind\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"accumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"roles\",\"type\":\"bytes4[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRoles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"}],\"name\":\"lockRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"base\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"kind\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"peek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"accumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"roles\",\"type\":\"bytes4[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRoles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"bytes4\",\"name\":\"adminRole\",\"type\":\"bytes4\"}],\"name\":\"setRoleAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes6\",\"name\":\"baseId\",\"type\":\"bytes6\"},{\"internalType\":\"bytes6\",\"name\":\"kindId\",\"type\":\"bytes6\"},{\"internalType\":\"uint256\",\"name\":\"startRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perSecondRate\",\"type\":\"uint256\"}],\"name\":\"setSource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes6\",\"name\":\"\",\"type\":\"bytes6\"},{\"internalType\":\"bytes6\",\"name\":\"\",\"type\":\"bytes6\"}],\"name\":\"sources\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"perSecondRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdated\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes6\",\"name\":\"baseId\",\"type\":\"bytes6\"},{\"internalType\":\"bytes6\",\"name\":\"kindId\",\"type\":\"bytes6\"},{\"internalType\":\"uint256\",\"name\":\"perSecondRate\",\"type\":\"uint256\"}],\"name\":\"updatePerSecondRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AccumulatorMultiOracle", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}